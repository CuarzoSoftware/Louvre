<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Louvre: Chapter 10: Toplevels</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="Logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">Louvre<span id="projectnumber">&#160;v2.18.1-1</span>
   </div>
   <div id="projectbrief">C++ library for Wayland compositors</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Chapter 10: Toplevels</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>As previously discussed, toplevel surfaces represent the typical windows containing a title bar and buttons for close, minimize, and maximize actions. They are perhaps the most common type of surfaces encountered in a compositor during everyday use.</p>
<center> <img src="https://lh3.googleusercontent.com/PvNaxLgkjaPryJ8W_P3bDOccQu1m-zNEcI7aH_R8WggzylV5LQZtuzLTUSImThDI8IVsAI9DERF4cwvSqPAEAyjsihHuPCQlZAbvu33iMC2iXvpTswZC3RBNDyKm1YEWDnnKeCn2Qw=w2400" alt="" style="max-width:45vw" class="inline"/> </center><p>Toplevels can either exist independently or serve as children of other toplevels, such as dialogs do. The functionality of toplevels is primarily managed within the <a class="el" href="class_louvre_1_1_l_toplevel_role.html" title="Toplevel role for surfaces.">Louvre::LToplevelRole</a> class. In this chapter, we will learn how to interact with them and handle their various requests.</p>
<h2><a class="anchor" id="state-flags"></a>
State Flags</h2>
<p>Toplevel surfaces can exhibit different states, which are listed in the <a class="el" href="class_louvre_1_1_l_toplevel_role.html#af874aae4fd3a2f77be9a6bedebe79048" title="Flags indicating the possible states of a Toplevel.">Louvre::LToplevelRole::State</a> flags enum. Among these states, the most common ones include:</p>
<ul>
<li><a class="el" href="class_louvre_1_1_l_toplevel_role.html#af874aae4fd3a2f77be9a6bedebe79048aed92813456b4cfc1005edc3b2c136a25" title="Activated (its decorations stand out from others)">Louvre::LToplevelRole::Activated</a>: When this flag is set, the toplevel's decorations are highlighted above others. Only one toplevel can be active at a time.</li>
<li><a class="el" href="class_louvre_1_1_l_toplevel_role.html#af874aae4fd3a2f77be9a6bedebe79048ac27e8f3bafa7f65f324fb932ccda524e" title="Maximized.">Louvre::LToplevelRole::Maximized</a>: When this flag is enabled, the toplevel typically removes its decorations and occupies a significant portion of the screen.</li>
<li><a class="el" href="class_louvre_1_1_l_toplevel_role.html#af874aae4fd3a2f77be9a6bedebe79048a442ecc88f57a81fcf5161137646b031f" title="Fullscreen mode.">Louvre::LToplevelRole::Fullscreen</a>: Enabling this flag typically results in the toplevel removing its decorations and completely occupying the entire screen, always staying displayed above other surfaces (except for its child surfaces).</li>
<li><a class="el" href="class_louvre_1_1_l_toplevel_role.html#af874aae4fd3a2f77be9a6bedebe79048a3e3838f5e5c1188df5ec36eab5439f36" title="In interactive resizing.">Louvre::LToplevelRole::Resizing</a>: This flag indicates an ongoing interactive resizing session, usually initiated when the user drags one of its corners.</li>
</ul>
<blockquote class="doxtable">
<p>&zwj;Toplevels can also request to be minimized, but this is not considered a toplevel state. </p>
</blockquote>
<h2><a class="anchor" id="current-and-pending-states"></a>
Current and Pending States</h2>
<p>To set the state flags of a toplevel, you can select from various Louvre::LToplevelRole::configure() variants, which also allow you to specify the desired size. If you provide a size of (0,0), the client is at liberty to determine its own dimensions. You can retrieve the current toplevel state flags and size using the Louvre::LToplevelRole::states() and Louvre::LToplevelRole::size() properties.</p>
<p>It's crucial to recognize that the state of a toplevel doesn't immediately change upon calling Louvre::LToplevelRole::configure(). You must await the respective property listener to detect the actual state change. For instance, if you configure a toplevel with the <a class="el" href="class_louvre_1_1_l_toplevel_role.html#af874aae4fd3a2f77be9a6bedebe79048ac27e8f3bafa7f65f324fb932ccda524e" title="Maximized.">Louvre::LToplevelRole::Maximized</a> flag, wait for the Louvre::LToplevelRole::maximizedChanged() event to ensure proper positioning. Alternatively, monitor changes in any state using Louvre::LToplevelRole::statesChanged().</p>
<p>As mentioned earlier, you can access the current size and state flags of the toplevel with Louvre::LToplevelRole::size() and Louvre::LToplevelRole::states(), respectively. Meanwhile, Louvre::LToplevelRole::pendingSize() and Louvre::LToplevelRole::pendingStates() represent the values from the last Louvre::LToplevelRole::configure() that has not yet been acknowledged.</p>
<p>Once a configuration is acknowledged by the client (when the current state and size actually change), the values of pending state and size are updated to match the current state and size. It's important to note that you will likely call Louvre::LToplevelRole::configure() multiple times before these changes are acknowledged by the client. Therefore, using the pending size and state flags when configuring is advisable to avoid undesired results stemming from potential race conditions.</p>
<h2><a class="anchor" id="window-geometry-1"></a>
Window Geometry</h2>
<p>The size of a toplevel is not determined by its surface size but by its window geometry (<code><a class="el" href="class_louvre_1_1_l_toplevel_role.html#ad1e743fb0701cd487e363cc3609f3ac3" title="Window geometry in surface coordinates.">Louvre::LToplevelRole::windowGeometry()</a>.size()</code> or <code>Louvre::LToplevelRole::size()</code>). The window geometry specifies the rect within the surface that encompasses the actual toplevel window, excluding its decorative elements like shadows. This is the size you should take into account when configuring it.</p>
<center> <img src="https://lh3.googleusercontent.com/pw/AIL4fc9WuCZOWGGC6v7ZepWA7VOWygycmNFEngEHX7J9ODdmzm1Qs4au1KYPMRJ_102tfvOXFBcL-Kwghm0bSKbd4U6der3p94l1drpn3ONqb9yfv-uFgHQ=w2400" alt="" style="max-width:25vw;min-width:400px" class="inline"/> </center><h2><a class="anchor" id="decorations"></a>
Decorations</h2>
<p>By default, clients handle their own toplevel decorations. However, some applications, like Qt applications, implement the <a href="https://wayland.app/protocols/xdg-decoration-unstable-v1">XDG Decoration</a> protocol, allowing the compositor to take charge of drawing the decorations.</p>
<p>It's worth noting that this protocol is still somewhat experimental, and only a limited number of clients support it. Therefore, for the purpose of this tutorial, we will focus on client-side decorations. If you're interested in exploring server-side decorations, please refer to the <a href="md_md__examples.html#views">louvre-views</a> example, which creates macOS-style decorations for toplevels that support it.</p>
<h2><a class="anchor" id="interactive-events"></a>
Interactive Events</h2>
<p>Clients can request to initiate interactive moving or resizing of toplevels, typically triggered by the user clicking on its top bar or one of its corners. We will explore how to handle these requests shortly.</p>
<p>Let's begin by crafting our own <a class="el" href="class_louvre_1_1_l_toplevel_role.html" title="Toplevel role for surfaces.">Louvre::LToplevelRole</a> subclass, which we'll name <code>EToplevel</code>:</p>
<h3><a class="anchor" id="srcetoplevelh"></a>
src/EToplevel.h</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#ifndef ETOPLEVEL_H</span></div>
<div class="line"><span class="preprocessor">#define ETOPLEVEL_H</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;LToplevelRole.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespace_louvre.html">Louvre</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>ESurface;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>EToplevel : <span class="keyword">public</span> <a class="code hl_class" href="class_louvre_1_1_l_toplevel_role.html">LToplevelRole</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    EToplevel(<span class="keyword">const</span> <span class="keywordtype">void</span> *params);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">inline</span> ESurface *surf()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        <span class="keywordflow">return</span> (ESurface*) surface();</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> configureRequest() <span class="keyword">override</span>;</div>
<div class="line">    <span class="keywordtype">void</span> setMinimizedRequest() <span class="keyword">override</span>;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#endif </span><span class="comment">// ETOPLEVEL_H</span></div>
<div class="ttc" id="aclass_louvre_1_1_l_toplevel_role_html"><div class="ttname"><a href="class_louvre_1_1_l_toplevel_role.html">Louvre::LToplevelRole</a></div><div class="ttdoc">Toplevel role for surfaces.</div><div class="ttdef"><b>Definition</b> LToplevelRole.h:77</div></div>
<div class="ttc" id="anamespace_louvre_html"><div class="ttname"><a href="namespace_louvre.html">Louvre</a></div><div class="ttdoc">Namespaces.</div><div class="ttdef"><b>Definition</b> LBox.h:7</div></div>
</div><!-- fragment --><p>Here, we're overriding the <a class="el" href="class_louvre_1_1_l_toplevel_role.html#a884870ee0060d30d75795ddf9e8c521d" title="Configuration request.">Louvre::LToplevelRole::configureRequest()</a> virtual method. This method is invoked when the toplevel is created and every time it's mapped after being previously unmapped. Within this method, we should call Louvre::LToplevelRole::configure() to properly set the initial state and size of the toplevel.</p>
<p>Additionally, we've overridden <a class="el" href="class_louvre_1_1_l_toplevel_role.html#a14e219a073b1d4559be6e781ccfd3536" title="Minimize request.">Louvre::LToplevelRole::setMinimizedRequest()</a>, where we will allow the client to minimize the toplevel only if it's not in fullscreen mode. Finally, we've created an auxiliary method to perform the casting of <a class="el" href="class_louvre_1_1_l_surface.html" title="A client &quot;window&quot;.">Louvre::LSurface</a> into our custom <code>ESurface</code> type.</p>
<h3><a class="anchor" id="srcetoplevelcpp"></a>
src/EToplevel.cpp</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;EToplevel.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;ESurface.h&quot;</span></div>
<div class="line"> </div>
<div class="line">EToplevel::EToplevel(<span class="keyword">const</span> <span class="keywordtype">void</span> *params) : <a class="code hl_class" href="class_louvre_1_1_l_toplevel_role.html">LToplevelRole</a>(params) {}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> EToplevel::configureRequest()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Request the client to draw its own window decorations</span></div>
<div class="line">    setDecorationMode(ClientSide);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Configure the toplevel with (0,0) so that the client can decide the size</span></div>
<div class="line">    configure(<a class="code hl_class" href="class_louvre_1_1_l_point_template.html">LSize</a>(0, 0), pendingStates() | Activated);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> EToplevel::setMinimizedRequest()</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (!fullscreen())</div>
<div class="line">        surf()-&gt;setMinimized(<span class="keyword">true</span>);</div>
<div class="line">}</div>
<div class="ttc" id="aclass_louvre_1_1_l_point_template_html"><div class="ttname"><a href="class_louvre_1_1_l_point_template.html">Louvre::LPointTemplate&lt; Int32 &gt;</a></div></div>
</div><!-- fragment --><p>In this case, we're requesting the client to use client-side decorations. Additionally, we're configuring the toplevel with a size of (0,0), allowing it to determine its own size. Furthermore, we're adding the <a class="el" href="class_louvre_1_1_l_toplevel_role.html#af874aae4fd3a2f77be9a6bedebe79048aed92813456b4cfc1005edc3b2c136a25" title="Activated (its decorations stand out from others)">Louvre::LToplevelRole::Activated</a> state using the "|" operator. If you're not yet familiar with working with bit flags, you can refer to <a href="https://dietertack.medium.com/using-bit-flags-in-c-d39ec6e30f08">this post</a> by Dieter Tack for a detailed guide on handling them.</p>
<p>Additionally, don't overlook its virtual constructor.</p>
<h3><a class="anchor" id="srcecompositorh-9"></a>
src/ECompositor.h</h3>
<div class="fragment"><div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Virtual constructors</span></div>
<div class="line"><a class="code hl_class" href="class_louvre_1_1_l_output.html">LOutput</a> *createOutputRequest(<span class="keyword">const</span> <span class="keywordtype">void</span> *params) <span class="keyword">override</span>;</div>
<div class="line"><a class="code hl_class" href="class_louvre_1_1_l_surface.html">LSurface</a> *createSurfaceRequest(<span class="keyword">const</span> <span class="keywordtype">void</span> *params) <span class="keyword">override</span>;</div>
<div class="line"><a class="code hl_class" href="class_louvre_1_1_l_pointer.html">LPointer</a> *createPointerRequest(<span class="keyword">const</span> <span class="keywordtype">void</span> *params) <span class="keyword">override</span>;</div>
<div class="line"><a class="code hl_class" href="class_louvre_1_1_l_keyboard.html">LKeyboard</a> *createKeyboardRequest(<span class="keyword">const</span> <span class="keywordtype">void</span> *params) <span class="keyword">override</span>;</div>
<div class="line"><a class="code hl_class" href="class_louvre_1_1_l_toplevel_role.html">LToplevelRole</a> *createToplevelRoleRequest(<span class="keyword">const</span> <span class="keywordtype">void</span> *params) <span class="keyword">override</span>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
<div class="ttc" id="aclass_louvre_1_1_l_keyboard_html"><div class="ttname"><a href="class_louvre_1_1_l_keyboard.html">Louvre::LKeyboard</a></div><div class="ttdoc">Class for handling keyboard events.</div><div class="ttdef"><b>Definition</b> LKeyboard.h:26</div></div>
<div class="ttc" id="aclass_louvre_1_1_l_output_html"><div class="ttname"><a href="class_louvre_1_1_l_output.html">Louvre::LOutput</a></div><div class="ttdoc">A display rendering interface.</div><div class="ttdef"><b>Definition</b> LOutput.h:215</div></div>
<div class="ttc" id="aclass_louvre_1_1_l_pointer_html"><div class="ttname"><a href="class_louvre_1_1_l_pointer.html">Louvre::LPointer</a></div><div class="ttdoc">Class for handling events generated by pointing devices.</div><div class="ttdef"><b>Definition</b> LPointer.h:25</div></div>
<div class="ttc" id="aclass_louvre_1_1_l_surface_html"><div class="ttname"><a href="class_louvre_1_1_l_surface.html">Louvre::LSurface</a></div><div class="ttdoc">A client &quot;window&quot;.</div><div class="ttdef"><b>Definition</b> LSurface.h:109</div></div>
</div><!-- fragment --><h3><a class="anchor" id="srcecompositorh-10"></a>
src/ECompositor.h</h3>
<div class="fragment"><div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;EToplevel.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="class_louvre_1_1_l_toplevel_role.html">LToplevelRole</a> *ECompositor::createToplevelRoleRequest(<span class="keyword">const</span> <span class="keywordtype">void</span> *params)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">new</span> EToplevel(params);</div>
<div class="line">}</div>
</div><!-- fragment --><p>After recompiling and running the compositor, you should observe that everything remains unchanged. To explore further, consider configuring the toplevels with different sizes and state flags to observe their responses.</p>
<p>You may have also noticed that upon creation, all toplevels are automatically centered on the screen. This behavior is a result of the default implementation of <a class="el" href="class_louvre_1_1_l_surface.html#a1150cf016134af22675fdb93b240ee78" title="Notifies of a change in the mapped() property.">Louvre::LSurface::mappingChanged()</a>, which centers them each time they are remapped.</p>
<p>To modify this behavior, let's override it and introduce a boolean variable in our <code>ESurface</code> class. This variable will ensure that the toplevels are centered only during their initial mapping.</p>
<h3><a class="anchor" id="srcesurfaceh-2"></a>
src/ESurface.h</h3>
<div class="fragment"><div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>EToplevel;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>ESurface : <span class="keyword">public</span> <a class="code hl_class" href="class_louvre_1_1_l_surface.html">LSurface</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">inline</span> EToplevel *tl()</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> (EToplevel*)toplevel();</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> mappingChanged() <span class="keyword">override</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">bool</span> firstMapping { <span class="keyword">true</span> };</div>
<div class="line">};</div>
</div><!-- fragment --><p>We initialize <code>firstMapping</code> as <code>true</code>, and after the initial mapping, we set it to <code>false</code>.</p>
<h3><a class="anchor" id="srcesurfacecpp-3"></a>
src/ESurface.cpp</h3>
<div class="fragment"><div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;EToplevel.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> ESurface::mappingChanged()</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (mapped() &amp;&amp; firstMapping)</div>
<div class="line">    {</div>
<div class="line">        firstMapping = <span class="keyword">false</span>;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// We only center toplevels the first time they are mapped</span></div>
<div class="line">        <span class="keywordflow">if</span> (tl())</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">// Use the output where the cursor is currently located</span></div>
<div class="line">            <a class="code hl_class" href="class_louvre_1_1_l_output.html">LOutput</a> *output { cursor()-&gt;<a class="code hl_function" href="class_louvre_1_1_l_cursor.html#a78cead834241e232298bef395516b2ee">output</a>() };</div>
<div class="line"> </div>
<div class="line">            <span class="comment">// If output == nullptr it means there is no initialized output</span></div>
<div class="line">            <span class="keywordflow">if</span> (!output)</div>
<div class="line">                <span class="keywordflow">return</span>;</div>
<div class="line"> </div>
<div class="line">            <span class="comment">// Restrict the area to the output size - the topbar area</span></div>
<div class="line">            <span class="keyword">const</span> <a class="code hl_class" href="class_louvre_1_1_l_point_template.html">LSize</a> availableSize { output-&gt;size() - <a class="code hl_class" href="class_louvre_1_1_l_point_template.html">LSize</a>(0, TOPBAR_HEIGHT) };</div>
<div class="line"> </div>
<div class="line">            <span class="comment">// Center the toplevel</span></div>
<div class="line">            setPos( (output-&gt;pos() + <a class="code hl_class" href="class_louvre_1_1_l_point_template.html">LPoint</a>(0, TOPBAR_HEIGHT)) + (availableSize - tl()-&gt;size()) / 2);</div>
<div class="line"> </div>
<div class="line">            <span class="comment">// Prevent positioning it under the topbar (when the toplevel height is greater than dstSize.h())</span></div>
<div class="line">            <span class="keywordflow">if</span> (pos().y() &lt; output-&gt;pos().y() + TOPBAR_HEIGHT)</div>
<div class="line">                setY(output-&gt;pos().y() + TOPBAR_HEIGHT);</div>
<div class="line"> </div>
<div class="line">            output-&gt;repaint();</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        raise();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Note: LSurfaceViews are automatically hidden when their surfaces are unmapped */</span></div>
<div class="line"> </div>
<div class="line">    <a class="code hl_function" href="namespace_louvre.html#a62750620c88ee98b1c5286f1fc339c5b">compositor</a>()-&gt;<a class="code hl_function" href="class_louvre_1_1_l_compositor.html#a05c977b22d20e051621dc42e183c2165">repaintAllOutputs</a>();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
<div class="ttc" id="aclass_louvre_1_1_l_compositor_html_a05c977b22d20e051621dc42e183c2165"><div class="ttname"><a href="class_louvre_1_1_l_compositor.html#a05c977b22d20e051621dc42e183c2165">Louvre::LCompositor::repaintAllOutputs</a></div><div class="ttdeci">void repaintAllOutputs() noexcept</div><div class="ttdoc">Unlocks the rendering thread of all initialized outputs.</div><div class="ttdef"><b>Definition</b> LCompositor.cpp:455</div></div>
<div class="ttc" id="aclass_louvre_1_1_l_cursor_html_a78cead834241e232298bef395516b2ee"><div class="ttname"><a href="class_louvre_1_1_l_cursor.html#a78cead834241e232298bef395516b2ee">Louvre::LCursor::output</a></div><div class="ttdeci">LOutput * output() const noexcept</div><div class="ttdoc">Gets the current cursor output.</div><div class="ttdef"><b>Definition</b> LCursor.cpp:350</div></div>
<div class="ttc" id="anamespace_louvre_html_a62750620c88ee98b1c5286f1fc339c5b"><div class="ttname"><a href="namespace_louvre.html#a62750620c88ee98b1c5286f1fc339c5b">Louvre::compositor</a></div><div class="ttdeci">LCompositor * compositor() noexcept</div><div class="ttdoc">Gets the static LCompositor instance.</div><div class="ttdef"><b>Definition</b> LCompositor.cpp:37</div></div>
</div><!-- fragment --><p><a class="el" href="class_louvre_1_1_l_surface.html#a1150cf016134af22675fdb93b240ee78" title="Notifies of a change in the mapped() property.">Louvre::LSurface::mappingChanged()</a> is invoked whenever there's a change in the <a class="el" href="class_louvre_1_1_l_surface.html#ac563c8ace44bf8111c0ee1c034e967e2" title="Mapped property.">Louvre::LSurface::mapped()</a> property. In contrast to the default approach, we have improved it by considering the topbar's height when centering the toplevel. When a toplevel's size exceeds the output size minus the topbar region, we reposition it downward to prevent it from appearing beneath the topbar.</p>
<h2><a class="anchor" id="interactive-toplevel-movement"></a>
Interactive Toplevel Movement</h2>
<p>Clients have the capability to request the initiation of interactive toplevel movement sessions, typically triggered when a user drags a toplevel window's titlebar. This request is managed within the <a class="el" href="class_louvre_1_1_l_toplevel_role.html#a7c9beaee827b1f8ce57ca82711897f82" title="Client request to initiate an interactive move session.">Louvre::LToplevelRole::startMoveRequest()</a> virtual method. <a class="el" href="namespace_louvre.html" title="Namespaces.">Louvre</a> also provides auxiliary methods for handling these sessions through the <a class="el" href="class_louvre_1_1_l_pointer.html" title="Class for handling events generated by pointing devices.">Louvre::LPointer</a> class.</p>
<p>To initiate an interactive toplevel movement session, use Louvre::LPointer::startMovingToplevel(). This method accepts several arguments, including the target toplevel window you intend to move and the defined constraint area that specifies where the toplevel can be positioned.</p>
<p>The toplevel's position is then updated by invoking Louvre::LPointer::updateMovingToplevelPos() within a pointer move event, as we previously demonstrated in Chapter 8: Pointer Events, taking the cursor's position into consideration.</p>
<p>Lastly, to conclude the session, we call Louvre::LPointer::stopMovingToplevel() when releasing the left pointer button as we also saw.</p>
<blockquote class="doxtable">
<p>&zwj;You are not obligated to employ the <a class="el" href="class_louvre_1_1_l_pointer.html" title="Class for handling events generated by pointing devices.">Louvre::LPointer</a> auxiliary methods for managing interactive moving toplevel sessions. Instead, you can manually update their positions using <a class="el" href="class_louvre_1_1_l_surface.html#aef41c6d77555ec63040c5baa94f3ffff" title="Assigns the position.">Louvre::LSurface::setPos()</a>, as previously explained. </p>
</blockquote>
<p>Let's customize the default behavior of <a class="el" href="class_louvre_1_1_l_toplevel_role.html#a7c9beaee827b1f8ce57ca82711897f82" title="Client request to initiate an interactive move session.">Louvre::LToplevelRole::startMoveRequest()</a> to prevent toplevel windows from being positioned under the topbar.</p>
<h3><a class="anchor" id="srcetoplevelh-1"></a>
src/EToplevel.h</h3>
<div class="fragment"><div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>EToplevel : <span class="keyword">public</span> <a class="code hl_class" href="class_louvre_1_1_l_toplevel_role.html">LToplevelRole</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> startMoveRequest() <span class="keyword">override</span>;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
</div><!-- fragment --><h3><a class="anchor" id="srcetoplevelcpp-1"></a>
src/EToplevel.cpp</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;LSeat.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;LPointer.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;LCursor.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;ESurface.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;EToplevel.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;Global.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> EToplevel::startMoveRequest()</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (!fullscreen() &amp;&amp; !maximized() &amp;&amp; surf()-&gt;hasPointerFocus())</div>
<div class="line">        seat()-&gt;<a class="code hl_function" href="class_louvre_1_1_l_seat.html#a7c55a27018215e867553eabc8ea4e89f">pointer</a>()-&gt;startMovingToplevel(</div>
<div class="line">            <span class="keyword">this</span>,                    <span class="comment">// The toplevel being dragged</span></div>
<div class="line">            cursor()-&gt;pos(),         <span class="comment">// The initial cursor position</span></div>
<div class="line">            LPointer::EdgeDisabled,  <span class="comment">// Left edge constraint</span></div>
<div class="line">            TOPBAR_HEIGHT);          <span class="comment">// Top edge constraint</span></div>
<div class="line">}</div>
<div class="ttc" id="aclass_louvre_1_1_l_seat_html_a7c55a27018215e867553eabc8ea4e89f"><div class="ttname"><a href="class_louvre_1_1_l_seat.html#a7c55a27018215e867553eabc8ea4e89f">Louvre::LSeat::pointer</a></div><div class="ttdeci">LPointer * pointer() const noexcept</div><div class="ttdoc">Access to pointer events.</div><div class="ttdef"><b>Definition</b> LSeat.h:169</div></div>
</div><!-- fragment --><p>Here, we initiate the moving session only if the toplevel has pointer focus and is not in fullscreen mode or maximized. Additionally, we impose a constraint on the top edge position by assigning it the <code>TOPBAR_HEIGHT</code> macro as the value for the T (top) argument.</p>
<p>It's worth noting that, by default, all edges are disabled. You have the option to disable a specific edge restriction by using the Louvre::LPointer::EdgeDisabled value.</p>
<p>Upon recompiling and running the compositor again, you'll observe that toplevel windows can no longer be positioned under the topbar. However, if you resize them, they still can... let's explore how to address this issue.</p>
<h2><a class="anchor" id="interactive-toplevel-resizing"></a>
Interactive Toplevel Resizing</h2>
<p>Much like interactive movement, clients can initiate a resizing session by requesting it through <a class="el" href="class_louvre_1_1_l_toplevel_role.html#af65ef9cce035874f94cf2710a35a89ab" title="Client request to initiate an interactive resize session.">Louvre::LToplevelRole::startResizeRequest()</a>. This is commonly triggered when users drag one of the corners or edges of a toplevel window.</p>
<p>The <a class="el" href="class_louvre_1_1_l_pointer.html" title="Class for handling events generated by pointing devices.">Louvre::LPointer</a> class also provides auxiliary methods to manage these toplevel resizing sessions. The process begins with a call to Louvre::LPointer::startResizingToplevel(). As the cursor position changes, we invoke Louvre::LPointer::updateResizingToplevelSize(), and each time the toplevel's size changes (handled within Louvre::LToplevelRole::geometryChanged()), we update its position using Louvre::LPointer::updateResizingToplevelPos(). Lastly, upon releasing the left pointer button (implemented in Chapter 8: Pointer Events), we call Louvre::LPointer::stopResizingToplevel() to conclude the resizing session.</p>
<blockquote class="doxtable">
<p>&zwj;It's important to note that both moving and resizing sessions will automatically stop if the toplevel is destroyed. Therefore, you don't need to be overly cautious about handling these situations yourself; the library takes care of this for you. </p>
</blockquote>
<p>The <a class="el" href="class_louvre_1_1_l_pointer.html" title="Class for handling events generated by pointing devices.">Louvre::LPointer</a> auxiliary methods internally configure the toplevel with the <a class="el" href="class_louvre_1_1_l_toplevel_role.html#af874aae4fd3a2f77be9a6bedebe79048a3e3838f5e5c1188df5ec36eab5439f36" title="In interactive resizing.">Louvre::LToplevelRole::Resizing</a> flag during the session. If you want to handle toplevel resizing sessions manually, you should configure them with that flag and unset it when it finishes.</p>
<p>Let's customize the default behavior of <a class="el" href="class_louvre_1_1_l_toplevel_role.html#af65ef9cce035874f94cf2710a35a89ab" title="Client request to initiate an interactive resize session.">Louvre::LToplevelRole::startResizeRequest()</a> to prevent toplevel windows from being positioned under the topbar.</p>
<h3><a class="anchor" id="srcetoplevelh-2"></a>
src/EToplevel.h</h3>
<div class="fragment"><div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>EToplevel : <span class="keyword">public</span> <a class="code hl_class" href="class_louvre_1_1_l_toplevel_role.html">LToplevelRole</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> startResizeRequest(ResizeEdge edge) <span class="keyword">override</span>;</div>
<div class="line">    <span class="keywordtype">void</span> geometryChanged() <span class="keyword">override</span>;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
</div><!-- fragment --><h3><a class="anchor" id="srcetoplevelcpp-2"></a>
src/EToplevel.cpp</h3>
<div class="fragment"><div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> EToplevel::startResizeRequest(ResizeEdge edge)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (!fullscreen() &amp;&amp; !maximized() &amp;&amp; surf()-&gt;hasPointerFocus())</div>
<div class="line">        seat()-&gt;<a class="code hl_function" href="class_louvre_1_1_l_seat.html#a7c55a27018215e867553eabc8ea4e89f">pointer</a>()-&gt;startResizingToplevel(</div>
<div class="line">            <span class="keyword">this</span>,                   <span class="comment">// The toplevel being resized</span></div>
<div class="line">            edge,                   <span class="comment">// Edge or corner being dragged</span></div>
<div class="line">            cursor()-&gt;pos(),        <span class="comment">// Initial cursor position</span></div>
<div class="line">            <a class="code hl_class" href="class_louvre_1_1_l_point_template.html">LSize</a>(0, 0),            <span class="comment">// Minimum allowed size</span></div>
<div class="line">            LPointer::EdgeDisabled, <span class="comment">// Left edge constraint</span></div>
<div class="line">            TOPBAR_HEIGHT);         <span class="comment">// Top edge constraint</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> EToplevel::geometryChanged()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">/* When the toplevel size changes during interactive resizing</span></div>
<div class="line"><span class="comment">     * we need to update its position depending on the dragged edge/corner */</span></div>
<div class="line">    <span class="keywordflow">if</span> (resizing())</div>
<div class="line">        updateResizingPos();</div>
<div class="line">}</div>
</div><!-- fragment --><p>Just like with the interactive moving session, we ignore the request if the toplevel is in fullscreen mode, maximized or if its surface has no pointer focus.</p>
<p>As for Louvre::LPointer::startResizingToplevel(), we pass it the toplevel being resized, the edge or corner being dragged, the current cursor position, the minimum toplevel size <code>LSize(0,0)</code> and also the positioning constraints for each toplevel size. In this case <code>TOPBAR_HEIGHT</code> for the top edge to prevent it from being positioned under the topbar.<br  />
 If you recompile and run it again, you will notice that the toplevels no longer position under the topbar while being resized.</p>
<p><img src="https://lh3.googleusercontent.com/pw/ADCreHe9h6_f3uF5llrKa4nt-n88dwoIDXtS-QA67EFT6PVFtDHdxlE5dP74X46eTuJ14sI6F_iEuQtBnsPUn0YjRHCqO0ENrLd3lBWM0d1o8lvbHUMINjY=w2400" alt="" class="inline"/></p>
<blockquote class="doxtable">
<p>&zwj;You might also observe that <b>weston-terminal</b> leaves an empty space between its toplevel window and the top bar when being resized against it. This behavior is due to <b>weston-terminal</b> using fixed size steps and is unrelated to <a class="el" href="namespace_louvre.html" title="Namespaces.">Louvre</a>. If you try another client, such as <b>gedit</b>, you'll notice that this issue doesn't occur. </p>
</blockquote>
<p>Let's now discuss how to handle maximization requests.</p>
<h2><a class="anchor" id="handling-maximization-requests"></a>
Handling Maximization Requests</h2>
<p>Clients can request to maximize their toplevels by using <a class="el" href="class_louvre_1_1_l_toplevel_role.html#a2ae840d86982053892de3157181dfaa8" title="Request to maximize.">Louvre::LToplevelRole::setMaximizedRequest()</a> and unmaximize them using <a class="el" href="class_louvre_1_1_l_toplevel_role.html#a2b8af19a843182b8b77496d08b6449e1" title="Request to unmaximize.">Louvre::LToplevelRole::unsetMaximizedRequest()</a>. This is typically done in response to user actions such as clicking the maximize button or pressing a keyboard shortcut.</p>
<p>Within these requests, we can configure the toplevels with or without the <a class="el" href="class_louvre_1_1_l_toplevel_role.html#af874aae4fd3a2f77be9a6bedebe79048ac27e8f3bafa7f65f324fb932ccda524e" title="Maximized.">Louvre::LToplevelRole::Maximized</a> flag and specify the desired size. We then wait for the Louvre::LToplevelRole::maximizedChanged() or Louvre::LToplevelRole::statesChanged() events to ensure proper positioning.</p>
<blockquote class="doxtable">
<p>&zwj;The compositor is free to ignore such requests. </p>
</blockquote>
<p>Let's override these methods to configure the toplevels based on the output size, subtracting the topbar region.</p>
<h3><a class="anchor" id="srcetoplevelh-3"></a>
src/EToplevel.h</h3>
<div class="fragment"><div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>EOutput;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>EToplevel : <span class="keyword">public</span> <a class="code hl_class" href="class_louvre_1_1_l_toplevel_role.html">LToplevelRole</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> statesChanged() <span class="keyword">override</span>;</div>
<div class="line">    <span class="keywordtype">bool</span> updateGeometry(<span class="keywordtype">bool</span> fallbackToNormalOnFail);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> setMaximized();</div>
<div class="line">    <span class="keywordtype">void</span> setMaximizedRequest() <span class="keyword">override</span>;</div>
<div class="line">    <span class="keywordtype">void</span> unsetMaximizedRequest() <span class="keyword">override</span>;</div>
<div class="line">    <span class="keywordtype">void</span> maximizedChanged()<span class="keyword"> override </span></div>
<div class="line"><span class="keyword">    </span>{ <span class="comment">/* Using statesChanged() instead */</span> };</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> saveNormalState();</div>
<div class="line"> </div>
<div class="line">    EOutput *output         { <span class="keyword">nullptr</span> };</div>
<div class="line">    <a class="code hl_class" href="class_louvre_1_1_l_point_template.html">LPointF</a> prevRelativePos { 200.f, 200.f};</div>
<div class="line">    <a class="code hl_class" href="class_louvre_1_1_l_point_template.html">LSize</a> prevSize          { 0, 0};</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
</div><!-- fragment --><p>We also introduced some auxiliary variables and methods to store and recover the toplevel's state to its previous "normal" state before maximizing it.</p>
<h3><a class="anchor" id="srcetoplevelcpp-3"></a>
src/EToplevel.cpp</h3>
<div class="fragment"><div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> EToplevel::saveNormalState()</div>
<div class="line">{</div>
<div class="line">    output = surf()-&gt;primaryOutput();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (output)</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">const</span> <a class="code hl_class" href="class_louvre_1_1_l_point_template.html">LPointF</a> localPos { surf()-&gt;pos() - output-&gt;pos() };</div>
<div class="line">        prevRelativePos = localPos / <a class="code hl_class" href="class_louvre_1_1_l_point_template.html">LSizeF</a>(output-&gt;size());</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!G::outputs().empty())</div>
<div class="line">    {</div>
<div class="line">        output = G::outputs().front();</div>
<div class="line">        prevRelativePos = <a class="code hl_class" href="class_louvre_1_1_l_point_template.html">LSizeF</a>(0.25f, 0.25f);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    prevSize = size();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
</div><!-- fragment --><p>So first, in <code>saveNormalState()</code>, we will store the current primary output, position, and size of the toplevel before it is maximized or set to fullscreen, similar to what we did when minimizing surfaces.</p>
<h3><a class="anchor" id="srcetoplevelcpp-4"></a>
src/EToplevel.cpp</h3>
<div class="fragment"><div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> EToplevel::setMaximizedRequest()</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (pendingStates() &amp; Maximized || !(surf()-&gt;hasKeyboardFocus() || surf()-&gt;hasPointerFocus()))</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line"> </div>
<div class="line">    setMaximized();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
</div><!-- fragment --><p>When a client requests to maximize the toplevel, we first check if it is already maximized or lacks pointer and keyboard focus, if so, we ignore the request.</p>
<h3><a class="anchor" id="srcetoplevelcpp-5"></a>
src/EToplevel.cpp</h3>
<div class="fragment"><div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> EToplevel::setMaximized()</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">bool</span> inNormalState = { output == <span class="keyword">nullptr</span> };</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (inNormalState)</div>
<div class="line">        saveNormalState();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Halt if zero initialized outputs</span></div>
<div class="line">    <span class="keywordflow">if</span> (!output)</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <a class="code hl_class" href="class_louvre_1_1_l_point_template.html">LSize</a> targetSize { output-&gt;size() - <a class="code hl_class" href="class_louvre_1_1_l_point_template.html">LSize</a>(0, TOPBAR_HEIGHT) };</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* If the toplevel does not support the target size, we will configure it with that size regardless.</span></div>
<div class="line"><span class="comment">     * However, we will set only the activated flag, ensuring it expands solely in size, keeping its</span></div>
<div class="line"><span class="comment">     * decorations */</span></div>
<div class="line">    <span class="keywordflow">if</span> (!sizeInRange(targetSize))</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> (inNormalState)</div>
<div class="line">            output = <span class="keyword">nullptr</span>;</div>
<div class="line"> </div>
<div class="line">        configure(targetSize, Activated);</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    configure(targetSize, Activated | Maximized);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
</div><!-- fragment --><p> Next, in our <code>setMaximized()</code> method, if the <code>output</code> variable is set, it indicates that <code>saveNormalState()</code> was previously called, and the toplevel is currently in fullscreen mode, eliminating the need to invoke it again.</p>
<p>Subsequently, we verify if the toplevel supports our target size (output size minus the topbar height). Each toplevel possesses an <a class="el" href="class_louvre_1_1_l_toplevel_role.html#a72449207b7a005d782ef71d97fe573fe" title="Gets the minimum size of the toplevel in surface coordinates.">Louvre::LToplevelRole::minSize()</a> and <a class="el" href="class_louvre_1_1_l_toplevel_role.html#a89c018cb4d03be6a1f755cd1f378f508" title="Gets the maximum size of the toplevel in surface coordinates.">Louvre::LToplevelRole::maxSize()</a>, which specify the range of sizes it can be configured with. If any component of these properties is 0, it implies no restrictions for that specific axis. <a class="el" href="class_louvre_1_1_l_toplevel_role.html#a93fef86b4fe7fc15ba2350215a88febe" title="Check if the provided size falls within the range defined by minSize() and maxSize().">Louvre::LToplevelRole::sizeInRange()</a> serves as an auxiliary function to check if the toplevel supports a given size.</p>
<p>If the toplevel does not support the given size, we configure it with that size anyway but using only the <a class="el" href="class_louvre_1_1_l_toplevel_role.html#af874aae4fd3a2f77be9a6bedebe79048aed92813456b4cfc1005edc3b2c136a25" title="Activated (its decorations stand out from others)">Louvre::LToplevelRole::Activated</a> flag. This may result in making it larger while preserving its decorations.</p>
<p>Finally, if the size is supported, we configure it with the <a class="el" href="class_louvre_1_1_l_toplevel_role.html#af874aae4fd3a2f77be9a6bedebe79048ac27e8f3bafa7f65f324fb932ccda524e" title="Maximized.">Louvre::LToplevelRole::Maximized</a> flag, typically removing its decorations.</p>
<h3><a class="anchor" id="srcetoplevelcpp-6"></a>
src/EToplevel.cpp</h3>
<div class="fragment"><div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> EToplevel::geometryChanged()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">/* When the toplevel size changes during interactive resizing</span></div>
<div class="line"><span class="comment">     * we need to update its position depending on the dragged edge/corner */</span></div>
<div class="line">    <span class="keywordflow">if</span> (resizing())</div>
<div class="line">        updateResizingPos();</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">        updateGeometry(<span class="keyword">true</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> EToplevel::updateGeometry(<span class="keywordtype">bool</span> fallbackToNormalOnFail)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (!output)</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* If the client did not adhere to our instructions, we may consider terminating it.</span></div>
<div class="line"><span class="comment">     * However, out of courtesy, we will instead reconfigure it back to its original</span></div>
<div class="line"><span class="comment">     * normal state. */</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (maximized())</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">const</span> <a class="code hl_class" href="class_louvre_1_1_l_point_template.html">LSize</a> targetSize { output-&gt;size() - <a class="code hl_class" href="class_louvre_1_1_l_point_template.html">LSize</a>(0, TOPBAR_HEIGHT) };</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (fallbackToNormalOnFail &amp;&amp; targetSize != size())</div>
<div class="line">        {</div>
<div class="line">            configure(prevSize, Activated);</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        surf()-&gt;setPos(output-&gt;pos() + <a class="code hl_class" href="class_louvre_1_1_l_point_template.html">LPoint</a>(0, TOPBAR_HEIGHT));</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> EToplevel::statesChanged()</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (!output)</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* If output is set then the toplevel changed from maximized or fullscreen</span></div>
<div class="line"><span class="comment">     * to normal */</span></div>
<div class="line">    <span class="keywordflow">if</span> (!maximized() &amp;&amp; !fullscreen())</div>
<div class="line">    {</div>
<div class="line">        G::reparentSurfaceAndChildrenViews(surf(), &amp;G::compositor()-&gt;surfacesLayer);</div>
<div class="line">        <span class="keyword">const</span> <a class="code hl_class" href="class_louvre_1_1_l_point_template.html">LPoint</a> prevPos { output-&gt;pos() + (prevRelativePos * output-&gt;size()) };</div>
<div class="line">        surf()-&gt;setPos(prevPos);</div>
<div class="line">        surf()-&gt;raise();</div>
<div class="line">        output = <span class="keyword">nullptr</span>;</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (!updateGeometry(<span class="keyword">true</span>))</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (maximized())</div>
<div class="line">    {</div>
<div class="line">        G::reparentSurfaceAndChildrenViews(surf(), &amp;G::compositor()-&gt;surfacesLayer);</div>
<div class="line">        surf()-&gt;raise();</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
</div><!-- fragment --><p>Instead of relying on Louvre::LToplevelRole::maximizedChanged() to listen for client configuration ACK, we use Louvre::LToplevelRole::statesChanged(). This notification occurs after all flags and the toplevel size are updated, proving more convenient for this scenario.</p>
<p>Here, we address all possible cases. The first scenario is when the toplevel transitions from fullscreen or maximized back to the normal state, requiring us to restore its previous normal position.</p>
<p>In the second scenario, when the window is maximized, we first verify whether the toplevel is configured with our predefined target size before proceeding using <code>updateGeometry()</code> (we will use this method to both update the toplevel's position and validate its size when <code>fallbackToNormalOnFail</code> is set to <code>true</code>). If it's not configured accordingly, we revert it to its normal state. If it is configured correctly, we position it at the top-left corner of the output, just below the top bar. This check is also performed each time there is a size change.</p>
<p>The rationale behind moving the surface view and its children to the surfaces layer will become clear shortly when we delve into handling fullscreen requests.</p>
<h3><a class="anchor" id="srcetoplevelcpp-7"></a>
src/EToplevel.cpp</h3>
<div class="fragment"><div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> EToplevel::unsetMaximizedRequest()</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (~pendingStates() &amp; Maximized || !(surf()-&gt;hasKeyboardFocus() || surf()-&gt;hasPointerFocus()))</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line"> </div>
<div class="line">    configure(prevSize, Activated);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
</div><!-- fragment --><p>Finally, when the client requests to unmaximize the toplevel, we check if it is already maximized and if it has pointer or keyboard focus before configuring it back to the normal state.</p>
<p>After recompiling and running the compositor, you'll observe that toplevels no longer maximize themselves behind the topbar, and upon unmaximizing, they return to their previous position and size.</p>
<p><img src="https://lh3.googleusercontent.com/pw/ADCreHdWo70LhuTMAzHGuj-JukFE9xgmTmf-yj0YUeuMXbLmFXoffBvJtb49yDDQUu9XxK_GmUm2Jj7ct68y0A9FoaPtddBSH0DfOhIIwMsLXSYXU44c3JE=w2400" alt="" class="inline"/></p>
<p>I made a drawing of you, successfully creating your own compositor with <a class="el" href="namespace_louvre.html" title="Namespaces.">Louvre</a>.</p>
<h2><a class="anchor" id="handling-fullscreen-requests"></a>
Handling Fullscreen Requests</h2>
<p>In order to display toplevels in fullscreen mode, we'll create a new black <a class="el" href="class_louvre_1_1_l_solid_color_view.html" title="View for displaying solid color rects.">Louvre::LSolidColorView</a> and relocate the toplevel, along with its child surfaces, into this view. This approach is necessary because <a class="el" href="class_louvre_1_1_l_toplevel_role.html#a89c018cb4d03be6a1f755cd1f378f508" title="Gets the maximum size of the toplevel in surface coordinates.">Louvre::LToplevelRole::maxSize()</a> might be smaller than the output size. In such cases, it's important to center the toplevel on the screen to ensure a visually appealing appearance. If other surfaces were left in the background during fullscreen mode, it could appear somewhat unusual.</p>
<p>Just like with maximizing toplevels, we will store the current state before entering fullscreen mode and restore it when exiting fullscreen mode.</p>
<h3><a class="anchor" id="srcetoplevelh-4"></a>
src/EToplevel.h</h3>
<div class="fragment"><div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;LSolidColorView.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;ECompositor.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;Global.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>EToplevel : <span class="keyword">public</span> <a class="code hl_class" href="class_louvre_1_1_l_toplevel_role.html">LToplevelRole</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> setFullscreen();</div>
<div class="line">    <span class="keywordtype">void</span> setFullscreenRequest(<a class="code hl_class" href="class_louvre_1_1_l_output.html">LOutput</a> *preferredOutput) <span class="keyword">override</span>;</div>
<div class="line">    <span class="keywordtype">void</span> unsetFullscreenRequest() <span class="keyword">override</span>;</div>
<div class="line">    <span class="keywordtype">void</span> fullscreenChanged()<span class="keyword"> override</span></div>
<div class="line"><span class="keyword">    </span>{ <span class="comment">/* Using statesChanged() instead */</span> };</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="class_louvre_1_1_l_solid_color_view.html">LSolidColorView</a> fullscreenBackground {</div>
<div class="line">        0.f, 0.f, 0.f, 1.f, <span class="comment">// RGBA</span></div>
<div class="line">        &amp;G::compositor()-&gt;fullscreenLayer</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
<div class="ttc" id="aclass_louvre_1_1_l_solid_color_view_html"><div class="ttname"><a href="class_louvre_1_1_l_solid_color_view.html">Louvre::LSolidColorView</a></div><div class="ttdoc">View for displaying solid color rects.</div><div class="ttdef"><b>Definition</b> LSolidColorView.h:12</div></div>
</div><!-- fragment --><h3><a class="anchor" id="srcetoplevelcpp-8"></a>
src/EToplevel.cpp</h3>
<div class="fragment"><div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line">EToplevel::EToplevel(<span class="keyword">const</span> <span class="keywordtype">void</span> *params) : <a class="code hl_class" href="class_louvre_1_1_l_toplevel_role.html">LToplevelRole</a>(params)</div>
<div class="line">{</div>
<div class="line">    fullscreenBackground.setVisible(<span class="keyword">false</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
</div><!-- fragment --><p>We start by hiding the fullscreen background initially, considering that toplevels have no state upon creation. Additionally, there's no need to explicitly define its translucent region, as we did with the wallpaper texture view. <a class="el" href="class_louvre_1_1_l_scene.html" title="Scene.">Louvre::LScene</a> automatically determines it based on the alpha (<a class="el" href="class_louvre_1_1_l_view.html#a64a46c0f9572b85ae118979de444e0f4" title="Gets the view opacity.">Louvre::LSolidColorView::opacity()</a>) value we set to <code>1.f</code> (fully opaque).</p>
<h3><a class="anchor" id="srcetoplevelcpp-9"></a>
src/EToplevel.cpp</h3>
<div class="fragment"><div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> EToplevel::setFullscreen()</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">bool</span> inNormalState = { output == <span class="keyword">nullptr</span> };</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (inNormalState)</div>
<div class="line">        saveNormalState();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Halt if zero initialized outputs</span></div>
<div class="line">    <span class="keywordflow">if</span> (!output)</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <a class="code hl_class" href="class_louvre_1_1_l_point_template.html">LSize</a> &amp;targetSize { output-&gt;size() };</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Unlike maximizing, we can simply center the toplevel if its max size is smaller than the output size</span></div>
<div class="line"><span class="comment">     * on the other hand, if its min size is larger than the output size, then we simply ignore the request */</span></div>
<div class="line">    <span class="keywordflow">if</span> ( (minSize().w() &gt; targetSize.w() &amp;&amp; minSize().w() != 0 ) || (minSize().h() &gt; targetSize.h() &amp;&amp; minSize().h() != 0 ) )</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> (inNormalState)</div>
<div class="line">            output = <span class="keyword">nullptr</span>;</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    configure(targetSize, Activated | Fullscreen);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> EToplevel::setFullscreenRequest(<a class="code hl_class" href="class_louvre_1_1_l_output.html">LOutput</a> *preferredOutput)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">/* Clients can request to display the toplevel on a specific output</span></div>
<div class="line"><span class="comment">     * or pass nullptr if they have no preference. For simplicity we are</span></div>
<div class="line"><span class="comment">     * simply ignoring them */</span></div>
<div class="line">    L_UNUSED(preferredOutput)</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (pendingStates() &amp; Fullscreen || !(surf()-&gt;hasKeyboardFocus() || surf()-&gt;hasPointerFocus()))</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line"> </div>
<div class="line">    setFullscreen();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
</div><!-- fragment --><p>When a client requests to set a toplevel into fullscreen mode, we adopt a similar approach to what we did for maximize requests. The <code>preferredOutput</code> parameter represents the client's preferred output for fullscreen mode, which can be <code>nullptr</code> if no preference is specified. For simplicity, we simply ignore it and use the output we have selected.</p>
<p>Unlike a maximize request, we configure it with the <a class="el" href="class_louvre_1_1_l_toplevel_role.html#af874aae4fd3a2f77be9a6bedebe79048a442ecc88f57a81fcf5161137646b031f" title="Fullscreen mode.">Louvre::LToplevelRole::Fullscreen</a> flag and using the entire output size, even if its maximum size is smaller than the output. In such cases, we will simply center it on the screen.</p>
<blockquote class="doxtable">
<p>&zwj;Adhering to the <a href="https://wayland.app/protocols/xdg-shell#xdg_toplevel:request:set_maximized">XDG Shell protocol</a>, we must always configure toplevels when clients request either setting or unsetting them in maximized or fullscreen mode. This applies even if for example a toplevel is already maximized, and the client seeks to maximize it again. If you do not explicitly configure the toplevels during these requests, <a class="el" href="namespace_louvre.html" title="Namespaces.">Louvre</a> will automatically handle the configuration for you, retaining the current pending states and size using <code>configure(pendingStates())</code>. </p>
</blockquote>
<h3><a class="anchor" id="srcetoplevelcpp-10"></a>
src/EToplevel.cpp</h3>
<div class="fragment"><div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> EToplevel::updateGeometry(<span class="keywordtype">bool</span> fallbackToNormalOnFail)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// ..</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (maximized())</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// ...</span></div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (fullscreen())</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">const</span> <a class="code hl_class" href="class_louvre_1_1_l_point_template.html">LSize</a> &amp;targetSize { output-&gt;size() };</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (fallbackToNormalOnFail &amp;&amp; (size().w() &gt; targetSize.w() || size().h() &gt; targetSize.h()))</div>
<div class="line">        {</div>
<div class="line">            configure(prevSize, Activated);</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        fullscreenBackground.setPos(output-&gt;pos());</div>
<div class="line">        fullscreenBackground.setSize(output-&gt;size());</div>
<div class="line"> </div>
<div class="line">        <span class="keyword">const</span> <a class="code hl_class" href="class_louvre_1_1_l_point_template.html">LPoint</a> centeredPos { output-&gt;pos() + output-&gt;size() / 2 - size() / 2 };</div>
<div class="line">        surf()-&gt;setPos(centeredPos);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> EToplevel::statesChanged()</div>
<div class="line">{</div>
<div class="line">    fullscreenBackground.setVisible(fullscreen());</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (!output)</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (!updateGeometry(<span class="keyword">true</span>))</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (maximized())</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// ...</span></div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (fullscreen())</div>
<div class="line">        G::reparentSurfaceAndChildrenViews(surf(), &amp;fullscreenBackground);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
</div><!-- fragment --><p>Upon receiving the client's configuration acknowledgment, we toggle the visibility of the <code>fullscreenBackground</code>, update its size and position, and incorporate the toplevel surface view and its children into it. Additionally, we check if the toplevel size exceeds that of the screen, in such cases, we revert its configuration back to normal. Finally, we center the toplevel.</p>
<blockquote class="doxtable">
<p>&zwj;An alternative approach could involve clipping the views to the <code>fullscreenBackground</code>. To implement this, you would need to enable parent clipping for all views using <a class="el" href="class_louvre_1_1_l_view.html#a0591ea5d02cca4d390974ca297841f2a" title="Toggles parent clipping.">Louvre::LView::enableParentClipping()</a>. </p>
</blockquote>
<h3><a class="anchor" id="srcetoplevelcpp-11"></a>
src/EToplevel.cpp</h3>
<div class="fragment"><div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> EToplevel::unsetFullscreenRequest()</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (~pendingStates() &amp; Fullscreen || !(surf()-&gt;hasKeyboardFocus() || surf()-&gt;hasPointerFocus()))</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line"> </div>
<div class="line">    configure(prevSize, Activated);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
</div><!-- fragment --><p>Finally, we address unfullscreen requests in a manner similar to how we handled unmaximization requests.</p>
<p>After recompiling and running the compositor, you'll observe toplevels seamlessly transitioning into fullscreen mode and returning to their normal state when exiting fullscreen mode. Note: Clients usually let users toggle fullscreen mode by pressing <code>F1</code>.</p>
<h2><a class="anchor" id="managing-surface-parent-changes"></a>
Managing Surface Parent Changes</h2>
<p>As we relocate the fullscreen toplevels and their child surfaces into the <code>fullscreenBackground</code> view, it's essential to ensure that any newly created child surfaces are also relocated. To accomplish this, we can override the <a class="el" href="class_louvre_1_1_l_surface.html#a2148e1e9be424c7b640f56f96bd7083f" title="Notifies a change of parent.">Louvre::LSurface::parentChanged()</a> virtual method.</p>
<h3><a class="anchor" id="srcesurfaceh-3"></a>
src/ESurface.h</h3>
<div class="fragment"><div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>ESurface : <span class="keyword">public</span> <a class="code hl_class" href="class_louvre_1_1_l_surface.html">LSurface</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> parentChanged() <span class="keyword">override</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
</div><!-- fragment --><h3><a class="anchor" id="srcesurfacecpp-4"></a>
src/ESurface.cpp</h3>
<div class="fragment"><div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> ESurface::parentChanged()</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (parent())</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">const</span> ESurface *parentSurface = { (ESurface*)parent() };</div>
<div class="line">        view.setParent(parentSurface-&gt;view.parent());</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">        view.setParent(&amp;G::compositor()-&gt;surfacesLayer);</div>
<div class="line"> </div>
<div class="line">    repaintOutputs();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
</div><!-- fragment --><p>So, whenever a surface changes its parent, we place it within the same parent view as its parent. If the surface has no parent, we position it within the surfaces layer.</p>
<h2><a class="anchor" id="managing-output-uninitialization-or-rearrangement"></a>
Managing Output Uninitialization or Rearrangement</h2>
<p>In a manner similar to our approach for minimizing surfaces, we also need to address situations where the output stored in <code>output</code> becomes uninitialized while the toplevel is in a maximized or fullscreen state. Additionally, we haven't yet covered the scenario where surfaces are no longer visible within any output after such an event occurs. To address these scenarios, let's create two new methods in <code>EOutput</code> and add a bit more code to <code>recoverViewsFromVoid()</code>.</p>
<h3><a class="anchor" id="srceoutputh-6"></a>
src/EOutput.h</h3>
<div class="fragment"><div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>EOutput : <span class="keyword">public</span> <a class="code hl_class" href="class_louvre_1_1_l_output.html">LOutput</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> updateToplevelsPos();</div>
<div class="line">    <span class="keywordtype">void</span> updateToplevelsSize();</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
</div><!-- fragment --><h3><a class="anchor" id="srceoutputcpp-16"></a>
src/EOutput.cpp</h3>
<div class="fragment"><div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;EToplevel.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> EOutput::moveGL()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line">    updateToplevelsPos();</div>
<div class="line">    G::scene()-&gt;handleMoveGL(<span class="keyword">this</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> EOutput::resizeGL()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line">    updateToplevelsSize();</div>
<div class="line">    G::scene()-&gt;handleResizeGL(<span class="keyword">this</span>);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> EOutput::updateToplevelsPos()</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">for</span> (ESurface *surface : G::surfaces())</div>
<div class="line">        if (surface-&gt;tl() &amp;&amp; surface-&gt;tl()-&gt;output == this)</div>
<div class="line">            surface-&gt;tl()-&gt;updateGeometry(false);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> EOutput::updateToplevelsSize()</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">for</span> (ESurface *surface : G::surfaces())</div>
<div class="line">    {</div>
<div class="line">        EToplevel *tl = { surface-&gt;tl() };</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (tl &amp;&amp; tl-&gt;output == <span class="keyword">this</span>)</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">if</span> (tl-&gt;pendingStates() &amp; LToplevelRole::Maximized)</div>
<div class="line">                tl-&gt;setMaximized();</div>
<div class="line">            <span class="keywordflow">else</span></div>
<div class="line">                tl-&gt;setFullscreen();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> EOutput::rescueViewsFromVoid()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Search another initialized output</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> isDiff = [<span class="keyword">this</span>](<span class="keyword">const</span> EOutput *output) { <span class="keywordflow">return</span> <span class="keyword">this</span> != output; };</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> it { std::find_if(G::outputs().begin(), G::outputs().end(), isDiff) };</div>
<div class="line">    EOutput *fallbackOutput { it != G::outputs().end() ? *it : <span class="keyword">nullptr</span> };</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (ESurface *surface : G::surfaces())</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> (surface-&gt;outputBeforeMinimize == <span class="keyword">this</span>)</div>
<div class="line">            surface-&gt;outputBeforeMinimize = fallbackOutput;</div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (surface-&gt;tl() &amp;&amp; surface-&gt;tl()-&gt;output == <span class="keyword">this</span>)</div>
<div class="line">        {</div>
<div class="line">            surface-&gt;tl()-&gt;output = <span class="keyword">nullptr</span>;</div>
<div class="line">            surface-&gt;setPos(200, 200);</div>
<div class="line">            G::reparentSurfaceAndChildrenViews(surface, &amp;G::compositor()-&gt;surfacesLayer);</div>
<div class="line">            surface-&gt;tl()-&gt;configure(surface-&gt;tl()-&gt;prevSize, LToplevelRole::Activated);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span>(surface-&gt;primaryOutput() == <span class="keyword">this</span>)</div>
<div class="line">            surface-&gt;setPos(200, 200);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"><span class="comment">// ...</span></div>
</div><!-- fragment --><p>Now, when there is a change in the output position, we invoke <code>updateToplevelsPos()</code>, which, in turn, simply calls <code>updateGeometry(false)</code> on all toplevels that are maximized or in fullscreen mode on this output. It's essential to note that this time we pass <code>false</code> because our intention is solely to update their positions and not to validate if they are correctly configured.</p>
<p>In the event of an output size change, we call <code>updateToplevelsSize()</code>, which essentially reconfigures each toplevel to fullscreen mode or maximized state but using the new output size.</p>
<p>Finally, within <code>rescueViewsFromVoid()</code> (called from <code><a class="el" href="class_louvre_1_1_l_output.html#a454d002ee90273a44dfb59a30246129e" title="Uninitialize Event.">Louvre::LOutput::uninitializeGL()</a></code>), we now revert the configuration of all toplevels that are maximized or in fullscreen mode on this output back to normal. Additionally, we relocate any surface that has this output as its primary output to the coordinates (200, 200), making them visible on the output positioned at (0, 0) (unless you are arranging outputs differently).</p>
<p>In the next chapter, we'll explore the handling of popup surfaces, which are notably simpler to manage than toplevels. See you there!</p>
<p><a href="09.md">◀ Chapter 9: Keyboard Events</a> || <a href="11.md">Chapter 11: Popups ▶</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<script>
    var menu = false;
    var burger, nav;
    function resp()
    {
        if (window.innerWidth < 768)
        {
            burger.hidden = false;
            nav.hidden = true;
        }
        else
        {
            burger.hidden = true;
            nav.hidden = false;
        }
        menu = false;
    }
    function toggleMenu()
    {
        nav.hidden = menu;
        menu = !menu;
    }
    window.onload = function()
    {
        if (typeof toggleLevel !== "undefined")
            toggleLevel(2);
        // Get all <a> tags with the "el" class
        var elLinks = document.querySelectorAll('a.el');
        // Loop through the matched elements
        elLinks.forEach(function(link) 
        {
            // Replace "Louvre::" with an empty string in the text content
            link.textContent = link.textContent.replace(/Louvre::/g, '');
        });
        nav = document.getElementById('main-nav');
        burger = document.createElement('div');
        burger.style.position = 'absolute';
        burger.style.top = '14px';
        burger.style.right = burger.style.top;
        burger.innerHTML = '<svg onclick="toggleMenu()" height="32px" viewBox="0 0 448 512"><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg>';
        document.getElementById('top').appendChild(burger);
        resp();
    };
    window.onresize = function()
    {
        resp();
    };
</script>
<div id="nav-path" class="navpath">
    <ul>
        <li class="footer">Project developed by <a href="https://github.com/CuarzoSoftware"><img class="footer" src="https://avatars.githubusercontent.com/u/29326763?s=200&v=4" style="margin-left:2px;position:relative;top:-1px;width:12px;height:12px" alt="cuarzo"/> Cuarzo Software</a></li>
    </ul>
</div>