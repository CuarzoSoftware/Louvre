<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Louvre: Chapter 5: Rendering with LPainter</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="Logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">Louvre<span id="projectnumber">&#160;v2.18.1-1</span>
   </div>
   <div id="projectbrief">C++ library for Wayland compositors</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Chapter 5: Rendering with LPainter</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>In this chapter, we will delve into the process of rendering content onto the outputs that we have previously initialized.<br  />
Each <a class="el" href="class_louvre_1_1_l_output.html" title="A display rendering interface.">Louvre::LOutput</a> operates within its own thread and provides a set of events that can be customized to suit our rendering needs.</p>
<h3><a class="anchor" id="initializegl"></a>
initializeGL()</h3>
<p>The <a class="el" href="class_louvre_1_1_l_output.html#a2aeeb1c8e8bb0f723ebb7129df23d4e8" title="Initialize Event.">Louvre::LOutput::initializeGL()</a> event is invoked once, right after we initialize the output using <a class="el" href="class_louvre_1_1_l_compositor.html#a0b328b0723a35d00bbaff5aec6b9e9e0" title="Initializes the specified output.">Louvre::LCompositor::addOutput()</a>. Within this event, your focus should be on setting up and loading any necessary OpenGL resources, such as shaders, programs, and textures. However, it's important to refrain from performing any painting operations at this stage, as they will not be visible on the screen. Instead, use <a class="el" href="class_louvre_1_1_l_output.html#a3640e75ecf0af51755b05a1e1262b25c" title="Unlocks the rendering thread.">Louvre::LOutput::repaint()</a> to schedule a new <a class="el" href="class_louvre_1_1_l_output.html#a0569e991ee4c6e4242578aca6d999741" title="Paint Event.">Louvre::LOutput::paintGL()</a> event.</p>
<h3><a class="anchor" id="paintgl"></a>
paintGL()</h3>
<p>The <a class="el" href="class_louvre_1_1_l_output.html#a0569e991ee4c6e4242578aca6d999741" title="Paint Event.">Louvre::LOutput::paintGL()</a> event is triggered asynchronously when we call <a class="el" href="class_louvre_1_1_l_output.html#a3640e75ecf0af51755b05a1e1262b25c" title="Unlocks the rendering thread.">Louvre::LOutput::repaint()</a> from any thread. Within this event, you should handle all the painting operations necessary for the current output frame.</p>
<h3><a class="anchor" id="movegl"></a>
moveGL()</h3>
<p>The <a class="el" href="class_louvre_1_1_l_output.html#aa15f67e7da7f9351890b2c6258ee9225" title="Move Event.">Louvre::LOutput::moveGL()</a> event is asynchronously triggered each time we alter the position of the output using <a class="el" href="class_louvre_1_1_l_output.html#a6ab8c3ffe18601c1d3d355c385553a4c" title="Set the position of the output.">Louvre::LOutput::setPos()</a>. It's crucial to avoid performing any painting operations within this event, as they will not be displayed on the screen. Instead, use <a class="el" href="class_louvre_1_1_l_output.html#a3640e75ecf0af51755b05a1e1262b25c" title="Unlocks the rendering thread.">Louvre::LOutput::repaint()</a> to schedule a new <a class="el" href="class_louvre_1_1_l_output.html#a0569e991ee4c6e4242578aca6d999741" title="Paint Event.">Louvre::LOutput::paintGL()</a> event.</p>
<h3><a class="anchor" id="resizegl"></a>
resizeGL()</h3>
<p>Similarly, the <a class="el" href="class_louvre_1_1_l_output.html#ad4dc5e1f724869e9523ce872afd56a1a" title="Resize Event.">Louvre::LOutput::resizeGL()</a> event is called asynchronously whenever we modify the output mode, transform or scale using <a class="el" href="class_louvre_1_1_l_output.html#a376a36620b1acd2a0d154f8993bacdb4" title="Sets the output mode.">Louvre::LOutput::setMode()</a>, <a class="el" href="class_louvre_1_1_l_output.html#ae4983ad9b25b32cd00f7b943894666a8" title="Sets the framebuffer transform.">Louvre::LOutput::setTransform()</a> or <a class="el" href="class_louvre_1_1_l_output.html#af950653f0fe07aed8acca7079047fb94" title="Sets the output scale factor.">Louvre::LOutput::setScale()</a>. Each output has one or more modes (<a class="el" href="class_louvre_1_1_l_output_mode.html" title="Output resolution and refresh rate.">Louvre::LOutputMode</a>), each of which dictates its refresh rate and resolution. The default output mode typically offers the highest refresh rate and resolution. To access all available output modes, you can use <a class="el" href="class_louvre_1_1_l_output.html#adb161afb5f8aa93896dead7d42ef5ab4" title="Available modes.">Louvre::LOutput::modes()</a>. Like the other events, it's essential not to perform any painting operations within <a class="el" href="class_louvre_1_1_l_output.html#ad4dc5e1f724869e9523ce872afd56a1a" title="Resize Event.">Louvre::LOutput::resizeGL()</a>, as they will not be visible on the screen. Instead, use <a class="el" href="class_louvre_1_1_l_output.html#a3640e75ecf0af51755b05a1e1262b25c" title="Unlocks the rendering thread.">Louvre::LOutput::repaint()</a> to schedule a new <a class="el" href="class_louvre_1_1_l_output.html#a0569e991ee4c6e4242578aca6d999741" title="Paint Event.">Louvre::LOutput::paintGL()</a> event.</p>
<h3><a class="anchor" id="uninitializegl"></a>
uninitializeGL()</h3>
<p>The <a class="el" href="class_louvre_1_1_l_output.html#a454d002ee90273a44dfb59a30246129e" title="Uninitialize Event.">Louvre::LOutput::uninitializeGL()</a> event is invoked once after we uninitialize an output using <a class="el" href="class_louvre_1_1_l_compositor.html#aa6d9794dfb7cb513f834cf503591b864" title="Uninitializes the specified output.">Louvre::LCompositor::removeOutput()</a> or when the output is unplugged. We will explore how to listen to output hotplugging events later on. Within this event, your responsibility is to release all the resources created during the <a class="el" href="class_louvre_1_1_l_output.html#a2aeeb1c8e8bb0f723ebb7129df23d4e8" title="Initialize Event.">Louvre::LOutput::initializeGL()</a> event. It's crucial to avoid any painting operations within <a class="el" href="class_louvre_1_1_l_output.html#a454d002ee90273a44dfb59a30246129e" title="Uninitialize Event.">Louvre::LOutput::uninitializeGL()</a> because they will not be displayed on the screen.</p>
<blockquote class="doxtable">
<p>&zwj;It's important to note that <a class="el" href="namespace_louvre.html" title="Namespaces.">Louvre</a> prevents you from initializing/uninitializing or changing the mode of an output from within any of these events, as doing so could lead to a deadlock. So calling <a class="el" href="class_louvre_1_1_l_compositor.html#a0b328b0723a35d00bbaff5aec6b9e9e0" title="Initializes the specified output.">Louvre::LCompositor::addOutput()</a>, <a class="el" href="class_louvre_1_1_l_compositor.html#aa6d9794dfb7cb513f834cf503591b864" title="Uninitializes the specified output.">Louvre::LCompositor::removeOutput()</a> or <a class="el" href="class_louvre_1_1_l_output.html#a376a36620b1acd2a0d154f8993bacdb4" title="Sets the output mode.">Louvre::LOutput::setMode()</a> in such cases is a no-op. </p>
</blockquote>
<h2><a class="anchor" id="custom-loutput"></a>
Custom LOutput</h2>
<p>As you might expect, <a class="el" href="namespace_louvre.html" title="Namespaces.">Louvre</a> provides a default mechanism for handling all these events, which is why you were able to see content rendered on your screens previously. Now, let's take control by overriding these virtual methods and creating our custom <a class="el" href="class_louvre_1_1_l_output.html" title="A display rendering interface.">Louvre::LOutput</a> subclass named <code>EOutput</code>.</p>
<h3><a class="anchor" id="srceoutputh"></a>
src/EOutput.h</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#ifndef EOUTPUT_H</span></div>
<div class="line"><span class="preprocessor">#define EOUTPUT_H</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;LOutput.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespace_louvre.html">Louvre</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>EOutput : <span class="keyword">public</span> <a class="code hl_class" href="class_louvre_1_1_l_output.html">LOutput</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    EOutput(<span class="keyword">const</span> <span class="keywordtype">void</span> *params);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> initializeGL() <span class="keyword">override</span>;</div>
<div class="line">    <span class="keywordtype">void</span> moveGL() <span class="keyword">override</span>;</div>
<div class="line">    <span class="keywordtype">void</span> resizeGL() <span class="keyword">override</span>;</div>
<div class="line">    <span class="keywordtype">void</span> paintGL() <span class="keyword">override</span>;</div>
<div class="line">    <span class="keywordtype">void</span> uninitializeGL() <span class="keyword">override</span>;</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="class_louvre_1_1_l_texture.html">LTexture</a> *wallpaper { <span class="keyword">nullptr</span> };</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#endif </span><span class="comment">// EOUTPUT_H</span></div>
<div class="ttc" id="aclass_louvre_1_1_l_output_html"><div class="ttname"><a href="class_louvre_1_1_l_output.html">Louvre::LOutput</a></div><div class="ttdoc">A display rendering interface.</div><div class="ttdef"><b>Definition</b> LOutput.h:215</div></div>
<div class="ttc" id="aclass_louvre_1_1_l_texture_html"><div class="ttname"><a href="class_louvre_1_1_l_texture.html">Louvre::LTexture</a></div><div class="ttdoc">OpenGL texture abstraction.</div><div class="ttdef"><b>Definition</b> LTexture.h:79</div></div>
<div class="ttc" id="anamespace_louvre_html"><div class="ttname"><a href="namespace_louvre.html">Louvre</a></div><div class="ttdoc">Namespaces.</div><div class="ttdef"><b>Definition</b> LBox.h:7</div></div>
</div><!-- fragment --><p>Here, we are simply overriding all <a class="el" href="class_louvre_1_1_l_output.html" title="A display rendering interface.">Louvre::LOutput</a> events. Additionally, we have defined a null pointer for a texture that we will use later as our background wallpaper.</p>
<blockquote class="doxtable">
<p>&zwj;The reason why we will allocate the texture on the heap is that we will only use it while the output is initialized, and we will free it when uninitialized. An <a class="el" href="class_louvre_1_1_l_output.html" title="A display rendering interface.">Louvre::LOutput</a> is not destroyed when uninitialized, it only gets destroyed when it is no longer available/plugged or during compositor uninitialization. </p>
</blockquote>
<h3><a class="anchor" id="srceoutputcpp"></a>
src/EOutput.cpp</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;LPainter.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;EOutput.h&quot;</span></div>
<div class="line"> </div>
<div class="line">EOutput::EOutput(<span class="keyword">const</span> <span class="keywordtype">void</span> *params) : <a class="code hl_class" href="class_louvre_1_1_l_output.html">LOutput</a>(params) {}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> EOutput::initializeGL()</div>
<div class="line">{</div>
<div class="line">    painter()-&gt;setClearColor(0.1f, 0.3f, 0.8f, 1.f);</div>
<div class="line">    repaint();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> EOutput::moveGL()</div>
<div class="line">{</div>
<div class="line">    repaint();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> EOutput::resizeGL()</div>
<div class="line">{</div>
<div class="line">    repaint();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> EOutput::paintGL()</div>
<div class="line">{</div>
<div class="line">    painter()-&gt;clearScreen();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> EOutput::uninitializeGL() {}</div>
</div><!-- fragment --><p>Within the code, we:</p>
<ol type="1">
<li>Modify the clear color in <a class="el" href="class_louvre_1_1_l_output.html#a2aeeb1c8e8bb0f723ebb7129df23d4e8" title="Initialize Event.">Louvre::LOutput::initializeGL()</a>.</li>
<li>Trigger <a class="el" href="class_louvre_1_1_l_output.html#a3640e75ecf0af51755b05a1e1262b25c" title="Unlocks the rendering thread.">Louvre::LOutput::repaint()</a> when the output position or size changes.</li>
<li>In <a class="el" href="class_louvre_1_1_l_output.html#a0569e991ee4c6e4242578aca6d999741" title="Paint Event.">Louvre::LOutput::paintGL()</a>, we simply clear the screen every frame without additional operations.</li>
<li>Finally, in <a class="el" href="class_louvre_1_1_l_output.html#a454d002ee90273a44dfb59a30246129e" title="Uninitialize Event.">Louvre::LOutput::uninitializeGL()</a>, no actions are taken as we haven't allocated any resources in <a class="el" href="class_louvre_1_1_l_output.html#a2aeeb1c8e8bb0f723ebb7129df23d4e8" title="Initialize Event.">Louvre::LOutput::initializeGL()</a> to this point.</li>
</ol>
<h2><a class="anchor" id="overriding-the-virtual-constructor"></a>
Overriding the Virtual Constructor</h2>
<p>To let <a class="el" href="namespace_louvre.html" title="Namespaces.">Louvre</a> use our custom <code>EOutput</code> class, we must complete one remaining task: overriding its virtual constructor, specifically Louvre::LCompositor::createOutputRequest().</p>
<h3><a class="anchor" id="srcecompositorh-1"></a>
src/ECompositor.h</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#ifndef ECOMPOSITOR_H</span></div>
<div class="line"><span class="preprocessor">#define ECOMPOSITOR_H</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;LCompositor.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespace_louvre.html">Louvre</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>ECompositor : <span class="keyword">public</span> <a class="code hl_class" href="class_louvre_1_1_l_compositor.html">LCompositor</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    ECompositor();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> initialized() <span class="keyword">override</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Virtual constructors</span></div>
<div class="line">    <a class="code hl_class" href="class_louvre_1_1_l_output.html">LOutput</a> *createOutputRequest(<span class="keyword">const</span> <span class="keywordtype">void</span> *params) <span class="keyword">override</span>;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#endif </span><span class="comment">// ECOMPOSITOR_H</span></div>
<div class="ttc" id="aclass_louvre_1_1_l_compositor_html"><div class="ttname"><a href="class_louvre_1_1_l_compositor.html">Louvre::LCompositor</a></div><div class="ttdoc">Louvre's core and objects factory.</div><div class="ttdef"><b>Definition</b> LCompositor.h:24</div></div>
</div><!-- fragment --><p>The graphic backend invokes this virtual constructor whenever it necessitates generating a new output instance. Subsequently, it employs this freshly generated output as an interface for invoking the <code>...GL()</code> events previously discussed.</p>
<h3><a class="anchor" id="srcecompositorcpp-1"></a>
src/ECompositor.cpp</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;ECompositor.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;EOutput.h&quot;</span></div>
<div class="line"> </div>
<div class="line">ECompositor::ECompositor() {}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> ECompositor::initialized() </div>
<div class="line">{ </div>
<div class="line">    <span class="comment">// ... </span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="class_louvre_1_1_l_output.html">LOutput</a> *ECompositor::createOutputRequest(<span class="keyword">const</span> <span class="keywordtype">void</span> *params)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">new</span> EOutput(params);</div>
<div class="line">}</div>
</div><!-- fragment --><blockquote class="doxtable">
<p>&zwj;Whenever you see <code>// ...</code> in a code snippet, it means that code has been omitted to reduce boilerplate. </p>
</blockquote>
<p>Instead of returning a new <a class="el" href="class_louvre_1_1_l_output.html" title="A display rendering interface.">Louvre::LOutput</a> instance as the defaults do, we return our custom <code>EOutput</code> class.</p>
<p>If you recompile and execute the compositor now, you will only see a bluish background color, probably the cursor as well, but no application windows (surfaces).</p>
<p><img src="https://lh3.googleusercontent.com/pw/ADCreHffyDKxkn-ciELGt5uBedV-47WD43mWV2HhFsf1TGT6PbSDiJussQ7Wr01A0-Xm-HYlqPobvKufFkFoFOLhWXrWIcEdmT6FMaHH6lk5BztJ_XnCuBU=w2400" alt="" class="inline"/></p>
<p>Let's proceed to learn how to render textures.</p>
<h1><a class="anchor" id="painting"></a>
Painting</h1>
<p><a class="el" href="namespace_louvre.html" title="Namespaces.">Louvre</a> offers various ways to help you render content on outputs. You can use your own OpenGL shaders, the <a class="el" href="class_louvre_1_1_l_painter.html" title="Basic 2D rendering utility.">Louvre::LPainter</a> functions (which use an internal shader), or work with the <a class="el" href="class_louvre_1_1_l_scene.html" title="Scene.">Louvre::LScene</a> and <a class="el" href="class_louvre_1_1_l_view.html" title="Base class for LScene views.">Louvre::LView</a> classes. In this section, we will begin by exploring how to render using <a class="el" href="class_louvre_1_1_l_painter.html" title="Basic 2D rendering utility.">Louvre::LPainter</a>, and later, we will cover the use of the <a class="el" href="class_louvre_1_1_l_scene.html" title="Scene.">Louvre::LScene</a> and <a class="el" href="class_louvre_1_1_l_view.html" title="Base class for LScene views.">Louvre::LView</a> classes. We will also discuss why the latter option may be your preferred choice.</p>
<h2><a class="anchor" id="rendering-with-lpainter"></a>
Rendering with LPainter</h2>
<p>To begin, let's render our background wallpaper. I'll be using this nice Louvre-themed wallpaper, typically located on your system at <code>/usr/local/share/Louvre/assets/wallpaper.png</code>, although the path may vary depending on your system. Feel free to choose any image of your preference for this purpose.</p>
<p><img src="https://github.com/CuarzoSoftware/Louvre/blob/devel/src/examples/louvre-views/assets/wallpaper.png?raw=true" alt="" class="inline"/></p>
<h3><a class="anchor" id="srceoutputcpp-1"></a>
src/EOutput.cpp</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;LCompositor.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;LPainter.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;LTexture.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;LOpenGL.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;LLog.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;EOutput.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> EOutput::initializeGL()</div>
<div class="line">{</div>
<div class="line">    wallpaper = LOpenGL::loadTexture(compositor()-&gt;defaultAssetsPath() / <span class="stringliteral">&quot;wallpaper.png&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (!wallpaper)</div>
<div class="line">        LLog::error(<span class="stringliteral">&quot;[louvre-example] Failed to load wallpaper.&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    repaint();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> EOutput::paintGL()</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_class" href="class_louvre_1_1_l_painter.html">LPainter</a> *p { painter() };</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Draw the wallpaper</span></div>
<div class="line">    <span class="keywordflow">if</span> (wallpaper)</div>
<div class="line">        p-&gt;drawTexture(wallpaper,</div>
<div class="line">                       <a class="code hl_class" href="class_louvre_1_1_l_rect_template.html">LRect</a>(0, 0, wallpaper-&gt;sizeB().w(), wallpaper-&gt;sizeB().h()),</div>
<div class="line">                       rect());</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> EOutput::uninitializeGL()</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (wallpaper)</div>
<div class="line">        <span class="keyword">delete</span> wallpaper;</div>
<div class="line">}</div>
<div class="ttc" id="aclass_louvre_1_1_l_painter_html"><div class="ttname"><a href="class_louvre_1_1_l_painter.html">Louvre::LPainter</a></div><div class="ttdoc">Basic 2D rendering utility.</div><div class="ttdef"><b>Definition</b> LPainter.h:34</div></div>
<div class="ttc" id="aclass_louvre_1_1_l_rect_template_html"><div class="ttname"><a href="class_louvre_1_1_l_rect_template.html">Louvre::LRectTemplate&lt; Int32 &gt;</a></div></div>
</div><!-- fragment --><p>Now, in <a class="el" href="class_louvre_1_1_l_output.html#a2aeeb1c8e8bb0f723ebb7129df23d4e8" title="Initialize Event.">Louvre::LOutput::initializeGL()</a>, we load our wallpaper image using the <a class="el" href="class_louvre_1_1_l_open_g_l.html#a97e66d3ddf65fe1e7ee96caf033fbb41" title="Create a texture from an image file.">Louvre::LOpenGL::loadTexture()</a> method. This method supports all image formats that <a href="https://github.com/nothings/stb">STB Image</a> supports and returns <code>nullptr</code> if it fails.</p>
<blockquote class="doxtable">
<p>&zwj;Just in case you weren't aware, in C/C++, when you use <code>if (variable)</code>, the statement is executed only when the variable is anything other than 0. In C++, <code>nullptr</code> is a value indicating a null pointer, essentially representing 0. So in this situation, we check whether the wallpaper texture is not equal to <code>nullptr</code> before attempting to render or delete it, as failing to do so would lead to a segfault. </p>
</blockquote>
<p>In <a class="el" href="class_louvre_1_1_l_output.html#a0569e991ee4c6e4242578aca6d999741" title="Paint Event.">Louvre::LOutput::paintGL()</a>, we draw the wallpaper using the Louvre::LPainter::drawTexture() method. This method takes three (or more) arguments: the first is the texture we want to render, the second is a rect within the texture that we want to render (in this case, we're using the entire texture), and the third argument defines where we want to draw our texture, in this case we pass the position and size of the output (<a class="el" href="class_louvre_1_1_l_output.html#a315aa6ec38b7660b6e56b8591199172b" title="Gets the output rect.">Louvre::LOutput::rect()</a> which is equivalent to <code>(<a class="el" href="class_louvre_1_1_l_output.html#a0843c1bb97b8a8cfb3faa6f75e68acd6" title="Gets the output position.">Louvre::LOutput::pos()</a>, <a class="el" href="class_louvre_1_1_l_output.html#af0e9483bc8188a275f4877e55ec720b0" title="Gets the output size in surface units.">Louvre::LOutput::size()</a>)</code>) to fully cover it.</p>
<p>It's important to note that <a class="el" href="namespace_louvre.html" title="Namespaces.">Louvre</a> uses both buffer and surface coordinates.</p>
<h2><a class="anchor" id="buffer-coordinates"></a>
Buffer Coordinates</h2>
<p>Buffer coordinates represent the maximum granularity within an object, independently of the scale associated with it. For example, if the wallpaper image was 1000x500px, its size in buffer coordinates would be the same, 1000x500. Methods and properties that use buffer coordinates have the "B" suffix, such as <a class="el" href="class_louvre_1_1_l_texture.html#a9595879ae0c4def717bd69d345001ed0" title="Gets the size of the texture in buffer coordinates.">Louvre::LTexture::sizeB()</a>.</p>
<h2><a class="anchor" id="surface-coordinates"></a>
Surface Coordinates</h2>
<p>Surface coordinates are a concept from the Wayland protocol but are not exclusive to surfaces. For instance, if one of your outputs has a resolution of 1000x1000px and you assigned it a scale factor of 2 (because it is HiDPI), the size of the output in buffer coordinates (<a class="el" href="class_louvre_1_1_l_output.html#a9595879ae0c4def717bd69d345001ed0" title="Gets the output size in buffer units.">Louvre::LOutput::sizeB()</a>) would be the same (1000x1000), but in surface coordinates (<a class="el" href="class_louvre_1_1_l_output.html#af0e9483bc8188a275f4877e55ec720b0" title="Gets the output size in surface units.">Louvre::LOutput::size()</a>), it would be 500x500. Surface coordinates are essentially defined as buffer coordinates divided by the scale factor of the object. Using surface coordinates simplifies continuous transformations across different scales and allows you to work in an consistent system while rendering.</p>
<p>In the draw operation, for instance, we use buffer coordinates to define the texture's subrect we want to draw and surface coordinates to define the destination rectangle on the output where we want to draw it. This approach ensures that if you're working with multiple outputs with different scales, the image gets automatically scaled by <a class="el" href="class_louvre_1_1_l_painter.html" title="Basic 2D rendering utility.">Louvre::LPainter</a>, eliminating the need to handle transformations manually each time.</p>
<p>If you were using your own shaders, you would need to manage scaling transformations yourself. In that case, you can access the OpenGL texture ID with <a class="el" href="class_louvre_1_1_l_texture.html#a3f80fc76ac58ff19200ade7d1da8c4b1" title="Gets the OpenGL texture ID for a specific output.">Louvre::LTexture::id()</a> and target with <a class="el" href="class_louvre_1_1_l_texture.html#a984eaa16c803411caa7a489320e4a277" title="Gets the OpenGL texture target.">Louvre::LTexture::target()</a>.</p>
<blockquote class="doxtable">
<p>&zwj;In Louvre::LPainter::drawTexture(), there is a fourth parameter known as <code>srcScale</code>, which defaults to 1. This default value is why we defined the <code>src</code> rect parameter in buffer coordinates. Change this parameter if you have the source rect defined in surface coordinates at a specific scale and wish to avoid the need to transform it back to buffer coordinates. </p>
</blockquote>
<p>Lastly, in <a class="el" href="class_louvre_1_1_l_output.html#a454d002ee90273a44dfb59a30246129e" title="Uninitialize Event.">Louvre::LOutput::uninitializeGL()</a>, we destroy the texture if it was successfully loaded previously.</p>
<p>If you recompile and run, you should now see your wallpaper displayed, but you won't see any surface yet since we haven't drawn them. Let's proceed to implement the rendering of surfaces.</p>
<h2><a class="anchor" id="rendering-surfaces"></a>
Rendering Surfaces</h2>
<p>In Wayland, surfaces represent what you would typically think of as application windows. So, in the context of <a class="el" href="namespace_louvre.html" title="Namespaces.">Louvre</a>, each surface has a texture that we can draw.<br  />
Surfaces, on their own, aren't very useful, they need to have a role assigned before the compositor can use them, which provide rules of how to stack them, position them and more. For instance, a client may assign the role of a cursor to a surface (<a class="el" href="class_louvre_1_1_l_cursor_role.html" title="Cursor role for surfaces.">Louvre::LCursorRole</a>), allowing the compositor to use its texture as a cursor (duh), or as a drag &amp; drop icon (<a class="el" href="class_louvre_1_1_l_d_n_d_icon_role.html" title="Drag &amp; drop icon role for surfaces.">Louvre::LDNDIconRole</a>), or as a toplevel window (<a class="el" href="class_louvre_1_1_l_toplevel_role.html" title="Toplevel role for surfaces.">Louvre::LToplevelRole</a>), as a popup (<a class="el" href="class_louvre_1_1_l_popup_role.html" title="Popup role for surfaces.">Louvre::LPopupRole</a>), etc. We will delve deeper into surfaces later, but for now, let's focus on how to render them.</p>
<p>The <a class="el" href="class_louvre_1_1_l_compositor.html" title="Louvre&#39;s core and objects factory.">Louvre::LCompositor</a> class contains a list of all surfaces created by all clients (<a class="el" href="class_louvre_1_1_l_compositor.html#a02b82f9077f93ed98b9fdd2c963014e8" title="Gets a list of all surfaces created by clients.">Louvre::LCompositor::surfaces()</a>). This list always maintains the correct rendering order, from bottom to topmost surfaces. Surface roles usually define a specific stacking order that must be respected by the compositor to function properly. Therefore, by using this list, you can ensure that the order is respected.</p>
<p>So, let's modify <a class="el" href="class_louvre_1_1_l_output.html#a0569e991ee4c6e4242578aca6d999741" title="Paint Event.">Louvre::LOutput::paintGL()</a> to draw the available surfaces.</p>
<h3><a class="anchor" id="srceoutputcpp-2"></a>
src/EOutput.cpp</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;LPainter.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;LTexture.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;LOpenGL.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;LLog.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;LDNDManager.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;LDNDIconRole.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;LCompositor.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;LCursor.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;LSeat.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;EOutput.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> EOutput::paintGL()</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_class" href="class_louvre_1_1_l_painter.html">LPainter</a> *p { painter() };</div>
<div class="line">    <a class="code hl_struct" href="class_louvre_1_1_l_painter.html#struct_louvre_1_1_l_painter_1_1_texture_params">LPainter::TextureParams</a> texParams;</div>
<div class="line">    <a class="code hl_class" href="class_louvre_1_1_l_rect_template.html">LRect</a> surfaceRect;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Draw the wallpaper</span></div>
<div class="line">    <span class="keywordflow">if</span> (wallpaper)</div>
<div class="line">        p-&gt;drawTexture(wallpaper,</div>
<div class="line">                       <a class="code hl_class" href="class_louvre_1_1_l_rect_template.html">LRect</a>(0, 0, wallpaper-&gt;sizeB().w(), wallpaper-&gt;sizeB().h()),</div>
<div class="line">                       <a class="code hl_class" href="class_louvre_1_1_l_rect_template.html">LRect</a>(pos(), size()));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Raise a drag &amp; drop icon</span></div>
<div class="line">    <span class="keywordflow">if</span> (seat()-&gt;dndManager()-&gt;icon())</div>
<div class="line">        seat()-&gt;dndManager()-&gt;icon()-&gt;surface()-&gt;raise();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Draw every surface</span></div>
<div class="line">    <span class="keywordflow">for</span> (<a class="code hl_class" href="class_louvre_1_1_l_surface.html">LSurface</a> *s : compositor()-&gt;surfaces())</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Skip some surfaces</span></div>
<div class="line">        <span class="keywordflow">if</span> (!s-&gt;mapped() || s-&gt;minimized() || s-&gt;cursorRole())</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">if</span> (s-&gt;cursorRole())</div>
<div class="line">                s-&gt;requestNextFrame();</div>
<div class="line">            <span class="keywordflow">continue</span>;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Current surface rect</span></div>
<div class="line">        surfaceRect = <a class="code hl_class" href="class_louvre_1_1_l_rect_template.html">LRect</a>(s-&gt;rolePos(), s-&gt;size());</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Calculate which outputs the surface intersects</span></div>
<div class="line">        <span class="keywordflow">for</span> (<a class="code hl_class" href="class_louvre_1_1_l_output.html">LOutput</a> *o : <a class="code hl_function" href="namespace_louvre.html#a62750620c88ee98b1c5286f1fc339c5b">compositor</a>()-&gt;outputs())</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">if</span> (o-&gt;rect().intersects(surfaceRect))</div>
<div class="line">                s-&gt;sendOutputEnterEvent(o);</div>
<div class="line">            <span class="keywordflow">else</span></div>
<div class="line">                s-&gt;sendOutputLeaveEvent(o);</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        texParams = </div>
<div class="line">        {</div>
<div class="line">            .<a class="code hl_variable" href="class_louvre_1_1_l_painter.html#a6b17b2b277c3dd696228c2262a0e32d5">texture</a> = s-&gt;texture(),</div>
<div class="line">            .pos = surfaceRect.<a class="code hl_function" href="class_louvre_1_1_l_rect_template.html#a2a2dc2fd45980947abd9dc2f80a7b7bf">pos</a>(),</div>
<div class="line">            .srcRect = s-&gt;srcRect(),</div>
<div class="line">            .dstSize = surfaceRect.<a class="code hl_function" href="class_louvre_1_1_l_rect_template.html#af6951b309861d44f0657e149461f6915">size</a>(),</div>
<div class="line">            .srcTransform = s-&gt;bufferTransform(),</div>
<div class="line">            .srcScale = (<a class="code hl_typedef" href="namespace_louvre.html#a87d38f886e617ced2698fc55afa07637">Float32</a>)s-&gt;bufferScale()</div>
<div class="line">        };</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Bind the surface texture params</span></div>
<div class="line">        p-&gt;bindTextureMode(texParams);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Draw the surface</span></div>
<div class="line">        p-&gt;drawRect(surfaceRect);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Notify the client it can now render a new surface frame</span></div>
<div class="line">        s-&gt;requestNextFrame();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Manually draw the cursor if hardware composition is not supported</span></div>
<div class="line">    <span class="keywordflow">if</span> (!<a class="code hl_function" href="namespace_louvre.html#a0ebe6057a764ac1de2b90e50c6a7916c">cursor</a>()-&gt;<a class="code hl_function" href="class_louvre_1_1_l_cursor.html#a10ae2fa3073c2c8012dda890fb3c3eca">hasHardwareSupport</a>(<span class="keyword">this</span>))</div>
<div class="line">    {</div>
<div class="line">        p-&gt;drawTexture(</div>
<div class="line">            <a class="code hl_function" href="namespace_louvre.html#a0ebe6057a764ac1de2b90e50c6a7916c">cursor</a>()-&gt;<a class="code hl_function" href="class_louvre_1_1_l_cursor.html#ab010fd9d64d973f5d1d6fbb4ed55e974">texture</a>(),</div>
<div class="line">            <a class="code hl_class" href="class_louvre_1_1_l_rect_template.html">LRect</a>(0, <a class="code hl_function" href="namespace_louvre.html#a0ebe6057a764ac1de2b90e50c6a7916c">cursor</a>()-&gt;texture()-&gt;sizeB()),</div>
<div class="line">            <a class="code hl_function" href="namespace_louvre.html#a0ebe6057a764ac1de2b90e50c6a7916c">cursor</a>()-&gt;<a class="code hl_function" href="class_louvre_1_1_l_cursor.html#a315aa6ec38b7660b6e56b8591199172b">rect</a>());</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
<div class="ttc" id="aclass_louvre_1_1_l_cursor_html_a10ae2fa3073c2c8012dda890fb3c3eca"><div class="ttname"><a href="class_louvre_1_1_l_cursor.html#a10ae2fa3073c2c8012dda890fb3c3eca">Louvre::LCursor::hasHardwareSupport</a></div><div class="ttdeci">bool hasHardwareSupport(const LOutput *output) const noexcept</div><div class="ttdoc">Checks if a given output supports hardware compositing.</div><div class="ttdef"><b>Definition</b> LCursor.cpp:317</div></div>
<div class="ttc" id="aclass_louvre_1_1_l_cursor_html_a315aa6ec38b7660b6e56b8591199172b"><div class="ttname"><a href="class_louvre_1_1_l_cursor.html#a315aa6ec38b7660b6e56b8591199172b">Louvre::LCursor::rect</a></div><div class="ttdeci">const LRect &amp; rect() const noexcept</div><div class="ttdoc">Gets the cursor rect on the screen.</div><div class="ttdef"><b>Definition</b> LCursor.cpp:369</div></div>
<div class="ttc" id="aclass_louvre_1_1_l_cursor_html_ab010fd9d64d973f5d1d6fbb4ed55e974"><div class="ttname"><a href="class_louvre_1_1_l_cursor.html#ab010fd9d64d973f5d1d6fbb4ed55e974">Louvre::LCursor::texture</a></div><div class="ttdeci">LTexture * texture() const noexcept</div><div class="ttdoc">Gets the current cursor texture.</div><div class="ttdef"><b>Definition</b> LCursor.cpp:330</div></div>
<div class="ttc" id="aclass_louvre_1_1_l_painter_html_a6b17b2b277c3dd696228c2262a0e32d5"><div class="ttname"><a href="class_louvre_1_1_l_painter.html#a6b17b2b277c3dd696228c2262a0e32d5">Louvre::LPainter::TextureParams::texture</a></div><div class="ttdeci">LTexture * texture</div><div class="ttdoc">Texture to be drawn.</div><div class="ttdef"><b>Definition</b> LPainter.h:47</div></div>
<div class="ttc" id="aclass_louvre_1_1_l_painter_html_struct_louvre_1_1_l_painter_1_1_texture_params"><div class="ttname"><a href="class_louvre_1_1_l_painter.html#struct_louvre_1_1_l_painter_1_1_texture_params">Louvre::LPainter::TextureParams</a></div><div class="ttdoc">Parameters required for bindTextureMode().</div><div class="ttdef"><b>Definition</b> LPainter.h:43</div></div>
<div class="ttc" id="aclass_louvre_1_1_l_rect_template_html_a2a2dc2fd45980947abd9dc2f80a7b7bf"><div class="ttname"><a href="class_louvre_1_1_l_rect_template.html#a2a2dc2fd45980947abd9dc2f80a7b7bf">Louvre::LRectTemplate::pos</a></div><div class="ttdeci">constexpr const LPointTemplate&lt; T &gt; &amp; pos() const noexcept</div><div class="ttdoc">2D vector given by the (x,y) components of the rectangle</div><div class="ttdef"><b>Definition</b> LRect.h:128</div></div>
<div class="ttc" id="aclass_louvre_1_1_l_rect_template_html_af6951b309861d44f0657e149461f6915"><div class="ttname"><a href="class_louvre_1_1_l_rect_template.html#af6951b309861d44f0657e149461f6915">Louvre::LRectTemplate::size</a></div><div class="ttdeci">constexpr const LPointTemplate&lt; T &gt; &amp; size() const noexcept</div><div class="ttdoc">2D vector given by the (w,h) components of the rectangle</div><div class="ttdef"><b>Definition</b> LRect.h:131</div></div>
<div class="ttc" id="aclass_louvre_1_1_l_surface_html"><div class="ttname"><a href="class_louvre_1_1_l_surface.html">Louvre::LSurface</a></div><div class="ttdoc">A client &quot;window&quot;.</div><div class="ttdef"><b>Definition</b> LSurface.h:109</div></div>
<div class="ttc" id="anamespace_louvre_html_a0ebe6057a764ac1de2b90e50c6a7916c"><div class="ttname"><a href="namespace_louvre.html#a0ebe6057a764ac1de2b90e50c6a7916c">Louvre::cursor</a></div><div class="ttdeci">LCursor * cursor() noexcept</div><div class="ttdoc">Gets the compositor's cursor.</div><div class="ttdef"><b>Definition</b> LCompositor.cpp:47</div></div>
<div class="ttc" id="anamespace_louvre_html_a62750620c88ee98b1c5286f1fc339c5b"><div class="ttname"><a href="namespace_louvre.html#a62750620c88ee98b1c5286f1fc339c5b">Louvre::compositor</a></div><div class="ttdeci">LCompositor * compositor() noexcept</div><div class="ttdoc">Gets the static LCompositor instance.</div><div class="ttdef"><b>Definition</b> LCompositor.cpp:37</div></div>
<div class="ttc" id="anamespace_louvre_html_a87d38f886e617ced2698fc55afa07637"><div class="ttname"><a href="namespace_louvre.html#a87d38f886e617ced2698fc55afa07637">Louvre::Float32</a></div><div class="ttdeci">float Float32</div><div class="ttdoc">32 bits float</div><div class="ttdef"><b>Definition</b> LNamespaces.h:246</div></div>
</div><!-- fragment --><p>There's a lot to cover, so let's break it down step by step:</p>
<h3><a class="anchor" id="srceoutputcpp-3"></a>
src/EOutput.cpp</h3>
<div class="fragment"><div class="line"><span class="comment">// Raise a drag &amp; drop icon</span></div>
<div class="line"><span class="keywordflow">if</span> (seat()-&gt;dndManager()-&gt;icon())</div>
<div class="line">    seat()-&gt;dndManager()-&gt;icon()-&gt;surface()-&gt;raise();</div>
</div><!-- fragment --><p> In this section, we are checking if there is an ongoing drag &amp; drop session with an icon. If that's the case, we use <a class="el" href="class_louvre_1_1_l_surface.html#ad9c27f2d106edb222bc33c4bfc384f58" title="Raises the surface within its current layer.">Louvre::LSurface::raise()</a> to elevate the icon surface. This action places the icon at the end of the surfaces list, ensuring that it will be rendered above the rest of the surfaces.</p>
<h3><a class="anchor" id="srceoutputcpp-4"></a>
src/EOutput.cpp</h3>
<div class="fragment"><div class="line"><span class="comment">// Skip some surfaces</span></div>
<div class="line"><span class="keywordflow">if</span> (!s-&gt;mapped() || s-&gt;minimized() || s-&gt;cursorRole())</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (s-&gt;cursorRole())</div>
<div class="line">        s-&gt;requestNextFrame();</div>
<div class="line">    <span class="keywordflow">continue</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><p> In the for loop, we have several conditions to determine whether or not to render a particular surface. Let's break down these conditions:</p>
<ol type="1">
<li>We use the <a class="el" href="class_louvre_1_1_l_surface.html#ac563c8ace44bf8111c0ee1c034e967e2" title="Mapped property.">Louvre::LSurface::mapped()</a> property to decide if the surface should be rendered. This property returns <code>false</code> when the surface does not have a buffer, does not have a role, or if the client wants to hide it.</li>
<li>We skip rendering surfaces that are minimized or have the <a class="el" href="class_louvre_1_1_l_cursor_role.html" title="Cursor role for surfaces.">Louvre::LCursorRole</a> since we use the <a class="el" href="class_louvre_1_1_l_cursor.html" title="Utility class for rendering cursors.">Louvre::LCursor</a> class to render them using hardware composition (we'll cover rendering cursors with <a class="el" href="class_louvre_1_1_l_cursor.html" title="Utility class for rendering cursors.">Louvre::LCursor</a> later).</li>
<li>We call <a class="el" href="class_louvre_1_1_l_surface.html#a23585ebe5d0f8117186848426ea39f0a" title="ACK the frame callback.">Louvre::LSurface::requestNextFrame()</a>, which allows us to control the rate at which clients repaint their surfaces. It notifies the client that it's a good moment to render new content for the given surface. We should avoid calling it if the surface is obscured by other surfaces or if it's not visible. In this case, we are always letting clients update their cursor surfaces.</li>
</ol>
<h3><a class="anchor" id="srceoutputcpp-5"></a>
src/EOutput.cpp</h3>
<div class="fragment"><div class="line"><span class="comment">// Current surface rect</span></div>
<div class="line">surfaceRect = <a class="code hl_class" href="class_louvre_1_1_l_rect_template.html">LRect</a>(s-&gt;rolePos(), s-&gt;size());</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Calculate which outputs the surface intersects</span></div>
<div class="line"><span class="keywordflow">for</span> (<a class="code hl_class" href="class_louvre_1_1_l_output.html">LOutput</a> *o : compositor()-&gt;outputs())</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (o-&gt;rect().intersects(surfaceRect))</div>
<div class="line">        s-&gt;sendOutputEnterEvent(o);</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">        s-&gt;sendOutputLeaveEvent(o);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Next, we determine on which outputs the surface is currently visible and notify the client using <a class="el" href="class_louvre_1_1_l_surface.html#adf7ba2250df7b9183015035fa9faf65d" title="Notify the client when the surface enters an output.">Louvre::LSurface::sendOutputEnterEvent()</a> and <a class="el" href="class_louvre_1_1_l_surface.html#a2ed50991c54d5cf3e12d8497be39be58" title="Notify the client when the surface leaves an output.">Louvre::LSurface::sendOutputLeaveEvent()</a>. This informs clients about the outputs where their surfaces are currently visible, allowing them to adjust the surface scale to match the scale of the output (surfaces also have a scale factor).</p>
<h3><a class="anchor" id="srceoutputcpp-6"></a>
src/EOutput.cpp</h3>
<div class="fragment"><div class="line">texParams = </div>
<div class="line">{</div>
<div class="line">    .<a class="code hl_variable" href="class_louvre_1_1_l_painter.html#a6b17b2b277c3dd696228c2262a0e32d5">texture</a> = s-&gt;texture(),</div>
<div class="line">    .pos = surfaceRect.<a class="code hl_function" href="class_louvre_1_1_l_rect_template.html#a2a2dc2fd45980947abd9dc2f80a7b7bf">pos</a>(),</div>
<div class="line">    .srcRect = s-&gt;srcRect(),</div>
<div class="line">    .dstSize = surfaceRect.<a class="code hl_function" href="class_louvre_1_1_l_rect_template.html#af6951b309861d44f0657e149461f6915">size</a>(),</div>
<div class="line">    .srcTransform = s-&gt;bufferTransform(),</div>
<div class="line">    .srcScale = (<a class="code hl_typedef" href="namespace_louvre.html#a87d38f886e617ced2698fc55afa07637">Float32</a>)s-&gt;bufferScale()</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Bind the surface texture params</span></div>
<div class="line">p-&gt;bindTextureMode(texParams);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Draw the surface</span></div>
<div class="line">p-&gt;drawRect(surfaceRect);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Notify the client it can now render a new surface frame</span></div>
<div class="line">s-&gt;requestNextFrame();</div>
</div><!-- fragment --><p>Following this, we proceed to render the surface, but this time using <a class="el" href="class_louvre_1_1_l_painter.html#a93fb8a67f835ea24bbabdce03f5f80c1" title="Switches to texture mode.">Louvre::LPainter::bindTextureMode()</a>, allowing us to virtually map a texture on the screen based on parameters set in the <a class="el" href="class_louvre_1_1_l_painter.html#struct_louvre_1_1_l_painter_1_1_texture_params" title="Parameters required for bindTextureMode().">Louvre::LPainter::TextureParams</a> struct. We then render it or portions of it using <a class="el" href="class_louvre_1_1_l_painter.html#af652dccf60c68fd95a8e4b4b0fa0c2c2" title="Draws a texture or color rect on the screen based on the current rendering mode.">Louvre::LPainter::drawRect()</a>, <a class="el" href="class_louvre_1_1_l_painter.html#a946153d0f58c9719d2acfa4cf354c7f3" title="Draws a texture or color box on the screen based on the current rendering mode.">Louvre::LPainter::drawBox()</a>, or <a class="el" href="class_louvre_1_1_l_painter.html#add435d7578fcc06c648903e798631e5b" title="Draws a texture or color region on the screen based on the current rendering mode.">Louvre::LPainter::drawRegion()</a>. This approach minimizes transfers to the GPU when rendering regions of textures, such as the <a class="el" href="class_louvre_1_1_l_surface.html#a39a66ef5eff7936fcc836dd223c1537d" title="Damaged region in surface coordinates.">Louvre::LSurface::damage()</a> region of a surface, which we will discuss later.</p>
<p>Unlike Louvre::LPainter::drawTexture(), this approach also enables us to specify custom buffer transforms. When applying a custom transform to an output, clients are notified and encouraged to render their content in a buffer with the same transform, allowing for direct scan-out (refer to <a class="el" href="class_louvre_1_1_l_surface.html#a64295697b08bc2c6cbb04ddce8ca6193" title="Gets the buffer transform of the surface.">Louvre::LSurface::bufferTransform()</a>). Using Louvre::LPainter::drawTexture() in these cases would result in surfaces being displayed rotated, flipped, or clipped.</p>
<h3><a class="anchor" id="srceoutputcpp-7"></a>
src/EOutput.cpp</h3>
<div class="fragment"><div class="line"><span class="comment">// Manually draw the cursor if hardware composition is not supported</span></div>
<div class="line"><span class="keywordflow">if</span> (!cursor()-&gt;hasHardwareSupport(<span class="keyword">this</span>))</div>
<div class="line">{</div>
<div class="line">    p-&gt;drawTexture(</div>
<div class="line">        cursor()-&gt;texture(),</div>
<div class="line">        <a class="code hl_class" href="class_louvre_1_1_l_rect_template.html">LRect</a>(0, cursor()-&gt;texture()-&gt;sizeB()),</div>
<div class="line">        cursor()-&gt;rect());</div>
<div class="line">}</div>
</div><!-- fragment --><p>Finally, we check if hardware cursor compositing is available. Hardware cursor compositing is a feature found in many hardware systems that allows the display of a cursor on the output in a highly efficient manner, without the need to render it using OpenGL. If hardware composition is not supported, we proceed to render the current cursor using OpenGL. In this case the unique <a class="el" href="class_louvre_1_1_l_cursor.html" title="Utility class for rendering cursors.">Louvre::LCursor</a> instance provides us the current cursor texture and also the destination rect where we should render it with <a class="el" href="class_louvre_1_1_l_cursor.html#a315aa6ec38b7660b6e56b8591199172b" title="Gets the cursor rect on the screen.">Louvre::LCursor::rect()</a>.</p>
<p>If you recompile and run, you should now see the surfaces coming back to life.</p>
<h1><a class="anchor" id="poor-performance-"></a>
Poor Performance </h1>
<p>While the rendering logic we've just implemented may appear straightforward, it's unfortunately quite inefficient. This inefficiency stems from the fact that we're repainting the entire output in each frame, including the background wallpaper and all the surfaces, even if only a small change occurs or parts of surfaces are hidden by others.</p>
<p>To create an efficient compositor that people would want to use, we should only repaint the regions that change in each frame. To achieve this, we need to consider several factors: the surfaces' opaque and translucent regions, the surfaces' damage region, and the outputs inter-frame damage.</p>
<p>Each surface has both translucent and opaque regions (<a class="el" href="class_louvre_1_1_l_surface.html#aa2bb0159586017db5bbc143fa929c037" title="Translucent region in surface coordinates.">Louvre::LSurface::translucentRegion()</a> and <a class="el" href="class_louvre_1_1_l_surface.html#a4f8b9a31339748d52c056897bf1f9347" title="Opaque region in surface coordinates.">Louvre::LSurface::opaqueRegion()</a>), which contain lists of non-overlapping rectangles positioned relative to the surface's top-left corner. These regions can help us prevent rendering objects behind opaque regions.</p>
<p>Additionally, each surface has a damage region (<a class="el" href="class_louvre_1_1_l_surface.html#a39a66ef5eff7936fcc836dd223c1537d" title="Damaged region in surface coordinates.">Louvre::LSurface::damage()</a>), similar to the opaque and translucent regions, which indicates which parts of the surface have changed and need repainting. This region is cleared after calling <a class="el" href="class_louvre_1_1_l_surface.html#a23585ebe5d0f8117186848426ea39f0a" title="ACK the frame callback.">Louvre::LSurface::requestNextFrame()</a>.</p>
<p>Lastly, we need to keep track of the output damage. Typically, each output uses more than one framebuffer. While one framebuffer is being displayed on the screen, we render to the other buffer, and then we swap, repeating this process to prevent screen tearing. So in order to handle damage tracking effectively, we would need to use <a class="el" href="class_louvre_1_1_l_output.html#a452f0d25a1d7db419c67673d82d5f21b" title="Returns the index of the current buffer.">Louvre::LOutput::currentBuffer()</a>. This method provides the index of the buffer we're currently rendering to, which can range from [0] for single buffering to [0,1] for double buffering, or even [0,1,2] for triple buffering, depending on your setup.</p>
<p>You can use the <a class="el" href="class_louvre_1_1_l_region.html" title="Collection of non-overlapping rectangles.">Louvre::LRegion</a> class to perform efficient boolean rectangle operations to calculate the region that needs repainting each frame. However, due to its complexity, we won't cover it here. You can refer to the <a href="md_md__examples.html#weston">louvre-weston-clone</a> compositor example to see how it's done, but be warned that it can be quite complex.</p>
<h1><a class="anchor" id="good-news-"></a>
Good News! </h1>
<p>Fortunately, <a class="el" href="namespace_louvre.html" title="Namespaces.">Louvre</a> provides an excellent solution to this problem: the <a class="el" href="class_louvre_1_1_l_scene.html" title="Scene.">Louvre::LScene</a> and <a class="el" href="class_louvre_1_1_l_view.html" title="Base class for LScene views.">Louvre::LView</a> system. These classes simplify the process of efficiently rendering only the necessary regions, and we will explore them in the following chapter.</p>
<p><a href="04.md"> Chapter 4: Compositor Initialization</a> || <a href="06.md">Chapter 6: Rendering with LScene and LViews </a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<script>
    var menu = false;
    var burger, nav;
    function resp()
    {
        if (window.innerWidth < 768)
        {
            burger.hidden = false;
            nav.hidden = true;
        }
        else
        {
            burger.hidden = true;
            nav.hidden = false;
        }
        menu = false;
    }
    function toggleMenu()
    {
        nav.hidden = menu;
        menu = !menu;
    }
    window.onload = function()
    {
        if (typeof toggleLevel !== "undefined")
            toggleLevel(2);
        // Get all <a> tags with the "el" class
        var elLinks = document.querySelectorAll('a.el');
        // Loop through the matched elements
        elLinks.forEach(function(link) 
        {
            // Replace "Louvre::" with an empty string in the text content
            link.textContent = link.textContent.replace(/Louvre::/g, '');
        });
        nav = document.getElementById('main-nav');
        burger = document.createElement('div');
        burger.style.position = 'absolute';
        burger.style.top = '14px';
        burger.style.right = burger.style.top;
        burger.innerHTML = '<svg onclick="toggleMenu()" height="32px" viewBox="0 0 448 512"><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg>';
        document.getElementById('top').appendChild(burger);
        resp();
    };
    window.onresize = function()
    {
        resp();
    };
</script>
<div id="nav-path" class="navpath">
    <ul>
        <li class="footer">Project developed by <a href="https://github.com/CuarzoSoftware"><img class="footer" src="https://avatars.githubusercontent.com/u/29326763?s=200&v=4" style="margin-left:2px;position:relative;top:-1px;width:12px;height:12px" alt="cuarzo"/> Cuarzo Software</a></li>
    </ul>
</div>