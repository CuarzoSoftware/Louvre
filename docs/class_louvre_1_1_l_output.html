<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Louvre: LOutput Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="Logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">Louvre<span id="projectnumber">&#160;v2.18.1-1</span>
   </div>
   <div id="projectbrief">C++ library for Wayland compositors</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_louvre.html">Louvre</a></li><li class="navelem"><a class="el" href="class_louvre_1_1_l_output.html">LOutput</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_louvre_1_1_l_output-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">LOutput Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A display rendering interface.  
 <a href="class_louvre_1_1_l_output.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_l_output_8h_source.html">LOutput.h</a>&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for LOutput:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
 <div class="center">
  <img src="class_louvre_1_1_l_output.png" usemap="#LOutput_map" alt=""/>
  <map id="LOutput_map" name="LOutput_map">
<area href="class_louvre_1_1_l_factory_object.html" title="Base class for Factory objects." alt="LFactoryObject" shape="rect" coords="0,56,100,80"/>
<area href="class_louvre_1_1_l_object.html" title="Base class for Louvre objects." alt="LObject" shape="rect" coords="0,0,100,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a5d74787dedbc4e11c1ab15bf487e61f8" id="r_a5d74787dedbc4e11c1ab15bf487e61f8"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#a5d74787dedbc4e11c1ab15bf487e61f8">State</a> </td></tr>
<tr class="memdesc:a5d74787dedbc4e11c1ab15bf487e61f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output state.  <a href="class_louvre_1_1_l_output.html#a5d74787dedbc4e11c1ab15bf487e61f8">More...</a><br /></td></tr>
<tr class="separator:a5d74787dedbc4e11c1ab15bf487e61f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf3ae70a3f91b9f2d855904572dcbed8" id="r_acf3ae70a3f91b9f2d855904572dcbed8"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#acf3ae70a3f91b9f2d855904572dcbed8">SubPixel</a> </td></tr>
<tr class="memdesc:acf3ae70a3f91b9f2d855904572dcbed8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subpixel geometry.  <a href="class_louvre_1_1_l_output.html#acf3ae70a3f91b9f2d855904572dcbed8">More...</a><br /></td></tr>
<tr class="separator:acf3ae70a3f91b9f2d855904572dcbed8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_class_louvre_1_1_l_factory_object"><td colspan="2" onclick="javascript:toggleInherit('pub_types_class_louvre_1_1_l_factory_object')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="class_louvre_1_1_l_factory_object.html">LFactoryObject</a></td></tr>
<tr class="memitem:ad96f0a085c6542bc6c83459a88bfb560 inherit pub_types_class_louvre_1_1_l_factory_object" id="r_ad96f0a085c6542bc6c83459a88bfb560"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_factory_object.html#ad96f0a085c6542bc6c83459a88bfb560">Type</a> : Int32 </td></tr>
<tr class="memdesc:ad96f0a085c6542bc6c83459a88bfb560"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base factory object types.  <a href="class_louvre_1_1_l_factory_object.html#ad96f0a085c6542bc6c83459a88bfb560">More...</a><br /></td></tr>
<tr class="separator:ad96f0a085c6542bc6c83459a88bfb560 inherit pub_types_class_louvre_1_1_l_factory_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae46b034566ab111fc6e3b1c74800c07d" id="r_ae46b034566ab111fc6e3b1c74800c07d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#ae46b034566ab111fc6e3b1c74800c07d">LOutput</a> (const void *params) noexcept</td></tr>
<tr class="memdesc:ae46b034566ab111fc6e3b1c74800c07d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor of the <a class="el" href="class_louvre_1_1_l_output.html" title="A display rendering interface.">LOutput</a> class.  <br /></td></tr>
<tr class="separator:ae46b034566ab111fc6e3b1c74800c07d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad154579ae13924ffd51510a3712c5d55" id="r_ad154579ae13924ffd51510a3712c5d55"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#ad154579ae13924ffd51510a3712c5d55">~LOutput</a> ()</td></tr>
<tr class="memdesc:ad154579ae13924ffd51510a3712c5d55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor of the <a class="el" href="class_louvre_1_1_l_output.html" title="A display rendering interface.">LOutput</a> class.  <br /></td></tr>
<tr class="separator:ad154579ae13924ffd51510a3712c5d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a102c8d5ab363c7e4e0d93bc41118993c" id="r_a102c8d5ab363c7e4e0d93bc41118993c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_louvre.html#a7e8aeec7b6541935dfc6f608cd5170ce">UInt32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#a102c8d5ab363c7e4e0d93bc41118993c">id</a> () const noexcept</td></tr>
<tr class="memdesc:a102c8d5ab363c7e4e0d93bc41118993c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a unique identifier for the output.  <br /></td></tr>
<tr class="separator:a102c8d5ab363c7e4e0d93bc41118993c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b866d19a1178ee624d2dfb31c744dee" id="r_a9b866d19a1178ee624d2dfb31c744dee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_louvre_1_1_l_output.html#a5d74787dedbc4e11c1ab15bf487e61f8">State</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#a9b866d19a1178ee624d2dfb31c744dee">state</a> () const noexcept</td></tr>
<tr class="memdesc:a9b866d19a1178ee624d2dfb31c744dee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current state of the <a class="el" href="class_louvre_1_1_l_output.html" title="A display rendering interface.">LOutput</a>.  <br /></td></tr>
<tr class="separator:a9b866d19a1178ee624d2dfb31c744dee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a805c69f2ba10cd237849c553ec9ce99e" id="r_a805c69f2ba10cd237849c553ec9ce99e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_louvre_1_1_l_g_p_u.html">LGPU</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#a805c69f2ba10cd237849c553ec9ce99e">gpu</a> () const noexcept</td></tr>
<tr class="memdesc:a805c69f2ba10cd237849c553ec9ce99e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the GPU to which this output belongs.  <br /></td></tr>
<tr class="separator:a805c69f2ba10cd237849c553ec9ce99e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50b3bf074aafac5129b43cca80e0db38" id="r_a50b3bf074aafac5129b43cca80e0db38"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_louvre_1_1_l_painter.html">LPainter</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#a50b3bf074aafac5129b43cca80e0db38">painter</a> () const noexcept</td></tr>
<tr class="memdesc:a50b3bf074aafac5129b43cca80e0db38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets access to the associated <a class="el" href="class_louvre_1_1_l_painter.html" title="Basic 2D rendering utility.">LPainter</a>.  <br /></td></tr>
<tr class="separator:a50b3bf074aafac5129b43cca80e0db38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b836fa9e76c09053fae6b06d1455c67" id="r_a4b836fa9e76c09053fae6b06d1455c67"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_louvre_1_1_l_session_lock_role.html">LSessionLockRole</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#a4b836fa9e76c09053fae6b06d1455c67">sessionLockRole</a> () const noexcept</td></tr>
<tr class="memdesc:a4b836fa9e76c09053fae6b06d1455c67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Session Lock Surface.  <br /></td></tr>
<tr class="separator:a4b836fa9e76c09053fae6b06d1455c67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc3ea58fabda3ae63531b9f99d955adc" id="r_afc3ea58fabda3ae63531b9f99d955adc"><td class="memItemLeft" align="right" valign="top">const std::list&lt; <a class="el" href="class_louvre_1_1_l_exclusive_zone.html">LExclusiveZone</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#afc3ea58fabda3ae63531b9f99d955adc">exclusiveZones</a> () const noexcept</td></tr>
<tr class="memdesc:afc3ea58fabda3ae63531b9f99d955adc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves all exclusive zones assigned to this output.  <br /></td></tr>
<tr class="separator:afc3ea58fabda3ae63531b9f99d955adc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33473d432755f05c5eda568b383000ff" id="r_a33473d432755f05c5eda568b383000ff"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_louvre.html#ad83fc7af7b313dac8820e4d4bd5b4383">LRect</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#a33473d432755f05c5eda568b383000ff">availableGeometry</a> () const noexcept</td></tr>
<tr class="memdesc:a33473d432755f05c5eda568b383000ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the rect within the output that is not occupied by exclusive zones.  <br /></td></tr>
<tr class="separator:a33473d432755f05c5eda568b383000ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac24588e06d25cf65b28c6b5ff8574789" id="r_ac24588e06d25cf65b28c6b5ff8574789"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_louvre.html#struct_louvre_1_1_l_margins">LMargins</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#ac24588e06d25cf65b28c6b5ff8574789">exclusiveEdges</a> () const noexcept</td></tr>
<tr class="memdesc:ac24588e06d25cf65b28c6b5ff8574789"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the sum of the space occupied by exclusive zones for each edge.  <br /></td></tr>
<tr class="separator:ac24588e06d25cf65b28c6b5ff8574789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b0e88488e807ce9e74c29420c9b4ceb" id="r_a2b0e88488e807ce9e74c29420c9b4ceb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_louvre_1_1_l_framebuffer.html">LFramebuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#a2b0e88488e807ce9e74c29420c9b4ceb">framebuffer</a> () const noexcept</td></tr>
<tr class="memdesc:a2b0e88488e807ce9e74c29420c9b4ceb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the associated framebuffer.  <br /></td></tr>
<tr class="separator:a2b0e88488e807ce9e74c29420c9b4ceb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d51d766a73de9c03a44e3dc8df71d9a" id="r_a6d51d766a73de9c03a44e3dc8df71d9a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_louvre_1_1_l_texture.html">LTexture</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#a6d51d766a73de9c03a44e3dc8df71d9a">oversamplingTexture</a> () const noexcept</td></tr>
<tr class="memdesc:a6d51d766a73de9c03a44e3dc8df71d9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the texture used for oversampling.  <br /></td></tr>
<tr class="separator:a6d51d766a73de9c03a44e3dc8df71d9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae53642e01710db05adae9dab67917fa7" id="r_ae53642e01710db05adae9dab67917fa7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_louvre.html#a700c2230c9a7c049255f06a9ca53b72b">LTransform</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#ae53642e01710db05adae9dab67917fa7">transform</a> () const noexcept</td></tr>
<tr class="memdesc:ae53642e01710db05adae9dab67917fa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the framebuffer transform.  <br /></td></tr>
<tr class="separator:ae53642e01710db05adae9dab67917fa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4983ad9b25b32cd00f7b943894666a8" id="r_ae4983ad9b25b32cd00f7b943894666a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#ae4983ad9b25b32cd00f7b943894666a8">setTransform</a> (<a class="el" href="namespace_louvre.html#a700c2230c9a7c049255f06a9ca53b72b">LTransform</a> <a class="el" href="class_louvre_1_1_l_output.html#ae53642e01710db05adae9dab67917fa7">transform</a>) noexcept</td></tr>
<tr class="memdesc:ae4983ad9b25b32cd00f7b943894666a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the framebuffer transform.  <br /></td></tr>
<tr class="separator:ae4983ad9b25b32cd00f7b943894666a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad297c46935046c5f6bd99bcbab99157a" id="r_ad297c46935046c5f6bd99bcbab99157a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_louvre.html#a7e8aeec7b6541935dfc6f608cd5170ce">UInt32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#ad297c46935046c5f6bd99bcbab99157a">currentBufferAge</a> () const noexcept</td></tr>
<tr class="memdesc:ad297c46935046c5f6bd99bcbab99157a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the age of the current buffer.  <br /></td></tr>
<tr class="separator:ad297c46935046c5f6bd99bcbab99157a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a452f0d25a1d7db419c67673d82d5f21b" id="r_a452f0d25a1d7db419c67673d82d5f21b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_louvre.html#a20b0c262d9ef5d263888e463dfa99638">Int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#a452f0d25a1d7db419c67673d82d5f21b">currentBuffer</a> () const noexcept</td></tr>
<tr class="memdesc:a452f0d25a1d7db419c67673d82d5f21b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the current buffer.  <br /></td></tr>
<tr class="separator:a452f0d25a1d7db419c67673d82d5f21b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b774e7c0dfda35a3b2fc5377c0c7e35" id="r_a6b774e7c0dfda35a3b2fc5377c0c7e35"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_louvre.html#a7e8aeec7b6541935dfc6f608cd5170ce">UInt32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#a6b774e7c0dfda35a3b2fc5377c0c7e35">buffersCount</a> () const noexcept</td></tr>
<tr class="memdesc:a6b774e7c0dfda35a3b2fc5377c0c7e35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the count of available buffers.  <br /></td></tr>
<tr class="separator:a6b774e7c0dfda35a3b2fc5377c0c7e35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7be8794bc1df3aaa6304f9e169581852" id="r_a7be8794bc1df3aaa6304f9e169581852"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_louvre_1_1_l_texture.html">LTexture</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#a7be8794bc1df3aaa6304f9e169581852">bufferTexture</a> (<a class="el" href="namespace_louvre.html#a7e8aeec7b6541935dfc6f608cd5170ce">UInt32</a> bufferIndex) noexcept</td></tr>
<tr class="memdesc:a7be8794bc1df3aaa6304f9e169581852"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the texture of a specific buffer.  <br /></td></tr>
<tr class="separator:a7be8794bc1df3aaa6304f9e169581852"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62709874a2dddce91d7ad3d0b3a956cf" id="r_a62709874a2dddce91d7ad3d0b3a956cf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#a62709874a2dddce91d7ad3d0b3a956cf">hasBufferDamageSupport</a> () const noexcept</td></tr>
<tr class="memdesc:a62709874a2dddce91d7ad3d0b3a956cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the output supports buffer damage tracking.  <br /></td></tr>
<tr class="separator:a62709874a2dddce91d7ad3d0b3a956cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7245d78b52786e2b77819860eab9a774" id="r_a7245d78b52786e2b77819860eab9a774"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#a7245d78b52786e2b77819860eab9a774">setBufferDamage</a> (const <a class="el" href="class_louvre_1_1_l_region.html">LRegion</a> *damage) noexcept</td></tr>
<tr class="memdesc:a7245d78b52786e2b77819860eab9a774"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the damage generated during the last painGL() event.  <br /></td></tr>
<tr class="separator:a7245d78b52786e2b77819860eab9a774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3d1cef8d9c4b0ac00835c930f2eb298" id="r_ac3d1cef8d9c4b0ac00835c930f2eb298"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_louvre_1_1_l_region.html">LRegion</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#ac3d1cef8d9c4b0ac00835c930f2eb298">bufferDamage</a> () const noexcept</td></tr>
<tr class="memdesc:ac3d1cef8d9c4b0ac00835c930f2eb298"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the damage region set by <a class="el" href="class_louvre_1_1_l_output.html#a7245d78b52786e2b77819860eab9a774" title="Specifies the damage generated during the last painGL() event.">setBufferDamage()</a>.  <br /></td></tr>
<tr class="separator:ac3d1cef8d9c4b0ac00835c930f2eb298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a026774ddbfcac05e0a2e0eb582b7807f" id="r_a026774ddbfcac05e0a2e0eb582b7807f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_louvre_1_1_l_output.html#acf3ae70a3f91b9f2d855904572dcbed8">SubPixel</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#a026774ddbfcac05e0a2e0eb582b7807f">subPixel</a> () const noexcept</td></tr>
<tr class="memdesc:a026774ddbfcac05e0a2e0eb582b7807f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the layout of RGB subpixels for a single pixel on a display.  <br /></td></tr>
<tr class="separator:a026774ddbfcac05e0a2e0eb582b7807f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84d4d0411fdd405e199074ec04484aaa" id="r_a84d4d0411fdd405e199074ec04484aaa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#a84d4d0411fdd405e199074ec04484aaa">setCustomScanoutBuffer</a> (<a class="el" href="class_louvre_1_1_l_texture.html">LTexture</a> *texture) noexcept</td></tr>
<tr class="memdesc:a84d4d0411fdd405e199074ec04484aaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a custom scanout buffer for a single frame.  <br /></td></tr>
<tr class="separator:a84d4d0411fdd405e199074ec04484aaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab37de15dd67cb6861eface25a2c1498b" id="r_ab37de15dd67cb6861eface25a2c1498b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#ab37de15dd67cb6861eface25a2c1498b">hasVSyncControlSupport</a> () const noexcept</td></tr>
<tr class="memdesc:ab37de15dd67cb6861eface25a2c1498b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if VSync control is supported for this output.  <br /></td></tr>
<tr class="separator:ab37de15dd67cb6861eface25a2c1498b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5337526b6523038cffcb6583afa756a5" id="r_a5337526b6523038cffcb6583afa756a5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#a5337526b6523038cffcb6583afa756a5">vSyncEnabled</a> () const noexcept</td></tr>
<tr class="memdesc:a5337526b6523038cffcb6583afa756a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if VSync is enabled (enabled by default).  <br /></td></tr>
<tr class="separator:a5337526b6523038cffcb6583afa756a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad3bf6e06d340d3dc8d267e4e654afeb" id="r_aad3bf6e06d340d3dc8d267e4e654afeb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#aad3bf6e06d340d3dc8d267e4e654afeb">enableVSync</a> (bool enabled) noexcept</td></tr>
<tr class="memdesc:aad3bf6e06d340d3dc8d267e4e654afeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turns VSync on or off.  <br /></td></tr>
<tr class="separator:aad3bf6e06d340d3dc8d267e4e654afeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5fb5100cd757d182fc0fed19650aef2" id="r_aa5fb5100cd757d182fc0fed19650aef2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_louvre.html#a20b0c262d9ef5d263888e463dfa99638">Int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#aa5fb5100cd757d182fc0fed19650aef2">refreshRateLimit</a> () const noexcept</td></tr>
<tr class="memdesc:aa5fb5100cd757d182fc0fed19650aef2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the refresh rate limit in Hz when VSync is disabled.  <br /></td></tr>
<tr class="separator:aa5fb5100cd757d182fc0fed19650aef2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1564c3c6d1b77f089702e01ec4502d9" id="r_af1564c3c6d1b77f089702e01ec4502d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#af1564c3c6d1b77f089702e01ec4502d9">setRefreshRateLimit</a> (<a class="el" href="namespace_louvre.html#a20b0c262d9ef5d263888e463dfa99638">Int32</a> hz) noexcept</td></tr>
<tr class="memdesc:af1564c3c6d1b77f089702e01ec4502d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the refresh rate limit in Hz when VSync is disabled.  <br /></td></tr>
<tr class="separator:af1564c3c6d1b77f089702e01ec4502d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16a1856622b2e0e1d4f3f81961de6e0c" id="r_a16a1856622b2e0e1d4f3f81961de6e0c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_louvre.html#a7e8aeec7b6541935dfc6f608cd5170ce">UInt32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#a16a1856622b2e0e1d4f3f81961de6e0c">gammaSize</a> () const noexcept</td></tr>
<tr class="memdesc:a16a1856622b2e0e1d4f3f81961de6e0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size of the gamma table.  <br /></td></tr>
<tr class="separator:a16a1856622b2e0e1d4f3f81961de6e0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a245e2751c991363d19e29fc3e22e1989" id="r_a245e2751c991363d19e29fc3e22e1989"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#a245e2751c991363d19e29fc3e22e1989">setGamma</a> (const <a class="el" href="class_louvre_1_1_l_gamma_table.html">LGammaTable</a> *gamma) noexcept</td></tr>
<tr class="memdesc:a245e2751c991363d19e29fc3e22e1989"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the gamma correction table for the output.  <br /></td></tr>
<tr class="separator:a245e2751c991363d19e29fc3e22e1989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb161afb5f8aa93896dead7d42ef5ab4" id="r_adb161afb5f8aa93896dead7d42ef5ab4"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="class_louvre_1_1_l_output_mode.html">LOutputMode</a> * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#adb161afb5f8aa93896dead7d42ef5ab4">modes</a> () const noexcept</td></tr>
<tr class="memdesc:adb161afb5f8aa93896dead7d42ef5ab4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Available modes.  <br /></td></tr>
<tr class="separator:adb161afb5f8aa93896dead7d42ef5ab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a387f10410e3367f22eb35e6595991811" id="r_a387f10410e3367f22eb35e6595991811"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_louvre_1_1_l_output_mode.html">LOutputMode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#a387f10410e3367f22eb35e6595991811">preferredMode</a> () const noexcept</td></tr>
<tr class="memdesc:a387f10410e3367f22eb35e6595991811"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the preferred mode.  <br /></td></tr>
<tr class="separator:a387f10410e3367f22eb35e6595991811"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee653f4eaf5e9fb3f85b48d72500185a" id="r_aee653f4eaf5e9fb3f85b48d72500185a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_louvre_1_1_l_output_mode.html">LOutputMode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#aee653f4eaf5e9fb3f85b48d72500185a">currentMode</a> () const noexcept</td></tr>
<tr class="memdesc:aee653f4eaf5e9fb3f85b48d72500185a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current mode.  <br /></td></tr>
<tr class="separator:aee653f4eaf5e9fb3f85b48d72500185a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a376a36620b1acd2a0d154f8993bacdb4" id="r_a376a36620b1acd2a0d154f8993bacdb4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#a376a36620b1acd2a0d154f8993bacdb4">setMode</a> (const <a class="el" href="class_louvre_1_1_l_output_mode.html">LOutputMode</a> *mode) noexcept</td></tr>
<tr class="memdesc:a376a36620b1acd2a0d154f8993bacdb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the output mode.  <br /></td></tr>
<tr class="separator:a376a36620b1acd2a0d154f8993bacdb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af950653f0fe07aed8acca7079047fb94" id="r_af950653f0fe07aed8acca7079047fb94"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#af950653f0fe07aed8acca7079047fb94">setScale</a> (<a class="el" href="namespace_louvre.html#a87d38f886e617ced2698fc55afa07637">Float32</a> <a class="el" href="class_louvre_1_1_l_output.html#a788d4e63bfe520c6db3ef3d9ccde0ec4">scale</a>) noexcept</td></tr>
<tr class="memdesc:af950653f0fe07aed8acca7079047fb94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the output scale factor.  <br /></td></tr>
<tr class="separator:af950653f0fe07aed8acca7079047fb94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a788d4e63bfe520c6db3ef3d9ccde0ec4" id="r_a788d4e63bfe520c6db3ef3d9ccde0ec4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_louvre.html#a87d38f886e617ced2698fc55afa07637">Float32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#a788d4e63bfe520c6db3ef3d9ccde0ec4">scale</a> () const noexcept</td></tr>
<tr class="memdesc:a788d4e63bfe520c6db3ef3d9ccde0ec4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the current output scale factor.  <br /></td></tr>
<tr class="separator:a788d4e63bfe520c6db3ef3d9ccde0ec4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a797d68da2b76224146872b3e4cb2c2db" id="r_a797d68da2b76224146872b3e4cb2c2db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_louvre.html#a87d38f886e617ced2698fc55afa07637">Float32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#a797d68da2b76224146872b3e4cb2c2db">fractionalScale</a> () const noexcept</td></tr>
<tr class="memdesc:a797d68da2b76224146872b3e4cb2c2db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the same scale set with <a class="el" href="class_louvre_1_1_l_output.html#af950653f0fe07aed8acca7079047fb94" title="Sets the output scale factor.">setScale()</a>.  <br /></td></tr>
<tr class="separator:a797d68da2b76224146872b3e4cb2c2db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af354d97907e6bc371b9534f45edd4f75" id="r_af354d97907e6bc371b9534f45edd4f75"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#af354d97907e6bc371b9534f45edd4f75">usingFractionalScale</a> () const noexcept</td></tr>
<tr class="memdesc:af354d97907e6bc371b9534f45edd4f75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the scale factor set with <a class="el" href="class_louvre_1_1_l_output.html#af950653f0fe07aed8acca7079047fb94" title="Sets the output scale factor.">setScale()</a> is fractional.  <br /></td></tr>
<tr class="separator:af354d97907e6bc371b9534f45edd4f75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b19b68cd7414ad718b8cbb117e24da5" id="r_a0b19b68cd7414ad718b8cbb117e24da5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#a0b19b68cd7414ad718b8cbb117e24da5">fractionalOversamplingEnabled</a> () const noexcept</td></tr>
<tr class="memdesc:a0b19b68cd7414ad718b8cbb117e24da5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if oversampling is enabled.  <br /></td></tr>
<tr class="separator:a0b19b68cd7414ad718b8cbb117e24da5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b261f037b65f4e6f20a28c179cdd179" id="r_a9b261f037b65f4e6f20a28c179cdd179"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#a9b261f037b65f4e6f20a28c179cdd179">enableFractionalOversampling</a> (bool enabled) noexcept</td></tr>
<tr class="memdesc:a9b261f037b65f4e6f20a28c179cdd179"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toggles oversampling for fractional scales.  <br /></td></tr>
<tr class="separator:a9b261f037b65f4e6f20a28c179cdd179"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3640e75ecf0af51755b05a1e1262b25c" id="r_a3640e75ecf0af51755b05a1e1262b25c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#a3640e75ecf0af51755b05a1e1262b25c">repaint</a> () noexcept</td></tr>
<tr class="memdesc:a3640e75ecf0af51755b05a1e1262b25c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlocks the rendering thread.  <br /></td></tr>
<tr class="separator:a3640e75ecf0af51755b05a1e1262b25c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3517e43b1493922e7d73304c72f01c71" id="r_a3517e43b1493922e7d73304c72f01c71"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#a3517e43b1493922e7d73304c72f01c71">needsFullRepaint</a> () const noexcept</td></tr>
<tr class="memdesc:a3517e43b1493922e7d73304c72f01c71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates that the entire output needs repainting.  <br /></td></tr>
<tr class="separator:a3517e43b1493922e7d73304c72f01c71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd98aecc4539ea542619bcb98cf72c2d" id="r_acd98aecc4539ea542619bcb98cf72c2d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_louvre.html#a20b0c262d9ef5d263888e463dfa99638">Int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#acd98aecc4539ea542619bcb98cf72c2d">dpi</a> () noexcept</td></tr>
<tr class="memdesc:acd98aecc4539ea542619bcb98cf72c2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the dots per inch (DPI) of the output.  <br /></td></tr>
<tr class="separator:acd98aecc4539ea542619bcb98cf72c2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a315aa6ec38b7660b6e56b8591199172b" id="r_a315aa6ec38b7660b6e56b8591199172b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_louvre.html#ad83fc7af7b313dac8820e4d4bd5b4383">LRect</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#a315aa6ec38b7660b6e56b8591199172b">rect</a> () const noexcept</td></tr>
<tr class="memdesc:a315aa6ec38b7660b6e56b8591199172b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the output rect.  <br /></td></tr>
<tr class="separator:a315aa6ec38b7660b6e56b8591199172b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0843c1bb97b8a8cfb3faa6f75e68acd6" id="r_a0843c1bb97b8a8cfb3faa6f75e68acd6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_louvre.html#a1111511396cab1b2607e4ac55e1883a3">LPoint</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#a0843c1bb97b8a8cfb3faa6f75e68acd6">pos</a> () const noexcept</td></tr>
<tr class="memdesc:a0843c1bb97b8a8cfb3faa6f75e68acd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the output position.  <br /></td></tr>
<tr class="separator:a0843c1bb97b8a8cfb3faa6f75e68acd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ab8c3ffe18601c1d3d355c385553a4c" id="r_a6ab8c3ffe18601c1d3d355c385553a4c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#a6ab8c3ffe18601c1d3d355c385553a4c">setPos</a> (const <a class="el" href="namespace_louvre.html#a1111511396cab1b2607e4ac55e1883a3">LPoint</a> &amp;<a class="el" href="class_louvre_1_1_l_output.html#a0843c1bb97b8a8cfb3faa6f75e68acd6">pos</a>) noexcept</td></tr>
<tr class="memdesc:a6ab8c3ffe18601c1d3d355c385553a4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the position of the output.  <br /></td></tr>
<tr class="separator:a6ab8c3ffe18601c1d3d355c385553a4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0e9483bc8188a275f4877e55ec720b0" id="r_af0e9483bc8188a275f4877e55ec720b0"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_louvre.html#a4df5473974ae0f28f3a4967f296a657b">LSize</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#af0e9483bc8188a275f4877e55ec720b0">size</a> () const noexcept</td></tr>
<tr class="memdesc:af0e9483bc8188a275f4877e55ec720b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the output size in surface units.  <br /></td></tr>
<tr class="separator:af0e9483bc8188a275f4877e55ec720b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9595879ae0c4def717bd69d345001ed0" id="r_a9595879ae0c4def717bd69d345001ed0"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_louvre.html#a4df5473974ae0f28f3a4967f296a657b">LSize</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#a9595879ae0c4def717bd69d345001ed0">sizeB</a> () const noexcept</td></tr>
<tr class="memdesc:a9595879ae0c4def717bd69d345001ed0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the output size in buffer units.  <br /></td></tr>
<tr class="separator:a9595879ae0c4def717bd69d345001ed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4814da0c84dfa9eae2ec64f331fe45c" id="r_aa4814da0c84dfa9eae2ec64f331fe45c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_louvre.html#a4df5473974ae0f28f3a4967f296a657b">LSize</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#aa4814da0c84dfa9eae2ec64f331fe45c">realBufferSize</a> () const noexcept</td></tr>
<tr class="memdesc:aa4814da0c84dfa9eae2ec64f331fe45c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the real destination buffer size.  <br /></td></tr>
<tr class="separator:aa4814da0c84dfa9eae2ec64f331fe45c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9e3d8123250a7f1c045bba0dd122dca" id="r_ac9e3d8123250a7f1c045bba0dd122dca"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_louvre.html#a4df5473974ae0f28f3a4967f296a657b">LSize</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#ac9e3d8123250a7f1c045bba0dd122dca">physicalSize</a> () const noexcept</td></tr>
<tr class="memdesc:ac9e3d8123250a7f1c045bba0dd122dca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the physical dimensions of the output.  <br /></td></tr>
<tr class="separator:ac9e3d8123250a7f1c045bba0dd122dca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b3ad023be45221c4791814e75bae035" id="r_a4b3ad023be45221c4791814e75bae035"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="class_louvre_1_1_l_screenshot_request.html">LScreenshotRequest</a> * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#a4b3ad023be45221c4791814e75bae035">screenshotRequests</a> () const noexcept</td></tr>
<tr class="memdesc:a4b3ad023be45221c4791814e75bae035"><td class="mdescLeft">&#160;</td><td class="mdescRight">Screen capture requests.  <br /></td></tr>
<tr class="separator:a4b3ad023be45221c4791814e75bae035"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77d688c4b02da52e5f2fc20f85024d6b" id="r_a77d688c4b02da52e5f2fc20f85024d6b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_louvre.html#a7de5cf1aefc1d4c90dbe7dc0727654ba">LContentType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#a77d688c4b02da52e5f2fc20f85024d6b">contentType</a> () const noexcept</td></tr>
<tr class="memdesc:a77d688c4b02da52e5f2fc20f85024d6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The content type hint set with <a class="el" href="class_louvre_1_1_l_output.html#af0c36b2fb823c8128b04f77ae9c488a5" title="Sets the content type hint.">setContentType()</a>.  <br /></td></tr>
<tr class="separator:a77d688c4b02da52e5f2fc20f85024d6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0c36b2fb823c8128b04f77ae9c488a5" id="r_af0c36b2fb823c8128b04f77ae9c488a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#af0c36b2fb823c8128b04f77ae9c488a5">setContentType</a> (<a class="el" href="namespace_louvre.html#a7de5cf1aefc1d4c90dbe7dc0727654ba">LContentType</a> type) noexcept</td></tr>
<tr class="memdesc:af0c36b2fb823c8128b04f77ae9c488a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the content type hint.  <br /></td></tr>
<tr class="separator:af0c36b2fb823c8128b04f77ae9c488a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ec1b13e7e27217080250c93e0139725" id="r_a5ec1b13e7e27217080250c93e0139725"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#a5ec1b13e7e27217080250c93e0139725">isNonDesktop</a> () const noexcept</td></tr>
<tr class="memdesc:a5ec1b13e7e27217080250c93e0139725"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the output is intended for non-desktop usage.  <br /></td></tr>
<tr class="separator:a5ec1b13e7e27217080250c93e0139725"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7f3f3691fe3e30d5a56299f3c6c74cf" id="r_ad7f3f3691fe3e30d5a56299f3c6c74cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#ad7f3f3691fe3e30d5a56299f3c6c74cf">setLeasable</a> (bool <a class="el" href="class_louvre_1_1_l_output.html#a8aa371d15583bb4f1cb3d507b27aa559">leasable</a>) noexcept</td></tr>
<tr class="memdesc:ad7f3f3691fe3e30d5a56299f3c6c74cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advertises the output as leasable.  <br /></td></tr>
<tr class="separator:ad7f3f3691fe3e30d5a56299f3c6c74cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aa371d15583bb4f1cb3d507b27aa559" id="r_a8aa371d15583bb4f1cb3d507b27aa559"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#a8aa371d15583bb4f1cb3d507b27aa559">leasable</a> () noexcept</td></tr>
<tr class="memdesc:a8aa371d15583bb4f1cb3d507b27aa559"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the output is advertised as leasable.  <br /></td></tr>
<tr class="separator:a8aa371d15583bb4f1cb3d507b27aa559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b404ffeeead230796583114274bec55" id="r_a5b404ffeeead230796583114274bec55"><td class="memItemLeft" align="right" valign="top">Protocols::DRMLease::RDRMLease *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#a5b404ffeeead230796583114274bec55">lease</a> () const noexcept</td></tr>
<tr class="memdesc:a5b404ffeeead230796583114274bec55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current lease created after an accepted <a class="el" href="class_louvre_1_1_l_output.html#a831a684290662b218b58ae77d82299f3" title="Handles client requests to lease the output.">leaseRequest()</a>.  <br /></td></tr>
<tr class="separator:a5b404ffeeead230796583114274bec55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33256784969e3347f423f72af1727cbd" id="r_a33256784969e3347f423f72af1727cbd"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#a33256784969e3347f423f72af1727cbd">name</a> () const noexcept</td></tr>
<tr class="memdesc:a33256784969e3347f423f72af1727cbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the output name.  <br /></td></tr>
<tr class="separator:a33256784969e3347f423f72af1727cbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afba2707e89f2a153d45e4e2b7b699350" id="r_afba2707e89f2a153d45e4e2b7b699350"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#afba2707e89f2a153d45e4e2b7b699350">model</a> () const noexcept</td></tr>
<tr class="memdesc:afba2707e89f2a153d45e4e2b7b699350"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the output model name.  <br /></td></tr>
<tr class="separator:afba2707e89f2a153d45e4e2b7b699350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01f2188ab35ed527ca6ffb254137b502" id="r_a01f2188ab35ed527ca6ffb254137b502"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#a01f2188ab35ed527ca6ffb254137b502">manufacturer</a> () const noexcept</td></tr>
<tr class="memdesc:a01f2188ab35ed527ca6ffb254137b502"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the manufacturer name of the output.  <br /></td></tr>
<tr class="separator:a01f2188ab35ed527ca6ffb254137b502"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd0f3730b5508e643c916f6e81156df2" id="r_afd0f3730b5508e643c916f6e81156df2"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#afd0f3730b5508e643c916f6e81156df2">description</a> () const noexcept</td></tr>
<tr class="memdesc:afd0f3730b5508e643c916f6e81156df2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the description of the output.  <br /></td></tr>
<tr class="separator:afd0f3730b5508e643c916f6e81156df2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90c193864e7f5f74d76e5f8f2fa6f852" id="r_a90c193864e7f5f74d76e5f8f2fa6f852"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#a90c193864e7f5f74d76e5f8f2fa6f852">serialNumber</a> () const noexcept</td></tr>
<tr class="memdesc:a90c193864e7f5f74d76e5f8f2fa6f852"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the serial number of the output.  <br /></td></tr>
<tr class="separator:a90c193864e7f5f74d76e5f8f2fa6f852"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa63ba85230130f89461fb64e2da375e" id="r_afa63ba85230130f89461fb64e2da375e"><td class="memItemLeft" align="right" valign="top">const std::thread::id &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#afa63ba85230130f89461fb64e2da375e">threadId</a> () const noexcept</td></tr>
<tr class="memdesc:afa63ba85230130f89461fb64e2da375e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the ID of the rendering thread.  <br /></td></tr>
<tr class="separator:afa63ba85230130f89461fb64e2da375e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_louvre_1_1_l_factory_object"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_louvre_1_1_l_factory_object')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_louvre_1_1_l_factory_object.html">LFactoryObject</a></td></tr>
<tr class="memitem:a3bd9479f72aa3d1df19e3a247adcf804 inherit pub_methods_class_louvre_1_1_l_factory_object" id="r_a3bd9479f72aa3d1df19e3a247adcf804"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_louvre_1_1_l_factory_object.html#ad96f0a085c6542bc6c83459a88bfb560">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_factory_object.html#a3bd9479f72aa3d1df19e3a247adcf804">factoryObjectType</a> () const noexcept</td></tr>
<tr class="memdesc:a3bd9479f72aa3d1df19e3a247adcf804 inherit pub_methods_class_louvre_1_1_l_factory_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the base factory object type.  <br /></td></tr>
<tr class="separator:a3bd9479f72aa3d1df19e3a247adcf804 inherit pub_methods_class_louvre_1_1_l_factory_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_louvre_1_1_l_object"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_louvre_1_1_l_object')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_louvre_1_1_l_object.html">LObject</a></td></tr>
<tr class="memitem:a5e0338a5b44c364d6b13da9a71ada022 inherit pub_methods_class_louvre_1_1_l_object" id="r_a5e0338a5b44c364d6b13da9a71ada022"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_object.html#a5e0338a5b44c364d6b13da9a71ada022">LObject</a> (const <a class="el" href="class_louvre_1_1_l_object.html">LObject</a> &amp;) noexcept</td></tr>
<tr class="memdesc:a5e0338a5b44c364d6b13da9a71ada022 inherit pub_methods_class_louvre_1_1_l_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <br /></td></tr>
<tr class="separator:a5e0338a5b44c364d6b13da9a71ada022 inherit pub_methods_class_louvre_1_1_l_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2d1ca3cf8daa14eec5716367c8f7cc5 inherit pub_methods_class_louvre_1_1_l_object" id="r_ab2d1ca3cf8daa14eec5716367c8f7cc5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_louvre_1_1_l_object.html">LObject</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_object.html#ab2d1ca3cf8daa14eec5716367c8f7cc5">operator=</a> (const <a class="el" href="class_louvre_1_1_l_object.html">LObject</a> &amp;) noexcept</td></tr>
<tr class="memdesc:ab2d1ca3cf8daa14eec5716367c8f7cc5 inherit pub_methods_class_louvre_1_1_l_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator (each object has its own individual <a class="el" href="class_louvre_1_1_l_weak.html" title="Weak reference to an LObject.">LWeak</a> reference count).  <br /></td></tr>
<tr class="separator:ab2d1ca3cf8daa14eec5716367c8f7cc5 inherit pub_methods_class_louvre_1_1_l_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaa9f556f19f069b6a81ff7ac7038962 inherit pub_methods_class_louvre_1_1_l_object" id="r_aaaa9f556f19f069b6a81ff7ac7038962"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_object.html#aaaa9f556f19f069b6a81ff7ac7038962">setUserData</a> (<a class="el" href="namespace_louvre.html#aae7f8c18b78885d886911ca3c22fac6a">UIntPtr</a> data) const noexcept</td></tr>
<tr class="memdesc:aaaa9f556f19f069b6a81ff7ac7038962 inherit pub_methods_class_louvre_1_1_l_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store an unsigned integer value/pointer.  <br /></td></tr>
<tr class="separator:aaaa9f556f19f069b6a81ff7ac7038962 inherit pub_methods_class_louvre_1_1_l_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca4673ef20b24d63618e7d9061c66c6f inherit pub_methods_class_louvre_1_1_l_object" id="r_aca4673ef20b24d63618e7d9061c66c6f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_louvre.html#aae7f8c18b78885d886911ca3c22fac6a">UIntPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_object.html#aca4673ef20b24d63618e7d9061c66c6f">userData</a> () const noexcept</td></tr>
<tr class="memdesc:aca4673ef20b24d63618e7d9061c66c6f inherit pub_methods_class_louvre_1_1_l_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the stored unsigned integer value/pointer.  <br /></td></tr>
<tr class="separator:aca4673ef20b24d63618e7d9061c66c6f inherit pub_methods_class_louvre_1_1_l_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Virtual Methods</h2></td></tr>
<tr class="memitem:a2aeeb1c8e8bb0f723ebb7129df23d4e8" id="r_a2aeeb1c8e8bb0f723ebb7129df23d4e8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#a2aeeb1c8e8bb0f723ebb7129df23d4e8">initializeGL</a> ()</td></tr>
<tr class="memdesc:a2aeeb1c8e8bb0f723ebb7129df23d4e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize Event.  <br /></td></tr>
<tr class="separator:a2aeeb1c8e8bb0f723ebb7129df23d4e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0569e991ee4c6e4242578aca6d999741" id="r_a0569e991ee4c6e4242578aca6d999741"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#a0569e991ee4c6e4242578aca6d999741">paintGL</a> ()</td></tr>
<tr class="memdesc:a0569e991ee4c6e4242578aca6d999741"><td class="mdescLeft">&#160;</td><td class="mdescRight">Paint Event.  <br /></td></tr>
<tr class="separator:a0569e991ee4c6e4242578aca6d999741"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4dc5e1f724869e9523ce872afd56a1a" id="r_ad4dc5e1f724869e9523ce872afd56a1a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#ad4dc5e1f724869e9523ce872afd56a1a">resizeGL</a> ()</td></tr>
<tr class="memdesc:ad4dc5e1f724869e9523ce872afd56a1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize Event.  <br /></td></tr>
<tr class="separator:ad4dc5e1f724869e9523ce872afd56a1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa15f67e7da7f9351890b2c6258ee9225" id="r_aa15f67e7da7f9351890b2c6258ee9225"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#aa15f67e7da7f9351890b2c6258ee9225">moveGL</a> ()</td></tr>
<tr class="memdesc:aa15f67e7da7f9351890b2c6258ee9225"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move Event.  <br /></td></tr>
<tr class="separator:aa15f67e7da7f9351890b2c6258ee9225"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a454d002ee90273a44dfb59a30246129e" id="r_a454d002ee90273a44dfb59a30246129e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#a454d002ee90273a44dfb59a30246129e">uninitializeGL</a> ()</td></tr>
<tr class="memdesc:a454d002ee90273a44dfb59a30246129e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uninitialize Event.  <br /></td></tr>
<tr class="separator:a454d002ee90273a44dfb59a30246129e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a386f3d06f6c9f2d60e66c6da5bf3dd1a" id="r_a386f3d06f6c9f2d60e66c6da5bf3dd1a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#a386f3d06f6c9f2d60e66c6da5bf3dd1a">setGammaRequest</a> (<a class="el" href="class_louvre_1_1_l_client.html">LClient</a> *client, const <a class="el" href="class_louvre_1_1_l_gamma_table.html">LGammaTable</a> *gamma)</td></tr>
<tr class="memdesc:a386f3d06f6c9f2d60e66c6da5bf3dd1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set gamma table request.  <br /></td></tr>
<tr class="separator:a386f3d06f6c9f2d60e66c6da5bf3dd1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a831a684290662b218b58ae77d82299f3" id="r_a831a684290662b218b58ae77d82299f3"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#a831a684290662b218b58ae77d82299f3">leaseRequest</a> (<a class="el" href="class_louvre_1_1_l_client.html">LClient</a> *client)</td></tr>
<tr class="memdesc:a831a684290662b218b58ae77d82299f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles client requests to lease the output.  <br /></td></tr>
<tr class="separator:a831a684290662b218b58ae77d82299f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5fd996431679f9db64a6a859eab7743" id="r_aa5fd996431679f9db64a6a859eab7743"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#aa5fd996431679f9db64a6a859eab7743">leaseChanged</a> ()</td></tr>
<tr class="memdesc:aa5fd996431679f9db64a6a859eab7743"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notifies a change in the <a class="el" href="class_louvre_1_1_l_output.html#a5b404ffeeead230796583114274bec55" title="Current lease created after an accepted leaseRequest().">lease()</a> property.  <br /></td></tr>
<tr class="separator:aa5fd996431679f9db64a6a859eab7743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03894018bad5907971d5b9d0ec072c6f" id="r_a03894018bad5907971d5b9d0ec072c6f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#a03894018bad5907971d5b9d0ec072c6f">availableGeometryChanged</a> ()</td></tr>
<tr class="memdesc:a03894018bad5907971d5b9d0ec072c6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notifies a change in <a class="el" href="class_louvre_1_1_l_output.html#a33473d432755f05c5eda568b383000ff" title="Retrieves the rect within the output that is not occupied by exclusive zones.">availableGeometry()</a>.  <br /></td></tr>
<tr class="separator:a03894018bad5907971d5b9d0ec072c6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6969bb3bc86f834354210a6b4d7f666" id="r_ab6969bb3bc86f834354210a6b4d7f666"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#ab6969bb3bc86f834354210a6b4d7f666">repaintFilter</a> ()</td></tr>
<tr class="memdesc:ab6969bb3bc86f834354210a6b4d7f666"><td class="mdescLeft">&#160;</td><td class="mdescRight">Temporarily disables repaint calls for this output.  <br /></td></tr>
<tr class="separator:ab6969bb3bc86f834354210a6b4d7f666"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_class_louvre_1_1_l_object"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_class_louvre_1_1_l_object')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="class_louvre_1_1_l_object.html">LObject</a></td></tr>
<tr class="memitem:a923dd55b0ee0726e290f2b96fda86863 inherit pro_methods_class_louvre_1_1_l_object" id="r_a923dd55b0ee0726e290f2b96fda86863"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_object.html#a923dd55b0ee0726e290f2b96fda86863">LObject</a> () noexcept=default</td></tr>
<tr class="memdesc:a923dd55b0ee0726e290f2b96fda86863 inherit pro_methods_class_louvre_1_1_l_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor of the <a class="el" href="class_louvre_1_1_l_object.html" title="Base class for Louvre objects.">LObject</a> class.  <br /></td></tr>
<tr class="separator:a923dd55b0ee0726e290f2b96fda86863 inherit pro_methods_class_louvre_1_1_l_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab82f01a547b3363a86304ad285774a3f inherit pro_methods_class_louvre_1_1_l_object" id="r_ab82f01a547b3363a86304ad285774a3f"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_object.html#ab82f01a547b3363a86304ad285774a3f">~LObject</a> () noexcept</td></tr>
<tr class="memdesc:ab82f01a547b3363a86304ad285774a3f inherit pro_methods_class_louvre_1_1_l_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor of the <a class="el" href="class_louvre_1_1_l_object.html" title="Base class for Louvre objects.">LObject</a> class.  <br /></td></tr>
<tr class="separator:ab82f01a547b3363a86304ad285774a3f inherit pro_methods_class_louvre_1_1_l_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af564f691ad42dec99924f2889175f323 inherit pro_methods_class_louvre_1_1_l_object" id="r_af564f691ad42dec99924f2889175f323"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_object.html#af564f691ad42dec99924f2889175f323">notifyDestruction</a> () noexcept</td></tr>
<tr class="memdesc:af564f691ad42dec99924f2889175f323 inherit pro_methods_class_louvre_1_1_l_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notifies the object destruction.  <br /></td></tr>
<tr class="separator:af564f691ad42dec99924f2889175f323 inherit pro_methods_class_louvre_1_1_l_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A display rendering interface. </p>
<p><a class="anchor" id="loutput_detailed"></a> The <a class="el" href="class_louvre_1_1_l_output.html" title="A display rendering interface.">LOutput</a> class is responsible for rendering content to a display. It is typically associated with a physical screen, but could also represent a toplevel window within Wayland desktop, depending on the selected graphic backend.</p>
<center><img src="https://lh3.googleusercontent.com/4lV1LTHBmO-eFywBrL4UhYIRcQbV5bjGB_17FdWFCzjGvnklxwBnXz5hQKOrkRCOegsn6PjnYZNCWk1SjFjwh9t8olEzr3Uwzd3saEt8EKRbbqX0n1f5R7q6r6V9u1t0PUk7BB0teA" alt="" height="250px" class="inline"/></center><h1><a class="anchor" id="Lifetime"></a>
Lifetime</h1>
<p>During compositor initialization, the graphic backend creates an <a class="el" href="class_louvre_1_1_l_output.html" title="A display rendering interface.">LOutput</a> for each available display through <a class="el" href="class_louvre_1_1_l_compositor.html#af3e8f08b72263581c87aa240607438ef" title="Request to create a specific LFactoryObject.">LCompositor::createObjectRequest()</a>.<br  />
These can be accessed via the <a class="el" href="class_louvre_1_1_l_seat.html#a05aaba26b6841b8ea133a64d1d28cb5e" title="Vector of available outputs.">LSeat::outputs()</a> vector.</p>
<p>After the compositor has been initialized, the number of available outputs can change. These changes are notified through the <a class="el" href="class_louvre_1_1_l_seat.html#ade85a580ee6b9aa3aaead45f948d2e82" title="New available output.">LSeat::outputPlugged()</a> and <a class="el" href="class_louvre_1_1_l_seat.html#aff161f8b1d3c715362778773b4b612c6" title="Disconnected output.">LSeat::outputUnplugged()</a> events.</p>
<h1><a class="anchor" id="Initialization"></a>
Initialization</h1>
<p>By default, all outputs are uninitialized. To initialize an output, use <a class="el" href="class_louvre_1_1_l_compositor.html#a0b328b0723a35d00bbaff5aec6b9e9e0" title="Initializes the specified output.">LCompositor::addOutput()</a>, as done in the default implementation of <a class="el" href="class_louvre_1_1_l_compositor.html#a7916bd2f47b5b148cdb52d0f7c7803a3" title="Notifies a successful compositor initialization.">LCompositor::initialized()</a> and <a class="el" href="class_louvre_1_1_l_seat.html#ade85a580ee6b9aa3aaead45f948d2e82" title="New available output.">LSeat::outputPlugged()</a>.</p>
<p>When an output is successfully initialized, it is added to <a class="el" href="class_louvre_1_1_l_compositor.html#a05aaba26b6841b8ea133a64d1d28cb5e" title="Gets a vector of all initialized outputs.">LCompositor::outputs()</a> and a new output-specific rendering thread and shared OpenGL context are created, triggering the <a class="el" href="class_louvre_1_1_l_output.html#a2aeeb1c8e8bb0f723ebb7129df23d4e8" title="Initialize Event.">initializeGL()</a> event.</p>
<h1><a class="anchor" id="Uninitialization"></a>
Uninitialization</h1>
<p>To uninitialize an output, use <a class="el" href="class_louvre_1_1_l_compositor.html#aa6d9794dfb7cb513f834cf503591b864" title="Uninitializes the specified output.">LCompositor::removeOutput()</a>. This will invoke the <a class="el" href="class_louvre_1_1_l_output.html#a454d002ee90273a44dfb59a30246129e" title="Uninitialize Event.">uninitializeGL()</a> event, destroy the rendering thread and OpenGL context and remove the output from <a class="el" href="class_louvre_1_1_l_compositor.html#a05aaba26b6841b8ea133a64d1d28cb5e" title="Gets a vector of all initialized outputs.">LCompositor::outputs()</a>.<br  />
 </p><dl class="section note"><dt>Note</dt><dd>Outputs are also automatically uninitialized following an <a class="el" href="class_louvre_1_1_l_seat.html#aff161f8b1d3c715362778773b4b612c6" title="Disconnected output.">LSeat::outputUnplugged()</a> event.</dd></dl>
<h1><a class="anchor" id="Rendering"></a>
Rendering</h1>
<p>The rendering thread loop remains blocked until <a class="el" href="class_louvre_1_1_l_output.html#a3640e75ecf0af51755b05a1e1262b25c" title="Unlocks the rendering thread.">repaint()</a> is called, which unlocks the thread and asynchronously triggers the <a class="el" href="class_louvre_1_1_l_output.html#a0569e991ee4c6e4242578aca6d999741" title="Paint Event.">paintGL()</a> event.</p>
<p>All painting operations must occur exclusively within a <a class="el" href="class_louvre_1_1_l_output.html#a0569e991ee4c6e4242578aca6d999741" title="Paint Event.">paintGL()</a> event, as rendering elsewhere will not be visible on the screen.</p>
<p>Calling <a class="el" href="class_louvre_1_1_l_output.html#a3640e75ecf0af51755b05a1e1262b25c" title="Unlocks the rendering thread.">repaint()</a> multiple times will only unlock the thread once. After or during a <a class="el" href="class_louvre_1_1_l_output.html#a0569e991ee4c6e4242578aca6d999741" title="Paint Event.">paintGL()</a> event, <a class="el" href="class_louvre_1_1_l_output.html#a3640e75ecf0af51755b05a1e1262b25c" title="Unlocks the rendering thread.">repaint()</a> must be called again to unlock the thread once more.</p>
<h1><a class="anchor" id="render_multithreading"></a>
Multithreading</h1>
<p>In <a class="el" href="namespace_louvre.html" title="Namespaces.">Louvre</a>, even if there is a main thread and each initialized <a class="el" href="class_louvre_1_1_l_output.html" title="A display rendering interface.">LOutput</a> has its own rendering thread, no single block of user code executes in parallel (unless you create custom threads, of course). For instance, all <b>xxxGL()</b> events never overlap with other events or requests being handled in separate threads.</p>
<p>You may be wondering why the need to use rendering threads then?</p>
<p>The answer is that calling rendering functions (in this case OpenGL functions) takes almost no time (except for <b>glFinish()</b>). Rendering commands are queued and processed later together with a page flip. For instance, if your monitor has a 60 Hz refresh rate (approximately 16 ms period), a <a class="el" href="class_louvre_1_1_l_output.html#a0569e991ee4c6e4242578aca6d999741" title="Paint Event.">paintGL()</a> call may take 1 ms to be processed while the presentation on screen could take up to 15 ms (with V-Sync on). However, during those 15 ms, the main thread or other rendering threads can continue working. This allows <a class="el" href="namespace_louvre.html" title="Namespaces.">Louvre</a> compositors to maintain a constant high refresh rate compared to single-threaded designs.</p>
<h1><a class="anchor" id="Painting"></a>
Painting</h1>
<p>Each output has its own OpenGL context and its own instance of <a class="el" href="class_louvre_1_1_l_painter.html" title="Basic 2D rendering utility.">LPainter</a>, accessible via <a class="el" href="class_louvre_1_1_l_output.html#a50b3bf074aafac5129b43cca80e0db38" title="Gets access to the associated LPainter.">painter()</a>.</p>
<p>You can use <a class="el" href="class_louvre_1_1_l_painter.html" title="Basic 2D rendering utility.">LPainter</a> methods to render colored rectangles or textures, use OpenGL directly with your own shaders/programs, or rely on the <a class="el" href="class_louvre_1_1_l_scene.html" title="Scene.">LScene</a> class.<br  />
<a class="el" href="class_louvre_1_1_l_scene.html" title="Scene.">LScene</a> can render views optimally by considering surface damage, opaque regions, and other factors to significantly improve performance.</p>
<h1><a class="anchor" id="Modes"></a>
Modes</h1>
<p>Each <a class="el" href="class_louvre_1_1_l_output.html" title="A display rendering interface.">LOutput</a> has at least one mode. An <a class="el" href="class_louvre_1_1_l_output_mode.html" title="Output resolution and refresh rate.">LOutputMode</a> contains information about the resolution and refresh rate at which the output can operate.</p>
<p>You can access the modes of an output using <a class="el" href="class_louvre_1_1_l_output.html#adb161afb5f8aa93896dead7d42ef5ab4" title="Available modes.">modes()</a> and set the desired one with <a class="el" href="class_louvre_1_1_l_output.html#a376a36620b1acd2a0d154f8993bacdb4" title="Sets the output mode.">setMode()</a>.</p>
<p>By default, outputs use the <a class="el" href="class_louvre_1_1_l_output.html#a387f10410e3367f22eb35e6595991811" title="Gets the preferred mode.">preferredMode()</a>, which typically has the highest refresh rate and resolution.</p>
<p>If you change an output's mode or scale while it is initialized, the <a class="el" href="class_louvre_1_1_l_output.html#ad4dc5e1f724869e9523ce872afd56a1a" title="Resize Event.">resizeGL()</a> event is triggered.</p>
<h1><a class="anchor" id="Arrangement"></a>
Arrangement</h1>
<p>Outputs, like surfaces, can be positioned within the compositor-global coordinate space similarly to how a system settings panel operates.</p>
<p>You can adjust the position of an output using <a class="el" href="class_louvre_1_1_l_output.html#a6ab8c3ffe18601c1d3d355c385553a4c" title="Set the position of the output.">setPos()</a>. This will later trigger the <a class="el" href="class_louvre_1_1_l_output.html#aa15f67e7da7f9351890b2c6258ee9225" title="Move Event.">moveGL()</a> event if the position changes.</p>
<center><img src="https://lh3.googleusercontent.com/VOWUX4iiqYMF_bIrBP3xMyaiydv_e_ZKznCIJlRLaEA0CtBLMuU4h41R3D4Xm-7krk8jFGZrQGb_SS7hlIFUY9E5dVbQqs0Q3NIBXvRFrGs_cukqOmbCv1ExN9fG3BDdj4Yz45xIkQ=w2400" alt="" height="350px" class="inline"/></center><dl class="section note"><dt>Note</dt><dd>To enable <a class="el" href="class_louvre_1_1_l_cursor.html" title="Utility class for rendering cursors.">LCursor</a> to transition across different LOutputs, ensure that the outputs are closely arranged side by side.</dd></dl>
<h1><a class="anchor" id="Scaling"></a>
Scaling</h1>
<p>Many screens nowadays are HiDPI, so it is commonly required to apply a scaling factor to prevent content from appearing tiny on the screen.<br  />
By default, all outputs have a scaling factor of 1, meaning no scaling is applied. To assign the scale factor use <a class="el" href="class_louvre_1_1_l_output.html#af950653f0fe07aed8acca7079047fb94" title="Sets the output scale factor.">setScale()</a>, which modifies the size returned by <a class="el" href="class_louvre_1_1_l_output.html#af0e9483bc8188a275f4877e55ec720b0" title="Gets the output size in surface units.">size()</a> (same as <code><a class="el" href="class_louvre_1_1_l_output.html#a315aa6ec38b7660b6e56b8591199172b" title="Gets the output rect.">rect()</a>.<a class="el" href="class_louvre_1_1_l_output.html#af0e9483bc8188a275f4877e55ec720b0" title="Gets the output size in surface units.">size()</a></code>).</p>
<p>In <a class="el" href="namespace_louvre.html" title="Namespaces.">Louvre</a>, you typically need to deal with two type of units: <em><b>buffer units</b></em> and <em><b>surface units</b></em>.</p>
<p>In buffer units, the scale factor is not taken into account, and the dimensions always have maximum granularity.<br  />
For example, if a screen has a resolution of 2000x1000px, its size in buffer units would be the same: 2000x1000px, which is returned by <a class="el" href="class_louvre_1_1_l_output.html#a9595879ae0c4def717bd69d345001ed0" title="Gets the output size in buffer units.">sizeB()</a>.<br  />
However, the compositor-global coordinate space uses surface units, which is equal to the buffer size divided by the applied scale factor.<br  />
Therefore, if a scale factor of 2 applied to the screen, its size in surface units would be 1000x500, which is returned by <a class="el" href="class_louvre_1_1_l_output.html#af0e9483bc8188a275f4877e55ec720b0" title="Gets the output size in surface units.">size()</a> and <code><a class="el" href="class_louvre_1_1_l_output.html#a315aa6ec38b7660b6e56b8591199172b" title="Gets the output rect.">rect()</a>.<a class="el" href="class_louvre_1_1_l_output.html#af0e9483bc8188a275f4877e55ec720b0" title="Gets the output size in surface units.">size()</a></code>.</p>
<dl class="section note"><dt>Note</dt><dd>Use surface units (<a class="el" href="class_louvre_1_1_l_output.html#a0843c1bb97b8a8cfb3faa6f75e68acd6" title="Gets the output position.">pos()</a> and <a class="el" href="class_louvre_1_1_l_output.html#af0e9483bc8188a275f4877e55ec720b0" title="Gets the output size in surface units.">size()</a> or <a class="el" href="class_louvre_1_1_l_output.html#a315aa6ec38b7660b6e56b8591199172b" title="Gets the output rect.">rect()</a>) when arranging outputs.</dd></dl>
<p>Let's look at an example to make these concepts clearer:</p>
<p>Let's assume you have two displays, one with a resolution of 1000x500px and another with 2000x1000px (double the resolution), but both with a physical size of 22''. This means that the space occupied by 1px on the blue screen accommodates 4px on the pink screen.</p>
<p>If you were to see them in real life, side by side they would look like this:</p>
<center><img src="https://lh3.googleusercontent.com/pw/ABLVV87QBEaAMVfuF92jfv0HRQrEgc0PMKgx9N29Wb6dDbF9cHLpCr7qSDUowUFnBXFHJxg4F9c7v7EcxxTSnpSzkEqLvCB7CxlnUYJmG1JsNspSHRq3zZE=w2400" alt="" class="inline"/></center><p>If you assign the same scaling factor of 1 to both screens, their sizes in surface units would be the same as in buffer units.<br  />
Therefore, from the compositor-global coordinate space point of view they would be arranged like this:</p>
<center><img src="https://lh3.googleusercontent.com/pw/ABLVV86CZvhAIc-yONr5BQe6ABGxfcuSVajo1jobAWL5C6tMdJO8BXjsbMbZk7r7rEZ9-ZsYmr3LsIdBSKkb3npEYoCIG1OD0iZKUoCDFVoqMG4avt06Vhs=w2400" alt="" class="inline"/></center><p>And if you were to see them in real life, they would look like the following. In the pink screen, everything would appear tiny, half the size of the blue screen. And as you can see, if you were to drag an application window from one screen to another, it would look somewhat odd.</p>
<center><img src="https://lh3.googleusercontent.com/pw/ABLVV84F3o3dewpcSRttqMHPjKO2YYUqSJ299tj760KcT6KRd0s7uf_bXtKQfwy5CFeXqPoxynuu2UmtkEOodg1l7DjZHoXohjXdpGIth9S50mKGdsHqfPw=w2400" alt="" class="inline"/></center><p>Now, let's imagine that you assign a scaling factor of 2 to the pink screen. In this case, the compositor-global coordiante space would look as follows:</p>
<center><img src="https://lh3.googleusercontent.com/pw/ABLVV86j52vqCYAxcm94frzQHzeI47idYlb-tggnlbwcVsZZwXIkr9M4tyhKPMDLfmtjOYqHWS9jnCiXojuusl8EKyv3OIn8KQX6biHr0hQeLxH7m04VaTc=w2400" alt="" class="inline"/></center><p>And therefore, if you were to see them in real life now, the UI elements dimensions would appear consistently.</p>
<center><img src="https://lh3.googleusercontent.com/pw/ABLVV87mN6ufD6PY9Rt8fjl3B84ii627PdOYwJx9vmeA72EeT_cpr8Q01IdoiBknoPI6fonVJWRCW34VZNKVKCsNIERY70Gvqkl7eH0R2vr3gBrEtuMNps0=w2400" alt="" class="inline"/></center><p>Therefore, in summary, the size of a screen in surface units is determined by dividing its buffer size by the applied scale factor.</p>
<h2><a class="anchor" id="fractional-scaling"></a>
Fractional Scaling</h2>
<p><a class="el" href="namespace_louvre.html" title="Namespaces.">Louvre</a> also supports fractional scaling, albeit with some differences compared to integer scaling. For instance, if you assign a scale factor of 1.5 using <a class="el" href="class_louvre_1_1_l_output.html#af950653f0fe07aed8acca7079047fb94" title="Sets the output scale factor.">setScale()</a> to the pink screen, the resulting applied scale (obtained with <a class="el" href="class_louvre_1_1_l_output.html#a788d4e63bfe520c6db3ef3d9ccde0ec4" title="Retrieves the current output scale factor.">scale()</a>) will be ceil(1.5) = 2. However, the buffer dimensions of the screen will simulate being 2/1.5 times larger than its current mode (rounded), resulting in 2668 x 1334 for this case. Consequently, its size in surface coordinates would be 2668 x 1334 divided by 2. As a result, the compositor-global coordinate space would appear as follows:</p>
<center><img src="https://lh3.googleusercontent.com/pw/ABLVV86R-d2uzDybJ-FLWL5PzbShg33f2_OJX9mQME8DkVI5y6O3eDT18UBRgwY8UScaApeoqU4ePq3BwbDNmW5Z-eW0dukpvdQfmarUbOVEbN_GmYU3MqE=w2400" alt="" class="inline"/></center><p>This creates the illusion of rendering on a larger screen, the result of which is actually scaled to the real size, allowing for the desired scaling effect.<br  />
Rendering using fractional scaling, however, can introduce undesired visual effects like aliasing, especially noticeable when moving elements with textures containing fine details. For this reason, <a class="el" href="namespace_louvre.html" title="Namespaces.">Louvre</a> offers the option to render using oversampling, where all the screen content is rendered into a larger buffer, and then that rendered buffer is scaled down to the actual screen framebuffer. This method almost completely eliminates aliasing but has the disadvantage of consuming more computational power, potentially decreasing performance. Without oversampling the content is directly rendered on the screen, making it efficient but retaining aliasing artifacts.<br  />
<a class="el" href="namespace_louvre.html" title="Namespaces.">Louvre</a> allows you to toggle oversampling on and off instantly at any time using <a class="el" href="class_louvre_1_1_l_output.html#a9b261f037b65f4e6f20a28c179cdd179" title="Toggles oversampling for fractional scales.">enableFractionalOversampling()</a>. For example, you could enable it when displaying a desktop with floating windows and disable it when displaying a fullscreen window.</p>
<dl class="section note"><dt>Note</dt><dd>Oversampling is not required and is always disabled when using non-fractional scales. Therefore, as a recommendation, if your monitor supports multiple <a class="el" href="class_louvre_1_1_l_output.html#adb161afb5f8aa93896dead7d42ef5ab4" title="Available modes.">modes()</a> with various resolutions, it is preferable to select one of those modes instead of using fractional scaling.</dd></dl>
<p>Clients supporting the <a href="https://wayland.app/protocols/fractional-scale-v1">fractional scaling protocol</a> are instructed to scale their buffers directly to the fractional scale.<br  />
On the other hand, clients lacking support for the protocol are advised to use ceil(fractional scale), ensuring a consistently high-detail appearance.</p>
<h1><a class="anchor" id="Transforms"></a>
Transforms</h1>
<p><a class="el" href="namespace_louvre.html" title="Namespaces.">Louvre</a> supports applying transforms to outputs with <a class="el" href="class_louvre_1_1_l_output.html#ae4983ad9b25b32cd00f7b943894666a8" title="Sets the framebuffer transform.">setTransform()</a>.</p>
<p>Let's imagine that you physically rotate the pink monitor 90 clockwise while maintaining the same normal transform on both. What you would see is the following:</p>
<center><img src="https://lh3.googleusercontent.com/pw/ABLVV85bV4h-OcbW1DozgUCQp4PbMoWOd2E2MNRQveEhw5r2p_mjnVRLbziTJ-egMu9D0eSIbMyLNmXECbupfa1gmQZMAidIS1pT5ahbeoL6hcsa6O3QlYc=w2400" alt="" class="inline"/></center><p>Given that you rotated the screen 90 clockwise, it is necessary to apply a transform that rotates the screen 90 counter-clockwise (<a class="el" href="namespace_louvre.html#a700c2230c9a7c049255f06a9ca53b72ba9ef5df811351f04c4bf2545d38f7f3b1">LTransform::Rotated90</a>). If you apply this to the pink screen, then you would see the following:</p>
<center><img src="https://lh3.googleusercontent.com/pw/ABLVV84Tm3VGwuNHqbAumAVrzZVgBtKSOo24y8PDk5Y47hIlLmO7uSzIMLeE0f9y-5DOQh1nOI9-qz48c_fnlgkM3CILC-GFB2qttGaE671Xke_jcF6DlVY=w2400" alt="" class="inline"/></center><p>Note that when applying a transformation containing a 90 or 270 rotation to an output, the components of <a class="el" href="class_louvre_1_1_l_output.html#a9595879ae0c4def717bd69d345001ed0" title="Gets the output size in buffer units.">sizeB()</a>, <a class="el" href="class_louvre_1_1_l_output.html#af0e9483bc8188a275f4877e55ec720b0" title="Gets the output size in surface units.">size()</a> and <code><a class="el" href="class_louvre_1_1_l_output.html#a315aa6ec38b7660b6e56b8591199172b" title="Gets the output rect.">rect()</a>.<a class="el" href="class_louvre_1_1_l_output.html#af0e9483bc8188a275f4877e55ec720b0" title="Gets the output size in surface units.">size()</a></code> are swapped (their width becomes the height, and the height becomes the width). The compositor-global coordiante space is structured in such a way that you can continue rendering in the same manner as if the screens were in their normal transform state. Therefore, there's no need to worry about rotating or flipping the elements you draw unless you decide not to use <a class="el" href="class_louvre_1_1_l_painter.html" title="Basic 2D rendering utility.">LPainter</a> or <a class="el" href="class_louvre_1_1_l_scene.html" title="Scene.">LScene</a> for rendering.</p>
<h1><a class="anchor" id="VSync"></a>
VSync</h1>
<p>All outputs have VSync enabled by default. Disabling VSync may not always be supported, refer to <a class="el" href="class_louvre_1_1_l_output.html#ab37de15dd67cb6861eface25a2c1498b" title="Checks if VSync control is supported for this output.">hasVSyncControlSupport()</a>.</p>
<p>VSync can be toggled using <a class="el" href="class_louvre_1_1_l_output.html#aad3bf6e06d340d3dc8d267e4e654afeb" title="Turns VSync on or off.">enableVSync()</a>. When VSync is disabled, <a class="el" href="namespace_louvre.html" title="Namespaces.">Louvre</a> limits the frame rate to double the refresh rate of the <a class="el" href="class_louvre_1_1_l_output.html#aee653f4eaf5e9fb3f85b48d72500185a" title="Gets the current mode.">currentMode()</a> by default. This setting can be changed with <a class="el" href="class_louvre_1_1_l_output.html#af1564c3c6d1b77f089702e01ec4502d9" title="Sets the refresh rate limit in Hz when VSync is disabled.">setRefreshRateLimit()</a>.</p>
<p>Clients using the Tearing Protocol can indicate their preference for each individual surface.<br  />
See <a class="el" href="class_louvre_1_1_l_surface.html#ac8212dc8e0490f5dd5671187b07f0773" title="Gets the VSync preference of the client for this surface.">LSurface::preferVSync()</a> and <a class="el" href="class_louvre_1_1_l_surface.html#a17d11b10d54f0f54fbb8ad6020c135f6" title="Notifies about changes in the VSync preference.">LSurface::preferVSyncChanged()</a> for more details.</p>
<h1><a class="anchor" id="drm_leasing"></a>
DRM Leasing</h1>
<p><a href="https://wayland.app/protocols/drm-lease-v1">DRM leasing</a> is a Wayland protocol and backend feature that allows clients to take control of a specific set of displays.<br  />
It is typically used by VR applications to render directly into VR headsets, skipping the compositor presentation and thereby reducing latency.</p>
<p>To advertise an output as leasable, use <a class="el" href="class_louvre_1_1_l_output.html#ad7f3f3691fe3e30d5a56299f3c6c74cf" title="Advertises the output as leasable.">setLeasable()</a>. By default, <a class="el" href="namespace_louvre.html" title="Namespaces.">Louvre</a> disables it for all outputs except for those with <a class="el" href="class_louvre_1_1_l_output.html#a5ec1b13e7e27217080250c93e0139725" title="Determines if the output is intended for non-desktop usage.">isNonDesktop()</a> set to <code>true</code>, which usually indicates a VR headset. See <a class="el" href="class_louvre_1_1_l_compositor.html#a7916bd2f47b5b148cdb52d0f7c7803a3" title="Notifies a successful compositor initialization.">LCompositor::initialized()</a> and <a class="el" href="class_louvre_1_1_l_seat.html#ade85a580ee6b9aa3aaead45f948d2e82" title="New available output.">LSeat::outputPlugged()</a>.</p>
<p>For each leasable output, clients can issue a <a class="el" href="class_louvre_1_1_l_output.html#a831a684290662b218b58ae77d82299f3" title="Handles client requests to lease the output.">leaseRequest()</a> which can be accepted or denied, returning <code>true</code> or <code>false</code>.<br  />
Each time the output starts or stops being leased, the <a class="el" href="class_louvre_1_1_l_output.html#a5b404ffeeead230796583114274bec55" title="Current lease created after an accepted leaseRequest().">lease()</a> property changes, which is notified with <a class="el" href="class_louvre_1_1_l_output.html#aa5fd996431679f9db64a6a859eab7743" title="Notifies a change in the lease() property.">leaseChanged()</a>.</p>
<p>The <a class="el" href="class_louvre_1_1_l_output.html#a5b404ffeeead230796583114274bec55" title="Current lease created after an accepted leaseRequest().">lease()</a> property allows you to see which client is currently leasing an output and also to stop the lease by calling <code><a class="el" href="class_louvre_1_1_l_output.html#a5b404ffeeead230796583114274bec55" title="Current lease created after an accepted leaseRequest().">lease()</a>-&gt;finished()</code>.<br  />
The lease is also terminated if the compositor initializes the output or if <a class="el" href="class_louvre_1_1_l_output.html#a8aa371d15583bb4f1cb3d507b27aa559" title="Checks if the output is advertised as leasable.">leasable()</a> is set to <code>false</code>.</p>
<p>An output can't be initialized and leased at the same time, enabling one disables the other.</p>
<dl class="section note"><dt>Note</dt><dd>Whenever the user switches to another session and the backend loses DRM master, all active leases are destroyed. Clients must request them again once the session is restored. </dd></dl>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a5d74787dedbc4e11c1ab15bf487e61f8" name="a5d74787dedbc4e11c1ab15bf487e61f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d74787dedbc4e11c1ab15bf487e61f8">&#9670;&#160;</a></span>State</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_louvre_1_1_l_output.html#a5d74787dedbc4e11c1ab15bf487e61f8">State</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Output state. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_louvre_1_1_l_output.html#a9b866d19a1178ee624d2dfb31c744dee" title="Gets the current state of the LOutput.">state()</a> </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a5d74787dedbc4e11c1ab15bf487e61f8ad83e069857681eacefa2ed3ea543f21d" name="a5d74787dedbc4e11c1ab15bf487e61f8ad83e069857681eacefa2ed3ea543f21d"></a>PendingInitialize&#160;</td><td class="fielddoc"><p>Output is pending initialization. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5d74787dedbc4e11c1ab15bf487e61f8a7a7304bcbfd2527762b18d301de0fd16" name="a5d74787dedbc4e11c1ab15bf487e61f8a7a7304bcbfd2527762b18d301de0fd16"></a>PendingUninitialize&#160;</td><td class="fielddoc"><p>Output is pending uninitialization. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5d74787dedbc4e11c1ab15bf487e61f8aae32940b344dab2f4e31be660ce1ab02" name="a5d74787dedbc4e11c1ab15bf487e61f8aae32940b344dab2f4e31be660ce1ab02"></a>Initialized&#160;</td><td class="fielddoc"><p>Output is initialized and active. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5d74787dedbc4e11c1ab15bf487e61f8a254bd1cf3c287ac4eb3d47320b1c92b6" name="a5d74787dedbc4e11c1ab15bf487e61f8a254bd1cf3c287ac4eb3d47320b1c92b6"></a>Uninitialized&#160;</td><td class="fielddoc"><p>Output is uninitialized. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5d74787dedbc4e11c1ab15bf487e61f8a151f7ecff2156021548285c6a31ff01f" name="a5d74787dedbc4e11c1ab15bf487e61f8a151f7ecff2156021548285c6a31ff01f"></a>ChangingMode&#160;</td><td class="fielddoc"><p>Output is in the process of changing display mode. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5d74787dedbc4e11c1ab15bf487e61f8a13bd6ff4bd5714ccc293f6802aacb40d" name="a5d74787dedbc4e11c1ab15bf487e61f8a13bd6ff4bd5714ccc293f6802aacb40d"></a>Suspended&#160;</td><td class="fielddoc"><p>Output is suspended. </p>
</td></tr>
</table>

</div>
</div>
<a id="acf3ae70a3f91b9f2d855904572dcbed8" name="acf3ae70a3f91b9f2d855904572dcbed8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf3ae70a3f91b9f2d855904572dcbed8">&#9670;&#160;</a></span>SubPixel</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_louvre_1_1_l_output.html#acf3ae70a3f91b9f2d855904572dcbed8">SubPixel</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subpixel geometry. </p>
<p>This enumeration provides information about how the physical pixels on an output are laid out.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_louvre_1_1_l_output.html#a026774ddbfcac05e0a2e0eb582b7807f" title="Gets the layout of RGB subpixels for a single pixel on a display.">subPixel()</a> </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="acf3ae70a3f91b9f2d855904572dcbed8a4e81c184ac3ad48a389cd4454c4a05bb" name="acf3ae70a3f91b9f2d855904572dcbed8a4e81c184ac3ad48a389cd4454c4a05bb"></a>Unknown&#160;</td><td class="fielddoc"><p>Unknown geometry. </p>
</td></tr>
<tr><td class="fieldname"><a id="acf3ae70a3f91b9f2d855904572dcbed8ac9d3e887722f2bc482bcca9d41c512af" name="acf3ae70a3f91b9f2d855904572dcbed8ac9d3e887722f2bc482bcca9d41c512af"></a>None&#160;</td><td class="fielddoc"><p>No specific geometry. </p>
</td></tr>
<tr><td class="fieldname"><a id="acf3ae70a3f91b9f2d855904572dcbed8af6dd61d48c7e7bb981b99292d7aac1d0" name="acf3ae70a3f91b9f2d855904572dcbed8af6dd61d48c7e7bb981b99292d7aac1d0"></a>HorizontalRGB&#160;</td><td class="fielddoc"><p>Horizontal RGB layout. </p>
</td></tr>
<tr><td class="fieldname"><a id="acf3ae70a3f91b9f2d855904572dcbed8a0a5e58bbb886fe45f3587a21f23acc53" name="acf3ae70a3f91b9f2d855904572dcbed8a0a5e58bbb886fe45f3587a21f23acc53"></a>HorizontalBGR&#160;</td><td class="fielddoc"><p>Horizontal BGR layout. </p>
</td></tr>
<tr><td class="fieldname"><a id="acf3ae70a3f91b9f2d855904572dcbed8a16d7d3a5b59ca99c3be61b0da997b8c9" name="acf3ae70a3f91b9f2d855904572dcbed8a16d7d3a5b59ca99c3be61b0da997b8c9"></a>VerticalRGB&#160;</td><td class="fielddoc"><p>Vertical RGB layout. </p>
</td></tr>
<tr><td class="fieldname"><a id="acf3ae70a3f91b9f2d855904572dcbed8ae45d01b6582fb4a2e7734d3b6bb2a7f6" name="acf3ae70a3f91b9f2d855904572dcbed8ae45d01b6582fb4a2e7734d3b6bb2a7f6"></a>VerticalBGR&#160;</td><td class="fielddoc"><p>Vertical BGR layout. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ae46b034566ab111fc6e3b1c74800c07d" name="ae46b034566ab111fc6e3b1c74800c07d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae46b034566ab111fc6e3b1c74800c07d">&#9670;&#160;</a></span>LOutput()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_louvre_1_1_l_output.html">LOutput</a> </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor of the <a class="el" href="class_louvre_1_1_l_output.html" title="A display rendering interface.">LOutput</a> class. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td>Internal parameters provided in <a class="el" href="class_louvre_1_1_l_compositor.html#af3e8f08b72263581c87aa240607438ef" title="Request to create a specific LFactoryObject.">LCompositor::createObjectRequest()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad154579ae13924ffd51510a3712c5d55" name="ad154579ae13924ffd51510a3712c5d55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad154579ae13924ffd51510a3712c5d55">&#9670;&#160;</a></span>~LOutput()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">~<a class="el" href="class_louvre_1_1_l_output.html">LOutput</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructor of the <a class="el" href="class_louvre_1_1_l_output.html" title="A display rendering interface.">LOutput</a> class. </p>
<p>Invoked after <a class="el" href="class_louvre_1_1_l_compositor.html#aa8850deab2bf40dc6cb9e276b22e39cb" title="Announce the anticipated destruction of an LFactoryObject.">LCompositor::onAnticipatedObjectDestruction()</a>. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a102c8d5ab363c7e4e0d93bc41118993c" name="a102c8d5ab363c7e4e0d93bc41118993c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a102c8d5ab363c7e4e0d93bc41118993c">&#9670;&#160;</a></span>id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_louvre.html#a7e8aeec7b6541935dfc6f608cd5170ce">UInt32</a> id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves a unique identifier for the output. </p>
<p>This identifier is guaranteed to be unique for each output.</p>
<p>When using the DRM backend, it corresponds to the underlying DRM connector ID. </p>

</div>
</div>
<a id="a9b866d19a1178ee624d2dfb31c744dee" name="a9b866d19a1178ee624d2dfb31c744dee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b866d19a1178ee624d2dfb31c744dee">&#9670;&#160;</a></span>state()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_louvre_1_1_l_output.html#a5d74787dedbc4e11c1ab15bf487e61f8">LOutput::State</a> state </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the current state of the <a class="el" href="class_louvre_1_1_l_output.html" title="A display rendering interface.">LOutput</a>. </p>
<p>This method returns the current state of the output. </p>

</div>
</div>
<a id="a805c69f2ba10cd237849c553ec9ce99e" name="a805c69f2ba10cd237849c553ec9ce99e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a805c69f2ba10cd237849c553ec9ce99e">&#9670;&#160;</a></span>gpu()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_louvre_1_1_l_g_p_u.html">LGPU</a> * gpu </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the GPU to which this output belongs. </p>
<p>Each output always belongs to a single GPU.</p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the GPU this output belongs to. </dd></dl>

</div>
</div>
<a id="a50b3bf074aafac5129b43cca80e0db38" name="a50b3bf074aafac5129b43cca80e0db38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50b3bf074aafac5129b43cca80e0db38">&#9670;&#160;</a></span>painter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_louvre_1_1_l_painter.html">LPainter</a> * painter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets access to the associated <a class="el" href="class_louvre_1_1_l_painter.html" title="Basic 2D rendering utility.">LPainter</a>. </p>
<p>This method provides access to the <a class="el" href="class_louvre_1_1_l_painter.html" title="Basic 2D rendering utility.">LPainter</a> associated with this output. </p>

</div>
</div>
<a id="a4b836fa9e76c09053fae6b06d1455c67" name="a4b836fa9e76c09053fae6b06d1455c67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b836fa9e76c09053fae6b06d1455c67">&#9670;&#160;</a></span>sessionLockRole()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_louvre_1_1_l_session_lock_role.html">LSessionLockRole</a> * sessionLockRole </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Session Lock Surface. </p>
<p>When a client requests to lock the user session (see <a class="el" href="class_louvre_1_1_l_session_lock_manager.html" title="Manages session lock requests and state changes.">LSessionLockManager</a>), it creates an <a class="el" href="class_louvre_1_1_l_session_lock_role.html" title="Surface displayed during a session lock.">LSessionLockRole</a> surface for each initialized output whith a size equals to the output <a class="el" href="class_louvre_1_1_l_output.html#af0e9483bc8188a275f4877e55ec720b0" title="Gets the output size in surface units.">size()</a>.</p>
<p>If the session is locked and there is no <a class="el" href="class_louvre_1_1_l_session_lock_role.html" title="Surface displayed during a session lock.">LSessionLockRole</a> assigned to this output, the compositor should still avoid rendering any user-related content.</p>
<dl class="section return"><dt>Returns</dt><dd>An instance of the <a class="el" href="class_louvre_1_1_l_session_lock_role.html" title="Surface displayed during a session lock.">LSessionLockRole</a> associated with this output if the session is locked, or <code>nullptr</code> if the session is not locked or the locking client didn't create one. </dd></dl>

</div>
</div>
<a id="afc3ea58fabda3ae63531b9f99d955adc" name="afc3ea58fabda3ae63531b9f99d955adc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc3ea58fabda3ae63531b9f99d955adc">&#9670;&#160;</a></span>exclusiveZones()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::list&lt; <a class="el" href="class_louvre_1_1_l_exclusive_zone.html">LExclusiveZone</a> * &gt; exclusiveZones </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves all exclusive zones assigned to this output. </p>
<p>The order of the list determines how zones anchored to the same edge are stacked. Zones listed first are positioned closer to the output's edge. Additionally, the order affects their predominance: zones listed later adjust their space to avoid occluding those listed earlier.</p>
<dl class="section return"><dt>Returns</dt><dd>A list of pointers to <a class="el" href="class_louvre_1_1_l_exclusive_zone.html" title="Exclusive zone within an LOutput.">LExclusiveZone</a> objects. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_louvre_1_1_l_exclusive_zone.html#a8d493e298cd1c8b00a8ab195424c12a6" title="Sets the current output.">LExclusiveZone::setOutput()</a> </dd></dl>

</div>
</div>
<a id="a33473d432755f05c5eda568b383000ff" name="a33473d432755f05c5eda568b383000ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33473d432755f05c5eda568b383000ff">&#9670;&#160;</a></span>availableGeometry()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_louvre.html#ad83fc7af7b313dac8820e4d4bd5b4383">LRect</a> &amp; availableGeometry </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the rect within the output that is not occupied by exclusive zones. </p>
<p>The available geometry defines the space within an output where, for example, <a class="el" href="class_louvre_1_1_l_toplevel_role.html" title="Toplevel role for surfaces.">LToplevelRole</a> surfaces should be constrained to prevent occluding UI elements like a panel.</p>
<p>The rect is in output-local surface coordinates.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_louvre_1_1_l_output.html#afc3ea58fabda3ae63531b9f99d955adc" title="Retrieves all exclusive zones assigned to this output.">exclusiveZones()</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A rect representing the available geometry. </dd></dl>

</div>
</div>
<a id="ac24588e06d25cf65b28c6b5ff8574789" name="ac24588e06d25cf65b28c6b5ff8574789"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac24588e06d25cf65b28c6b5ff8574789">&#9670;&#160;</a></span>exclusiveEdges()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_louvre.html#struct_louvre_1_1_l_margins">LMargins</a> &amp; exclusiveEdges </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the sum of the space occupied by exclusive zones for each edge. </p>
<p>This function provides margins that represent the total area taken up by the exclusive zones along each edge of the output.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_louvre_1_1_l_output.html#afc3ea58fabda3ae63531b9f99d955adc" title="Retrieves all exclusive zones assigned to this output.">exclusiveZones()</a> </dd>
<dd>
<a class="el" href="class_louvre_1_1_l_output.html#a33473d432755f05c5eda568b383000ff" title="Retrieves the rect within the output that is not occupied by exclusive zones.">availableGeometry()</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespace_louvre.html#struct_louvre_1_1_l_margins" title="Structure representing left, top, right and bottom margins.">LMargins</a> object representing the exclusive edges. </dd></dl>

</div>
</div>
<a id="a2b0e88488e807ce9e74c29420c9b4ceb" name="a2b0e88488e807ce9e74c29420c9b4ceb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b0e88488e807ce9e74c29420c9b4ceb">&#9670;&#160;</a></span>framebuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_louvre_1_1_l_framebuffer.html">LFramebuffer</a> * framebuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to the associated framebuffer. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_louvre_1_1_l_painter.html#a20cff5606b060b9f7bfeeb721186a5eb" title="Binds the specified framebuffer for rendering.">LPainter::bindFramebuffer()</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the <a class="el" href="class_louvre_1_1_l_framebuffer.html" title="Base class for LPainter framebuffers.">LFramebuffer</a> instance associated with the output. </dd></dl>

</div>
</div>
<a id="a6d51d766a73de9c03a44e3dc8df71d9a" name="a6d51d766a73de9c03a44e3dc8df71d9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d51d766a73de9c03a44e3dc8df71d9a">&#9670;&#160;</a></span>oversamplingTexture()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_louvre_1_1_l_texture.html">LTexture</a> * oversamplingTexture </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the texture used for oversampling. </p>
<p>Retrieves the intermediate texture used when a fractional scale is applied and oversampling is enabled.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_louvre_1_1_l_output.html#af354d97907e6bc371b9534f45edd4f75" title="Checks if the scale factor set with setScale() is fractional.">usingFractionalScale()</a> and <a class="el" href="class_louvre_1_1_l_output.html#a0b19b68cd7414ad718b8cbb117e24da5" title="Checks if oversampling is enabled.">fractionalOversamplingEnabled()</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The texture, or <code>nullptr</code> if oversampling is disabled. </dd></dl>

</div>
</div>
<a id="ae53642e01710db05adae9dab67917fa7" name="ae53642e01710db05adae9dab67917fa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae53642e01710db05adae9dab67917fa7">&#9670;&#160;</a></span>transform()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_louvre.html#a700c2230c9a7c049255f06a9ca53b72b">LTransform</a> transform </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the framebuffer transform. </p>
<p>This method returns the current framebuffer transform applied with <a class="el" href="class_louvre_1_1_l_output.html#ae4983ad9b25b32cd00f7b943894666a8" title="Sets the framebuffer transform.">setTransform()</a>.</p>
<p>The default value is <a class="el" href="namespace_louvre.html#a700c2230c9a7c049255f06a9ca53b72ba960b44c579bc2f6818d2daaf9e4c16f0">LTransform::Normal</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>The framebuffer transforma. </dd></dl>

</div>
</div>
<a id="ae4983ad9b25b32cd00f7b943894666a8" name="ae4983ad9b25b32cd00f7b943894666a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4983ad9b25b32cd00f7b943894666a8">&#9670;&#160;</a></span>setTransform()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setTransform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_louvre.html#a700c2230c9a7c049255f06a9ca53b72b">LTransform</a>&#160;</td>
          <td class="paramname"><em>transform</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the framebuffer transform. </p>
<p>This method sets the output transform, allowing you to adjust the orientation/flipping of the output.<br  />
If the specified transform includes a 90 or 270-degree rotation, the width and height of the output are swapped accordingly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transform</td><td>The framebuffer transformation to apply. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad297c46935046c5f6bd99bcbab99157a" name="ad297c46935046c5f6bd99bcbab99157a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad297c46935046c5f6bd99bcbab99157a">&#9670;&#160;</a></span>currentBufferAge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_louvre.html#a7e8aeec7b6541935dfc6f608cd5170ce">UInt32</a> currentBufferAge </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the age of the current buffer. </p>
<p>This method returns the age of the buffer as specified in the <a href="https://registry.khronos.org/EGL/extensions/EXT/EGL_EXT_buffer_age.txt">EGL_EXT_buffer_age</a> extension specification. </p>

</div>
</div>
<a id="a452f0d25a1d7db419c67673d82d5f21b" name="a452f0d25a1d7db419c67673d82d5f21b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a452f0d25a1d7db419c67673d82d5f21b">&#9670;&#160;</a></span>currentBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_louvre.html#a20b0c262d9ef5d263888e463dfa99638">Int32</a> currentBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index of the current buffer. </p>
<p>Compositors commonly employ double or triple buffering. This involves rendering to one buffer while displaying another, prventing visual artifacts like tearing.</p>
<div class="image">
<img src="https://lh3.googleusercontent.com/2ousoWwxnVGvFX5bT6ual2G8UUbhUOJ21mK1UQmthPNM-7XfracRlL5GCYBQTzt4Os28eKO_FzC6BS-rasiNngvTMI9lEdET0ItKrI2wK_9IwSDaF-hNGkTMI6gVlL0m4ENDJYbckw" alt=""/>
</div>
<dl class="section return"><dt>Returns</dt><dd>The current buffer index. Alternates between [0, 1] or [0, 1, 2] depending on the graphic backend configuration.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Some backends do not provide this information and will always return 0. For damage tracking, use <a class="el" href="class_louvre_1_1_l_output.html#ad297c46935046c5f6bd99bcbab99157a" title="Retrieves the age of the current buffer.">currentBufferAge()</a> instead. </dd></dl>

</div>
</div>
<a id="a6b774e7c0dfda35a3b2fc5377c0c7e35" name="a6b774e7c0dfda35a3b2fc5377c0c7e35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b774e7c0dfda35a3b2fc5377c0c7e35">&#9670;&#160;</a></span>buffersCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_louvre.html#a7e8aeec7b6541935dfc6f608cd5170ce">UInt32</a> buffersCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the count of available buffers. </p>
<p>This method returns the number of buffers used by the output. It can be 2 or 3 depending on the graphic backend configuration.</p>
<dl class="section warning"><dt>Warning</dt><dd>Some backends do not provide this information and will always return 0. For damage tracking, use <a class="el" href="class_louvre_1_1_l_output.html#ad297c46935046c5f6bd99bcbab99157a" title="Retrieves the age of the current buffer.">currentBufferAge()</a> instead. </dd></dl>

</div>
</div>
<a id="a7be8794bc1df3aaa6304f9e169581852" name="a7be8794bc1df3aaa6304f9e169581852"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7be8794bc1df3aaa6304f9e169581852">&#9670;&#160;</a></span>bufferTexture()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_louvre_1_1_l_texture.html">LTexture</a> * bufferTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_louvre.html#a7e8aeec7b6541935dfc6f608cd5170ce">UInt32</a>&#160;</td>
          <td class="paramname"><em>bufferIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access the texture of a specific buffer. </p>
<p>This method allows access to the texture associated with a particular buffer index.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bufferIndex</td><td>The index of the buffer for which the texture is to be accessed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the texture associated with the specified buffer index, or <code>nullptr</code> if texture access is not supported.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Some hardware/backends may not support accessing outputs textures, so you should always check if <code>nullptr</code> is returned. </dd></dl>

</div>
</div>
<a id="a62709874a2dddce91d7ad3d0b3a956cf" name="a62709874a2dddce91d7ad3d0b3a956cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62709874a2dddce91d7ad3d0b3a956cf">&#9670;&#160;</a></span>hasBufferDamageSupport()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool hasBufferDamageSupport </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the output supports buffer damage tracking. </p>
<p>Some graphic backends/hardware can benefit from knowing which regions of the framebuffer have changed within a <a class="el" href="class_louvre_1_1_l_output.html#a0569e991ee4c6e4242578aca6d999741" title="Paint Event.">paintGL()</a> event.</p>
<p>This method indicates whether buffer damage support is available.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_louvre_1_1_l_output.html#a7245d78b52786e2b77819860eab9a774" title="Specifies the damage generated during the last painGL() event.">setBufferDamage()</a> and <a class="el" href="class_louvre_1_1_l_output.html#ac3d1cef8d9c4b0ac00835c930f2eb298" title="Retrieves the damage region set by setBufferDamage().">bufferDamage()</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the graphical backend supports buffer damage tracking, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a7245d78b52786e2b77819860eab9a774" name="a7245d78b52786e2b77819860eab9a774"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7245d78b52786e2b77819860eab9a774">&#9670;&#160;</a></span>setBufferDamage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setBufferDamage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_louvre_1_1_l_region.html">LRegion</a> *&#160;</td>
          <td class="paramname"><em>damage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specifies the damage generated during the last painGL() event. </p>
<p>The <a class="el" href="class_louvre_1_1_l_output.html#ac3d1cef8d9c4b0ac00835c930f2eb298" title="Retrieves the damage region set by setBufferDamage().">bufferDamage()</a> is automatically reset just before the subsequent <a class="el" href="class_louvre_1_1_l_output.html#a0569e991ee4c6e4242578aca6d999741" title="Paint Event.">paintGL()</a> event.</p>
<dl class="section note"><dt>Note</dt><dd>Although calling this method is not mandatory, it can significantly enhance performance, especially on certain graphic backends/hardware or when the output scale is fractional and oversampling is enabled. If never invoked, the entire output is considered damaged.</dd></dl>
<p>When using <a class="el" href="class_louvre_1_1_l_scene.html" title="Scene.">LScene</a> for rendering, damage calculation is handled automatically with this method being called inside <a class="el" href="class_louvre_1_1_l_scene.html#a980646107c925c155e58646741a0fa8c" title="Handle the OpenGL painting for an LOutput.">LScene::handlePaintGL()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">damage</td><td>The damaged region of the output in compositor-global coordinates. Providing an empty region indicates no damage, while passing <code>nullptr</code> implies the entire output is damaged. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac3d1cef8d9c4b0ac00835c930f2eb298" name="ac3d1cef8d9c4b0ac00835c930f2eb298"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3d1cef8d9c4b0ac00835c930f2eb298">&#9670;&#160;</a></span>bufferDamage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_louvre_1_1_l_region.html">LRegion</a> &amp; bufferDamage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the damage region set by <a class="el" href="class_louvre_1_1_l_output.html#a7245d78b52786e2b77819860eab9a774" title="Specifies the damage generated during the last painGL() event.">setBufferDamage()</a>. </p>
<p>Before each <a class="el" href="class_louvre_1_1_l_output.html#a0569e991ee4c6e4242578aca6d999741" title="Paint Event.">paintGL()</a> event, the compositor automatically clears the damage region and marks the entire output as damaged by adding <a class="el" href="class_louvre_1_1_l_output.html#a315aa6ec38b7660b6e56b8591199172b" title="Gets the output rect.">rect()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>The damage region in compositor-global coordiantes. </dd></dl>

</div>
</div>
<a id="a026774ddbfcac05e0a2e0eb582b7807f" name="a026774ddbfcac05e0a2e0eb582b7807f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a026774ddbfcac05e0a2e0eb582b7807f">&#9670;&#160;</a></span>subPixel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_louvre_1_1_l_output.html#acf3ae70a3f91b9f2d855904572dcbed8">LOutput::SubPixel</a> subPixel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the layout of RGB subpixels for a single pixel on a display. </p>
<p>The layout of subpixels can impact the display of elements like fonts. </p>

</div>
</div>
<a id="a84d4d0411fdd405e199074ec04484aaa" name="a84d4d0411fdd405e199074ec04484aaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84d4d0411fdd405e199074ec04484aaa">&#9670;&#160;</a></span>setCustomScanoutBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool setCustomScanoutBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_louvre_1_1_l_texture.html">LTexture</a> *&#160;</td>
          <td class="paramname"><em>texture</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets a custom scanout buffer for a single frame. </p>
<p>This method allows you to replace the screen framebuffer during a single frame with a custom one, such as a fullscreen surface, preventing rendering using OpenGL and thus reducing GPU consumption and latency.</p>
<dl class="section warning"><dt>Warning</dt><dd>This method must be called within a <a class="el" href="class_louvre_1_1_l_output.html#a0569e991ee4c6e4242578aca6d999741" title="Paint Event.">paintGL()</a> event and nowhere else.</dd></dl>
<p>The graphic backend will check if the format is supported and if the dimensions match the current output mode. If that's the case, <code>true</code> is returned, and the <a class="el" href="class_louvre_1_1_l_output.html#a452f0d25a1d7db419c67673d82d5f21b" title="Returns the index of the current buffer.">currentBuffer()</a> index is not updated after this frame. Also, no painting operations should be performed as they will simply not make it to the screen.</p>
<p>While a custom buffer is being displayed:</p><ul>
<li>No other content will be visible, so this method should not be called if there is any overlay content such as a notification, subsurfaces, etc.</li>
<li>The hardware cursor plane can still be displayed, but if it is disabled or unsupported, calling this method should be avoided.</li>
<li>All screenshot requests will be forced to be cancelled.</li>
</ul>
<p>The custom buffer is displayed during a single frame. To display it again, this method should be called in subsequent frames.</p>
<p>If not set during a frame, or <code>nullptr</code> is passed as texture, the internal output framebuffers are restored, the <a class="el" href="class_louvre_1_1_l_output.html#a452f0d25a1d7db419c67673d82d5f21b" title="Returns the index of the current buffer.">currentBuffer()</a> index continues to update as usual and <a class="el" href="class_louvre_1_1_l_output.html#a3517e43b1493922e7d73304c72f01c71" title="Indicates that the entire output needs repainting.">needsFullRepaint()</a> is set to <code>true</code> for one frame.</p>
<dl class="section note"><dt>Note</dt><dd>When setting buffers belonging to surfaces, <a class="el" href="namespace_louvre.html" title="Namespaces.">Louvre</a> automatically ensures they aren't updated while being displayed, which would cause undesired artifacts to be displayed. When setting your own buffers, you must take care to not update their content while being displayed. Destroying a buffer while it is being displayed is safe, the graphic backend ensures it remains alive until it is no longer in use.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td>The texture to scan or <code>nullptr</code> to restore the internal output framebuffers. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the buffer is going to be displayed, <code>false</code> if the internal output framebuffers will be displayed. </dd></dl>

</div>
</div>
<a id="ab37de15dd67cb6861eface25a2c1498b" name="ab37de15dd67cb6861eface25a2c1498b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab37de15dd67cb6861eface25a2c1498b">&#9670;&#160;</a></span>hasVSyncControlSupport()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool hasVSyncControlSupport </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if VSync control is supported for this output. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_louvre_1_1_l_output.html#aad3bf6e06d340d3dc8d267e4e654afeb" title="Turns VSync on or off.">enableVSync()</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if VSync control is supported, <code>false</code> if VSync is always enabled. </dd></dl>

</div>
</div>
<a id="a5337526b6523038cffcb6583afa756a5" name="a5337526b6523038cffcb6583afa756a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5337526b6523038cffcb6583afa756a5">&#9670;&#160;</a></span>vSyncEnabled()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vSyncEnabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if VSync is enabled (enabled by default). </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_louvre_1_1_l_output.html#aad3bf6e06d340d3dc8d267e4e654afeb" title="Turns VSync on or off.">enableVSync()</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if VSync is enabled, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="aad3bf6e06d340d3dc8d267e4e654afeb" name="aad3bf6e06d340d3dc8d267e4e654afeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad3bf6e06d340d3dc8d267e4e654afeb">&#9670;&#160;</a></span>enableVSync()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool enableVSync </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Turns VSync on or off. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enabled</td><td><code>true</code> to enable VSync, <code>false</code> to disable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if VSync was successfully enabled or disabled, <code>false</code> if VSync control is not supported (see <a class="el" href="class_louvre_1_1_l_output.html#ab37de15dd67cb6861eface25a2c1498b" title="Checks if VSync control is supported for this output.">hasVSyncControlSupport()</a>). </dd></dl>

</div>
</div>
<a id="aa5fb5100cd757d182fc0fed19650aef2" name="aa5fb5100cd757d182fc0fed19650aef2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5fb5100cd757d182fc0fed19650aef2">&#9670;&#160;</a></span>refreshRateLimit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_louvre.html#a20b0c262d9ef5d263888e463dfa99638">Int32</a> refreshRateLimit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the refresh rate limit in Hz when VSync is disabled. </p>
<p>A value less than 0 indicates the limit is disabled.<br  />
A value equal to 0 indicates the limit is double the current output mode refresh rate (the default).<br  />
Any other positive value represents the limit in Hz.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_louvre_1_1_l_output.html#af1564c3c6d1b77f089702e01ec4502d9" title="Sets the refresh rate limit in Hz when VSync is disabled.">setRefreshRateLimit()</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The refresh rate limit when VSync is disabled. </dd></dl>

</div>
</div>
<a id="af1564c3c6d1b77f089702e01ec4502d9" name="af1564c3c6d1b77f089702e01ec4502d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1564c3c6d1b77f089702e01ec4502d9">&#9670;&#160;</a></span>setRefreshRateLimit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setRefreshRateLimit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_louvre.html#a20b0c262d9ef5d263888e463dfa99638">Int32</a>&#160;</td>
          <td class="paramname"><em>hz</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the refresh rate limit in Hz when VSync is disabled. </p>
<p>A value less than 0 indicates the limit is disabled.<br  />
A value equal to 0 indicates the limit is double the current output mode refresh rate (the default).<br  />
Any other positive value represents the limit in Hz.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hz</td><td>The refresh rate limit in Hz when VSync is disabled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a16a1856622b2e0e1d4f3f81961de6e0c" name="a16a1856622b2e0e1d4f3f81961de6e0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16a1856622b2e0e1d4f3f81961de6e0c">&#9670;&#160;</a></span>gammaSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_louvre.html#a7e8aeec7b6541935dfc6f608cd5170ce">UInt32</a> gammaSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the size of the gamma table. </p>
<dl class="section note"><dt>Note</dt><dd>This method can only be called while the output is initialized. If called when not initialized, it returns 0. If the output doesn't support gamma correction, this method also returns 0.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The size of the gamma correction table.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_louvre_1_1_l_output.html#a245e2751c991363d19e29fc3e22e1989" title="Sets the gamma correction table for the output.">setGamma()</a> and <a class="el" href="class_louvre_1_1_l_output.html#a386f3d06f6c9f2d60e66c6da5bf3dd1a" title="Set gamma table request.">setGammaRequest()</a> </dd>
<dd>
<a class="el" href="class_louvre_1_1_l_gamma_table.html" title="Gamma correction table for outputs.">LGammaTable</a> </dd></dl>

</div>
</div>
<a id="a245e2751c991363d19e29fc3e22e1989" name="a245e2751c991363d19e29fc3e22e1989"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a245e2751c991363d19e29fc3e22e1989">&#9670;&#160;</a></span>setGamma()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool setGamma </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_louvre_1_1_l_gamma_table.html">LGammaTable</a> *&#160;</td>
          <td class="paramname"><em>gamma</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the gamma correction table for the output. </p>
<p>This method allows to set the gamma correction table for the output.</p>
<dl class="section note"><dt>Note</dt><dd>This method can only be called while the output is initialized. <a class="el" href="namespace_louvre.html" title="Namespaces.">Louvre</a> automatically sets a linear gamma table when the output is initialized.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gamma</td><td>A pointer to the <a class="el" href="class_louvre_1_1_l_gamma_table.html" title="Gamma correction table for outputs.">LGammaTable</a> with a size matching <a class="el" href="class_louvre_1_1_l_output.html#a16a1856622b2e0e1d4f3f81961de6e0c" title="Gets the size of the gamma table.">gammaSize()</a>. Passing <code>nullptr</code> restores the default table (linear).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the gamma correction table was successfully set, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="adb161afb5f8aa93896dead7d42ef5ab4" name="adb161afb5f8aa93896dead7d42ef5ab4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb161afb5f8aa93896dead7d42ef5ab4">&#9670;&#160;</a></span>modes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="class_louvre_1_1_l_output_mode.html">LOutputMode</a> * &gt; &amp; modes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Available modes. </p>
<p>This method returns a vector containing all the available output modes for the <a class="el" href="class_louvre_1_1_l_output.html" title="A display rendering interface.">LOutput</a> instance.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_louvre_1_1_l_output.html#a376a36620b1acd2a0d154f8993bacdb4" title="Sets the output mode.">setMode()</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of pointers to <a class="el" href="class_louvre_1_1_l_output_mode.html" title="Output resolution and refresh rate.">LOutputMode</a> instances representing the available modes of the output. </dd></dl>

</div>
</div>
<a id="a387f10410e3367f22eb35e6595991811" name="a387f10410e3367f22eb35e6595991811"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a387f10410e3367f22eb35e6595991811">&#9670;&#160;</a></span>preferredMode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_louvre_1_1_l_output_mode.html">LOutputMode</a> * preferredMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the preferred mode. </p>
<p>This method returns the preferred mode for the output. It is generally the mode with the highest refresh rate and resolution.</p>
<p>Set by default. See <a class="el" href="class_louvre_1_1_l_output.html#a376a36620b1acd2a0d154f8993bacdb4" title="Sets the output mode.">setMode()</a>. </p>

</div>
</div>
<a id="aee653f4eaf5e9fb3f85b48d72500185a" name="aee653f4eaf5e9fb3f85b48d72500185a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee653f4eaf5e9fb3f85b48d72500185a">&#9670;&#160;</a></span>currentMode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_louvre_1_1_l_output_mode.html">LOutputMode</a> * currentMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the current mode. </p>
<p>This method returns the current output mode set with <a class="el" href="class_louvre_1_1_l_output.html#a376a36620b1acd2a0d154f8993bacdb4" title="Sets the output mode.">setMode()</a>. </p>

</div>
</div>
<a id="a376a36620b1acd2a0d154f8993bacdb4" name="a376a36620b1acd2a0d154f8993bacdb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a376a36620b1acd2a0d154f8993bacdb4">&#9670;&#160;</a></span>setMode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setMode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_louvre_1_1_l_output_mode.html">LOutputMode</a> *&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the output mode. </p>
<p>Use this method to assign a mode to the output, which must be one of the available modes listed in <a class="el" href="class_louvre_1_1_l_output.html#adb161afb5f8aa93896dead7d42ef5ab4" title="Available modes.">modes()</a>.<br  />
If the mode changes and the output is already initialized the <a class="el" href="class_louvre_1_1_l_output.html#ad4dc5e1f724869e9523ce872afd56a1a" title="Resize Event.">resizeGL()</a> event is triggered.</p>
<dl class="section note"><dt>Note</dt><dd>Calling this method from any of the <code>GL</code> events is not allowed, as it could potentially lead to a deadlock. In such cases, the method is simply ignored to prevent issues. </dd></dl>

</div>
</div>
<a id="af950653f0fe07aed8acca7079047fb94" name="af950653f0fe07aed8acca7079047fb94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af950653f0fe07aed8acca7079047fb94">&#9670;&#160;</a></span>setScale()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setScale </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_louvre.html#a87d38f886e617ced2698fc55afa07637">Float32</a>&#160;</td>
          <td class="paramname"><em>scale</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the output scale factor. </p>
<p>Use this method to adjust the scale factor of the output. By default, outputs have a scale factor of 1.<br  />
Increasing the scale factor, such as setting it to 2, is often suitable for high-definition displays (when <a class="el" href="class_louvre_1_1_l_output.html#acd98aecc4539ea542619bcb98cf72c2d" title="Gets the dots per inch (DPI) of the output.">dpi()</a> &gt;= 200). It's common for clients to adapt their surface scales to match the scale of the output where they are displayed.<br  />
If the scale changes and the output is already initialized, the <a class="el" href="class_louvre_1_1_l_output.html#ad4dc5e1f724869e9523ce872afd56a1a" title="Resize Event.">resizeGL()</a> event will be triggered.</p>
<dl class="section note"><dt>Note</dt><dd>Starting from <a class="el" href="namespace_louvre.html" title="Namespaces.">Louvre</a> version 1.2, fractional scales are now supported, see the <a class="el" href="class_louvre_1_1_l_output.html#Scaling">Scaling Section</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scale</td><td>The desired scale factor to set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>See an example of its use in the default implementation of <a class="el" href="class_louvre_1_1_l_compositor.html#a7916bd2f47b5b148cdb52d0f7c7803a3" title="Notifies a successful compositor initialization.">LCompositor::initialized()</a>. </dd></dl>

</div>
</div>
<a id="a788d4e63bfe520c6db3ef3d9ccde0ec4" name="a788d4e63bfe520c6db3ef3d9ccde0ec4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a788d4e63bfe520c6db3ef3d9ccde0ec4">&#9670;&#160;</a></span>scale()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_louvre.html#a87d38f886e617ced2698fc55afa07637">Float32</a> scale </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the current output scale factor. </p>
<p>This method returns the current scale factor assigned to the output using <a class="el" href="class_louvre_1_1_l_output.html#af950653f0fe07aed8acca7079047fb94" title="Sets the output scale factor.">setScale()</a>. The default scale factor is 1.</p>
<p>If the assigned scale is fractional this value is equal to ceil(scale).</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_louvre_1_1_l_output.html#a797d68da2b76224146872b3e4cb2c2db" title="Gets the same scale set with setScale().">fractionalScale()</a> </dd></dl>

</div>
</div>
<a id="a797d68da2b76224146872b3e4cb2c2db" name="a797d68da2b76224146872b3e4cb2c2db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a797d68da2b76224146872b3e4cb2c2db">&#9670;&#160;</a></span>fractionalScale()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_louvre.html#a87d38f886e617ced2698fc55afa07637">Float32</a> fractionalScale </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the same scale set with <a class="el" href="class_louvre_1_1_l_output.html#af950653f0fe07aed8acca7079047fb94" title="Sets the output scale factor.">setScale()</a>. </p>
<p>Set to 1.f by default.</p>
<dl class="section return"><dt>Returns</dt><dd>The fractional scale value. </dd></dl>

</div>
</div>
<a id="af354d97907e6bc371b9534f45edd4f75" name="af354d97907e6bc371b9534f45edd4f75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af354d97907e6bc371b9534f45edd4f75">&#9670;&#160;</a></span>usingFractionalScale()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool usingFractionalScale </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the scale factor set with <a class="el" href="class_louvre_1_1_l_output.html#af950653f0fe07aed8acca7079047fb94" title="Sets the output scale factor.">setScale()</a> is fractional. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the scale factor is fractional, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a0b19b68cd7414ad718b8cbb117e24da5" name="a0b19b68cd7414ad718b8cbb117e24da5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b19b68cd7414ad718b8cbb117e24da5">&#9670;&#160;</a></span>fractionalOversamplingEnabled()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool fractionalOversamplingEnabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if oversampling is enabled. </p>
<p>Oversampling is enabled by default when a fractional scale is set using <a class="el" href="class_louvre_1_1_l_output.html#af950653f0fe07aed8acca7079047fb94" title="Sets the output scale factor.">setScale()</a>.<br  />
It is always disabled when using an integer scale. You can disable oversampling using <a class="el" href="class_louvre_1_1_l_output.html#a9b261f037b65f4e6f20a28c179cdd179" title="Toggles oversampling for fractional scales.">enableFractionalOversampling()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if oversampling is enabled, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a9b261f037b65f4e6f20a28c179cdd179" name="a9b261f037b65f4e6f20a28c179cdd179"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b261f037b65f4e6f20a28c179cdd179">&#9670;&#160;</a></span>enableFractionalOversampling()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void enableFractionalOversampling </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Toggles oversampling for fractional scales. </p>
<dl class="section note"><dt>Note</dt><dd>Oversampling is always turned off for integer scales. You can instantly turn oversampling on or off when using a fractional scale.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enabled</td><td><code>true</code> to enable oversampling for fractional scales, <code>false</code> to disable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3640e75ecf0af51755b05a1e1262b25c" name="a3640e75ecf0af51755b05a1e1262b25c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3640e75ecf0af51755b05a1e1262b25c">&#9670;&#160;</a></span>repaint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void repaint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unlocks the rendering thread. </p>
<p>Calling this method unlocks the output rendering thread, triggering a subsequent <a class="el" href="class_louvre_1_1_l_output.html#a0569e991ee4c6e4242578aca6d999741" title="Paint Event.">paintGL()</a> event.<br  />
Regardless of the number of <a class="el" href="class_louvre_1_1_l_output.html#a3640e75ecf0af51755b05a1e1262b25c" title="Unlocks the rendering thread.">repaint()</a> calls within the same frame, <a class="el" href="class_louvre_1_1_l_output.html#a0569e991ee4c6e4242578aca6d999741" title="Paint Event.">paintGL()</a> is invoked only once.<br  />
To unlock the rendering thread again, <a class="el" href="class_louvre_1_1_l_output.html#a3640e75ecf0af51755b05a1e1262b25c" title="Unlocks the rendering thread.">repaint()</a> must be called within or after a <a class="el" href="class_louvre_1_1_l_output.html#a0569e991ee4c6e4242578aca6d999741" title="Paint Event.">paintGL()</a> event.</p>
<dl class="section note"><dt>Note</dt><dd>This method is ignored if <a class="el" href="class_louvre_1_1_l_output.html#ab6969bb3bc86f834354210a6b4d7f666" title="Temporarily disables repaint calls for this output.">repaintFilter()</a> returns <code>false</code>. </dd></dl>

</div>
</div>
<a id="a3517e43b1493922e7d73304c72f01c71" name="a3517e43b1493922e7d73304c72f01c71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3517e43b1493922e7d73304c72f01c71">&#9670;&#160;</a></span>needsFullRepaint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool needsFullRepaint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates that the entire output needs repainting. </p>
<p>This hint from the graphic backend suggests that the entire output should be repainted, possibly because it doesn't support damage tracking or for other reasons.</p>
<dl class="section note"><dt>Note</dt><dd>This is automatically managed by <a class="el" href="class_louvre_1_1_l_scene.html" title="Scene.">LScene</a>. </dd></dl>

</div>
</div>
<a id="acd98aecc4539ea542619bcb98cf72c2d" name="acd98aecc4539ea542619bcb98cf72c2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd98aecc4539ea542619bcb98cf72c2d">&#9670;&#160;</a></span>dpi()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_louvre.html#a20b0c262d9ef5d263888e463dfa99638">Int32</a> dpi </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the dots per inch (DPI) of the output. </p>
<p>This method calculates and returns the dots per inch (DPI) of the output, considering its physical dimensions and the resolution provided by its current mode. </p>

</div>
</div>
<a id="a315aa6ec38b7660b6e56b8591199172b" name="a315aa6ec38b7660b6e56b8591199172b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a315aa6ec38b7660b6e56b8591199172b">&#9670;&#160;</a></span>rect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_louvre.html#ad83fc7af7b313dac8820e4d4bd5b4383">LRect</a> &amp; rect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the output rect. </p>
<p>This method provides the position and size of the output in compositor-global coordinates (<a class="el" href="class_louvre_1_1_l_output.html#a0843c1bb97b8a8cfb3faa6f75e68acd6" title="Gets the output position.">pos()</a>, <a class="el" href="class_louvre_1_1_l_output.html#af0e9483bc8188a275f4877e55ec720b0" title="Gets the output size in surface units.">size()</a>). </p>

</div>
</div>
<a id="a0843c1bb97b8a8cfb3faa6f75e68acd6" name="a0843c1bb97b8a8cfb3faa6f75e68acd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0843c1bb97b8a8cfb3faa6f75e68acd6">&#9670;&#160;</a></span>pos()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_louvre.html#a1111511396cab1b2607e4ac55e1883a3">LPoint</a> &amp; pos </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the output position. </p>
<p>This method retrieves the position of the output in compositor-global coordinates assigned with <a class="el" href="class_louvre_1_1_l_output.html#a6ab8c3ffe18601c1d3d355c385553a4c" title="Set the position of the output.">setPos()</a>.<br  />
It is equivalent to the position given by the <a class="el" href="class_louvre_1_1_l_output.html#a315aa6ec38b7660b6e56b8591199172b" title="Gets the output rect.">rect()</a>. </p>

</div>
</div>
<a id="a6ab8c3ffe18601c1d3d355c385553a4c" name="a6ab8c3ffe18601c1d3d355c385553a4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ab8c3ffe18601c1d3d355c385553a4c">&#9670;&#160;</a></span>setPos()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setPos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_louvre.html#a1111511396cab1b2607e4ac55e1883a3">LPoint</a> &amp;&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the position of the output. </p>
<p>This method allows you to assign the position of the output in compositor-global coordinates, with the upper-left corner as the origin.<br  />
If the position changes while the output is initialized, the <a class="el" href="class_louvre_1_1_l_output.html#aa15f67e7da7f9351890b2c6258ee9225" title="Move Event.">moveGL()</a> event is triggered.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The new position of the output in compositor-global coordinates. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af0e9483bc8188a275f4877e55ec720b0" name="af0e9483bc8188a275f4877e55ec720b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0e9483bc8188a275f4877e55ec720b0">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_louvre.html#a4df5473974ae0f28f3a4967f296a657b">LSize</a> &amp; size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the output size in surface units. </p>
<p>This method provides the size of the output in surface units, based on its current mode and scale factor.<br  />
It is equivalent to the size given by the <a class="el" href="class_louvre_1_1_l_output.html#a315aa6ec38b7660b6e56b8591199172b" title="Gets the output rect.">rect()</a>. </p>

</div>
</div>
<a id="a9595879ae0c4def717bd69d345001ed0" name="a9595879ae0c4def717bd69d345001ed0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9595879ae0c4def717bd69d345001ed0">&#9670;&#160;</a></span>sizeB()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_louvre.html#a4df5473974ae0f28f3a4967f296a657b">LSize</a> &amp; sizeB </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the output size in buffer units. </p>
<p>This method returns the size of the output in buffer units, based on its current mode. </p>

</div>
</div>
<a id="aa4814da0c84dfa9eae2ec64f331fe45c" name="aa4814da0c84dfa9eae2ec64f331fe45c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4814da0c84dfa9eae2ec64f331fe45c">&#9670;&#160;</a></span>realBufferSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_louvre.html#a4df5473974ae0f28f3a4967f296a657b">LSize</a> &amp; realBufferSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the real destination buffer size. </p>
<p>This method returns the size in pixels of the destination framebuffer during a <a class="el" href="class_louvre_1_1_l_output.html#a0569e991ee4c6e4242578aca6d999741" title="Paint Event.">paintGL()</a> event.<br  />
Unlike <a class="el" href="class_louvre_1_1_l_output.html#a9595879ae0c4def717bd69d345001ed0" title="Gets the output size in buffer units.">sizeB()</a>, the width and height are not swapped if <a class="el" href="class_louvre_1_1_l_output.html#ae53642e01710db05adae9dab67917fa7" title="Gets the framebuffer transform.">transform()</a> includes a 90 rotation.<br  />
Additionally, when using oversampling and a fractional scale, it returns the actual size of the intermediary "oversampled" framebuffer, rather than the "fake" buffer size provided by <a class="el" href="class_louvre_1_1_l_output.html#a9595879ae0c4def717bd69d345001ed0" title="Gets the output size in buffer units.">sizeB()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This method is only useful if you are not using <a class="el" href="class_louvre_1_1_l_painter.html" title="Basic 2D rendering utility.">LPainter</a> or <a class="el" href="class_louvre_1_1_l_scene.html" title="Scene.">LScene</a> for rendering. </dd></dl>

</div>
</div>
<a id="ac9e3d8123250a7f1c045bba0dd122dca" name="ac9e3d8123250a7f1c045bba0dd122dca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9e3d8123250a7f1c045bba0dd122dca">&#9670;&#160;</a></span>physicalSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_louvre.html#a4df5473974ae0f28f3a4967f296a657b">LSize</a> &amp; physicalSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the physical dimensions of the output. </p>
<p>This method retrieves the physical dimensions of the output in millimeters.</p>
<dl class="section note"><dt>Note</dt><dd>In some cases, such as when the compositor is running inside a virtual machine, the physical size may be (0,0). </dd></dl>

</div>
</div>
<a id="a4b3ad023be45221c4791814e75bae035" name="a4b3ad023be45221c4791814e75bae035"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b3ad023be45221c4791814e75bae035">&#9670;&#160;</a></span>screenshotRequests()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="class_louvre_1_1_l_screenshot_request.html">LScreenshotRequest</a> * &gt; &amp; screenshotRequests </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Screen capture requests. </p>
<p>This vector contains all <a class="el" href="class_louvre_1_1_l_screenshot_request.html" title="Request to capture an LOutput frame.">LScreenshotRequest</a> s that should be handled during a <a class="el" href="class_louvre_1_1_l_output.html#a0569e991ee4c6e4242578aca6d999741" title="Paint Event.">paintGL()</a> event. </p>

</div>
</div>
<a id="a77d688c4b02da52e5f2fc20f85024d6b" name="a77d688c4b02da52e5f2fc20f85024d6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77d688c4b02da52e5f2fc20f85024d6b">&#9670;&#160;</a></span>contentType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_louvre.html#a7de5cf1aefc1d4c90dbe7dc0727654ba">LContentType</a> contentType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The content type hint set with <a class="el" href="class_louvre_1_1_l_output.html#af0c36b2fb823c8128b04f77ae9c488a5" title="Sets the content type hint.">setContentType()</a>. </p>

</div>
</div>
<a id="af0c36b2fb823c8128b04f77ae9c488a5" name="af0c36b2fb823c8128b04f77ae9c488a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0c36b2fb823c8128b04f77ae9c488a5">&#9670;&#160;</a></span>setContentType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setContentType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_louvre.html#a7de5cf1aefc1d4c90dbe7dc0727654ba">LContentType</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the content type hint. </p>
<p>This hint is used by some hardware displays to properly adapt to the type of content being displayed.<br  />
For example, if the <a class="el" href="namespace_louvre.html#a7de5cf1aefc1d4c90dbe7dc0727654baa5062e1374b770808c21b3846dd31498c">LContentTypeGame</a> flag is set, a TV connected through an HDMI port may adapt to reduce latency.</p>
<p>The default value is <a class="el" href="namespace_louvre.html#a7de5cf1aefc1d4c90dbe7dc0727654baa9b954e76f820119b19d48566706f709e">LContentTypeNone</a>.</p>
<p>Clients using the Content Type Hint protocol can also specify the type of content a given <a class="el" href="class_louvre_1_1_l_surface.html" title="A client &quot;window&quot;.">LSurface</a> is displaying.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_louvre_1_1_l_surface.html#a77d688c4b02da52e5f2fc20f85024d6b" title="Returns the content type that the surface represents.">LSurface::contentType()</a> and <a class="el" href="class_louvre_1_1_l_surface.html#adc79b942fea173935ef3bff4de7406f1" title="Notifies a change of content type.">LSurface::contentTypeChanged()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The content type hint to be set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5ec1b13e7e27217080250c93e0139725" name="a5ec1b13e7e27217080250c93e0139725"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ec1b13e7e27217080250c93e0139725">&#9670;&#160;</a></span>isNonDesktop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool isNonDesktop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the output is intended for non-desktop usage. </p>
<p>Outputs like VR headsets set this property to <code>true</code> to indicate they are not meant for desktop use.</p>
<p>Such outputs are typically intended to be leased by clients and not used by the compositor.</p>
<p>The default implementation of <a class="el" href="class_louvre_1_1_l_compositor.html#a7916bd2f47b5b148cdb52d0f7c7803a3" title="Notifies a successful compositor initialization.">LCompositor::initialized()</a> marks outputs with this property as leasable. See <a class="el" href="class_louvre_1_1_l_output.html#ad7f3f3691fe3e30d5a56299f3c6c74cf" title="Advertises the output as leasable.">setLeasable()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the output is not meant for desktop usage, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ad7f3f3691fe3e30d5a56299f3c6c74cf" name="ad7f3f3691fe3e30d5a56299f3c6c74cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7f3f3691fe3e30d5a56299f3c6c74cf">&#9670;&#160;</a></span>setLeasable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setLeasable </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>leasable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Advertises the output as leasable. </p>
<p>When set to <code>true</code>, clients using the DRM Lease protocol will be able to trigger <a class="el" href="class_louvre_1_1_l_output.html#a831a684290662b218b58ae77d82299f3" title="Handles client requests to lease the output.">leaseRequest()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>Setting it to <code>false</code> will automatically revoke any existing lease. </dd></dl>

</div>
</div>
<a id="a8aa371d15583bb4f1cb3d507b27aa559" name="a8aa371d15583bb4f1cb3d507b27aa559"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8aa371d15583bb4f1cb3d507b27aa559">&#9670;&#160;</a></span>leasable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool leasable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the output is advertised as leasable. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_louvre_1_1_l_output.html#ad7f3f3691fe3e30d5a56299f3c6c74cf" title="Advertises the output as leasable.">setLeasable()</a> and <a class="el" href="class_louvre_1_1_l_output.html#aa5fd996431679f9db64a6a859eab7743" title="Notifies a change in the lease() property.">leaseChanged()</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if leasable, <code>false</code> otherwise. <code>false</code> by default. </dd></dl>

</div>
</div>
<a id="a5b404ffeeead230796583114274bec55" name="a5b404ffeeead230796583114274bec55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b404ffeeead230796583114274bec55">&#9670;&#160;</a></span>lease()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DRMLease::RDRMLease * lease </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Current lease created after an accepted <a class="el" href="class_louvre_1_1_l_output.html#a831a684290662b218b58ae77d82299f3" title="Handles client requests to lease the output.">leaseRequest()</a>. </p>
<p><code>#include &lt;protocols/DRMLease/RDRMLease.h&gt;</code></p>
<p>Use this property to determine which client is leasing the output via <code><a class="el" href="class_louvre_1_1_l_output.html#a5b404ffeeead230796583114274bec55" title="Current lease created after an accepted leaseRequest().">lease()</a>-&gt;client()</code> or to revoke it with <code><a class="el" href="class_louvre_1_1_l_output.html#a5b404ffeeead230796583114274bec55" title="Current lease created after an accepted leaseRequest().">lease()</a>-&gt;finished()</code>.</p>
<p>Once revoked, this property is set to <code>nullptr</code>.</p>
<dl class="section return"><dt>Returns</dt><dd><code>nullptr</code> if the output is not being leased. </dd></dl>

</div>
</div>
<a id="a33256784969e3347f423f72af1727cbd" name="a33256784969e3347f423f72af1727cbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33256784969e3347f423f72af1727cbd">&#9670;&#160;</a></span>name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the output name. </p>
<p>This method retrieves the name of the output provided by the graphic backend, such as "HDMI-A-2."</p>
<dl class="section note"><dt>Note</dt><dd>Output names are always unique, even if they belong to different GPUs. </dd></dl>

</div>
</div>
<a id="afba2707e89f2a153d45e4e2b7b699350" name="afba2707e89f2a153d45e4e2b7b699350"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afba2707e89f2a153d45e4e2b7b699350">&#9670;&#160;</a></span>model()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * model </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the output model name. </p>
<p>This method retrieves the model name of the output provided by the graphic backend. </p>

</div>
</div>
<a id="a01f2188ab35ed527ca6ffb254137b502" name="a01f2188ab35ed527ca6ffb254137b502"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01f2188ab35ed527ca6ffb254137b502">&#9670;&#160;</a></span>manufacturer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * manufacturer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the manufacturer name of the output. </p>
<p>This method retrieves the manufacturer name of the output provided by the graphic backend. </p>

</div>
</div>
<a id="afd0f3730b5508e643c916f6e81156df2" name="afd0f3730b5508e643c916f6e81156df2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd0f3730b5508e643c916f6e81156df2">&#9670;&#160;</a></span>description()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * description </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the description of the output. </p>
<p>This method retrieves the description of the output provided by the graphic backend. </p>

</div>
</div>
<a id="a90c193864e7f5f74d76e5f8f2fa6f852" name="a90c193864e7f5f74d76e5f8f2fa6f852"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90c193864e7f5f74d76e5f8f2fa6f852">&#9670;&#160;</a></span>serialNumber()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * serialNumber </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the serial number of the output. </p>
<p>The serial number can be used to uniquely identify an output even after reboots.</p>
<dl class="section return"><dt>Returns</dt><dd><code>nullptr</code> if the backend doesn't provide it. </dd></dl>

</div>
</div>
<a id="afa63ba85230130f89461fb64e2da375e" name="afa63ba85230130f89461fb64e2da375e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa63ba85230130f89461fb64e2da375e">&#9670;&#160;</a></span>threadId()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::thread::id &amp; threadId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the ID of the rendering thread. </p>
<p>This method retrieves the ID of the output rendering thread. </p>

</div>
</div>
<a id="a2aeeb1c8e8bb0f723ebb7129df23d4e8" name="a2aeeb1c8e8bb0f723ebb7129df23d4e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2aeeb1c8e8bb0f723ebb7129df23d4e8">&#9670;&#160;</a></span>initializeGL()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void initializeGL </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize Event. </p>
<p>The <a class="el" href="class_louvre_1_1_l_output.html#a2aeeb1c8e8bb0f723ebb7129df23d4e8" title="Initialize Event.">initializeGL()</a> event is invoked after the output is properly initialized.<br  />
 </p><dl class="section note"><dt>Note</dt><dd>Avoid performing painting operations here, as they won't be visible on the screen. See the <a class="el" href="class_louvre_1_1_l_output.html#a0569e991ee4c6e4242578aca6d999741" title="Paint Event.">paintGL()</a> event.</dd></dl>
<h4><a class="anchor" id="default-implementation-11"></a>
Default Implementation</h4>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="class_louvre_1_1_l_output.html#a2aeeb1c8e8bb0f723ebb7129df23d4e8">LOutput::initializeGL</a>()</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_function" href="class_louvre_1_1_l_output.html#a50b3bf074aafac5129b43cca80e0db38">painter</a>()-&gt;<a class="code hl_function" href="class_louvre_1_1_l_painter.html#a11d841661afaa10a037ecb62bccb1598">setClearColor</a>(1.f, 1.f, 1.f, 1.f);</div>
<div class="line">}</div>
<div class="ttc" id="aclass_louvre_1_1_l_output_html_a2aeeb1c8e8bb0f723ebb7129df23d4e8"><div class="ttname"><a href="class_louvre_1_1_l_output.html#a2aeeb1c8e8bb0f723ebb7129df23d4e8">Louvre::LOutput::initializeGL</a></div><div class="ttdeci">virtual void initializeGL()</div><div class="ttdoc">Initialize Event.</div></div>
<div class="ttc" id="aclass_louvre_1_1_l_output_html_a50b3bf074aafac5129b43cca80e0db38"><div class="ttname"><a href="class_louvre_1_1_l_output.html#a50b3bf074aafac5129b43cca80e0db38">Louvre::LOutput::painter</a></div><div class="ttdeci">LPainter * painter() const noexcept</div><div class="ttdoc">Gets access to the associated LPainter.</div><div class="ttdef"><b>Definition</b> LOutput.cpp:515</div></div>
<div class="ttc" id="aclass_louvre_1_1_l_painter_html_a11d841661afaa10a037ecb62bccb1598"><div class="ttname"><a href="class_louvre_1_1_l_painter.html#a11d841661afaa10a037ecb62bccb1598">Louvre::LPainter::setClearColor</a></div><div class="ttdeci">void setClearColor(Float32 r, Float32 g, Float32 b, Float32 a) noexcept</div><div class="ttdoc">Sets the clear color.</div><div class="ttdef"><b>Definition</b> LPainter.cpp:811</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a0569e991ee4c6e4242578aca6d999741" name="a0569e991ee4c6e4242578aca6d999741"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0569e991ee4c6e4242578aca6d999741">&#9670;&#160;</a></span>paintGL()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void paintGL </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Paint Event. </p>
<p>The <a class="el" href="class_louvre_1_1_l_output.html#a0569e991ee4c6e4242578aca6d999741" title="Paint Event.">paintGL()</a> event is invoked after unlocking the rendering thread with <a class="el" href="class_louvre_1_1_l_output.html#a3640e75ecf0af51755b05a1e1262b25c" title="Unlocks the rendering thread.">repaint()</a>.<br  />
All rendering operations performed here will be displayed later on screen after the backend performs a page flip.</p>
<h4><a class="anchor" id="default-implementation-12"></a>
Default Implementation</h4>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="class_louvre_1_1_l_output.html#a0569e991ee4c6e4242578aca6d999741">LOutput::paintGL</a>()</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">bool</span> sessionLocked { <a class="code hl_function" href="namespace_louvre.html#aae2b1cd84497a1980827ff545147c58c">sessionLockManager</a>()-&gt;<a class="code hl_function" href="class_louvre_1_1_l_session_lock_manager.html#a1830cc3b524929125683b32dbadd16ff">state</a>() != <a class="code hl_enumvalue" href="class_louvre_1_1_l_session_lock_manager.html#a5d74787dedbc4e11c1ab15bf487e61f8a7a581195d038372012532c1e5c284f29">LSessionLockManager::Unlocked</a> };</div>
<div class="line">    <span class="keyword">const</span> <a class="code hl_class" href="class_louvre_1_1_l_rect_template.html">LRect</a> availGeo { <a class="code hl_function" href="class_louvre_1_1_l_output.html#a0843c1bb97b8a8cfb3faa6f75e68acd6">pos</a>() + <a class="code hl_function" href="class_louvre_1_1_l_output.html#a33473d432755f05c5eda568b383000ff">availableGeometry</a>().<a class="code hl_function" href="class_louvre_1_1_l_rect_template.html#a2a2dc2fd45980947abd9dc2f80a7b7bf">pos</a>(), <a class="code hl_function" href="class_louvre_1_1_l_output.html#a33473d432755f05c5eda568b383000ff">availableGeometry</a>().<a class="code hl_function" href="class_louvre_1_1_l_rect_template.html#af6951b309861d44f0657e149461f6915">size</a>() };</div>
<div class="line">    LPainter::TextureParams params;</div>
<div class="line">    <a class="code hl_typedef" href="namespace_louvre.html#ad83fc7af7b313dac8820e4d4bd5b4383">LRect</a> currentRect;</div>
<div class="line">    LPainter *p { <a class="code hl_function" href="class_louvre_1_1_l_output.html#a50b3bf074aafac5129b43cca80e0db38">painter</a>() };</div>
<div class="line">    p-&gt;<a class="code hl_function" href="class_louvre_1_1_l_painter.html#a16454a37fc0a0427085de2800c218cf4">clearScreen</a>();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (<a class="code hl_function" href="namespace_louvre.html#acee23df69aa55d791385fb9813b0319a">seat</a>()-&gt;dnd()-&gt;icon())</div>
<div class="line">        <a class="code hl_function" href="namespace_louvre.html#acee23df69aa55d791385fb9813b0319a">seat</a>()-&gt;<a class="code hl_function" href="class_louvre_1_1_l_seat.html#abfb3294698b07c4a236e19046fbc2440">dnd</a>()-&gt;<a class="code hl_function" href="class_louvre_1_1_l_d_n_d.html#a8b46d9f82d039fa3fe51859197f7f91d">icon</a>()-&gt;<a class="code hl_function" href="class_louvre_1_1_l_base_surface_role.html#a1378b298f947230aaf75d2d87d6a9db6">surface</a>()-&gt;<a class="code hl_function" href="class_louvre_1_1_l_surface.html#ad9c27f2d106edb222bc33c4bfc384f58">raise</a>();</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">auto</span> surfaceShouldBeSkipped = [](<a class="code hl_enumvalue" href="class_louvre_1_1_l_factory_object.html#ad96f0a085c6542bc6c83459a88bfb560ada873b27e38118d47ddfb31d8569eb68">LSurface</a> *s, <a class="code hl_enumvalue" href="class_louvre_1_1_l_factory_object.html#ad96f0a085c6542bc6c83459a88bfb560a0718ddbd53ad0bada74c064c006da4d1">LOutput</a> *output, <span class="keywordtype">bool</span> sessionLocked) -&gt; <span class="keywordtype">bool</span></div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// An unmapped surface usually indicates it doesn&#39;t have a buffer</span></div>
<div class="line">        <span class="keywordflow">if</span> (!s-&gt;mapped())</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Should be displayed, for example, as a thumbnail in a panel instead</span></div>
<div class="line">        <span class="keywordflow">if</span> (s-&gt;minimized())</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Use LCursor instead for rendering the cursor</span></div>
<div class="line">        <span class="keywordflow">if</span> (s-&gt;cursorRole())</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">// But let the client update it</span></div>
<div class="line">            s-&gt;requestNextFrame();</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Layer or screen lock surfaces should be displayed only on their exclusive output or not at all</span></div>
<div class="line">        <span class="keywordflow">if</span> ((s-&gt;layerRole() &amp;&amp; s-&gt;layerRole()-&gt;exclusiveOutput() != output) ||</div>
<div class="line">            (s-&gt;sessionLock() &amp;&amp; s-&gt;sessionLock()-&gt;exclusiveOutput() != output))</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Other roles with a different exclusive output, e.g. maximized or fullscreen toplevels</span></div>
<div class="line">        <span class="keywordflow">if</span> (s-&gt;role() &amp;&amp; s-&gt;role()-&gt;exclusiveOutput() &amp;&amp; s-&gt;role()-&gt;exclusiveOutput() != output)</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// If the session is locked only surfaces from the locking client should be displayed</span></div>
<div class="line">        <span class="keywordflow">if</span> (sessionLocked &amp;&amp; s-&gt;client() != <a class="code hl_function" href="namespace_louvre.html#aae2b1cd84497a1980827ff545147c58c">sessionLockManager</a>()-&gt;<a class="code hl_function" href="class_louvre_1_1_l_session_lock_manager.html#a030bc63c24e4bb205344939c91b2ba26">client</a>())</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">auto</span> surfaceShouldBeClippedToAvailableGeometry = [](<a class="code hl_enumvalue" href="class_louvre_1_1_l_factory_object.html#ad96f0a085c6542bc6c83459a88bfb560ada873b27e38118d47ddfb31d8569eb68">LSurface</a> *s) -&gt; <span class="keywordtype">bool</span></div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Popups are usually constrained to the entire output rect instead</span></div>
<div class="line">        <span class="keywordflow">if</span> (s-&gt;popup())</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Fullscreen toplevels should not be clipped</span></div>
<div class="line">        <span class="keywordflow">if</span> (s-&gt;toplevel() &amp;&amp; !s-&gt;toplevel()-&gt;fullscreen())</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Toplevels or subsurfaces child of a non fullscreen toplevel</span></div>
<div class="line">        <span class="keywordflow">if</span> (s-&gt;subsurface() || s-&gt;toplevel())</div>
<div class="line">        {</div>
<div class="line">            <span class="keyword">const</span> <a class="code hl_enumvalue" href="class_louvre_1_1_l_factory_object.html#ad96f0a085c6542bc6c83459a88bfb560ada873b27e38118d47ddfb31d8569eb68">LSurface</a> *topmostParent { s-&gt;topmostParent() };</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">if</span> (topmostParent &amp;&amp; topmostParent-&gt;toplevel() &amp;&amp; !topmostParent-&gt;toplevel()-&gt;fullscreen())</div>
<div class="line">                <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Draw every surface</span></div>
<div class="line">    <span class="keywordflow">for</span> (<a class="code hl_enumvalue" href="class_louvre_1_1_l_factory_object.html#ad96f0a085c6542bc6c83459a88bfb560ada873b27e38118d47ddfb31d8569eb68">LSurface</a> *s : <a class="code hl_function" href="namespace_louvre.html#a62750620c88ee98b1c5286f1fc339c5b">compositor</a>()-&gt;surfaces())</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> (surfaceShouldBeSkipped(s, <span class="keyword">this</span>, sessionLocked))</div>
<div class="line">            <span class="keywordflow">continue</span>;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Current surface rect</span></div>
<div class="line">        currentRect.setPos(s-&gt;rolePos());</div>
<div class="line">        currentRect.setSize(s-&gt;size());</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Calc which outputs intersect the surface</span></div>
<div class="line">        <span class="keywordflow">for</span> (<a class="code hl_enumvalue" href="class_louvre_1_1_l_factory_object.html#ad96f0a085c6542bc6c83459a88bfb560a0718ddbd53ad0bada74c064c006da4d1">LOutput</a> *o : <a class="code hl_function" href="namespace_louvre.html#a62750620c88ee98b1c5286f1fc339c5b">compositor</a>()-&gt;outputs())</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">if</span> (o-&gt;rect().intersects(currentRect))</div>
<div class="line">                s-&gt;sendOutputEnterEvent(o);</div>
<div class="line">            <span class="keywordflow">else</span></div>
<div class="line">                s-&gt;sendOutputLeaveEvent(o);</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        params.srcRect = s-&gt;srcRect();</div>
<div class="line">        params.dstSize = s-&gt;size();</div>
<div class="line">        params.srcScale = s-&gt;bufferScale();</div>
<div class="line">        params.srcTransform = s-&gt;bufferTransform();</div>
<div class="line">        params.texture = s-&gt;texture();</div>
<div class="line">        params.pos = currentRect.pos();</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Bind the surface texture</span></div>
<div class="line">        p-&gt;bindTextureMode(params);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Clip to available geometry</span></div>
<div class="line">        <span class="keywordflow">if</span> (surfaceShouldBeClippedToAvailableGeometry(s))</div>
<div class="line">            <span class="comment">// If the intersected area is zero</span></div>
<div class="line">            <span class="keywordflow">if</span> (currentRect.clip(availGeo))</div>
<div class="line">                <span class="keywordflow">continue</span>;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Draw the surface</span></div>
<div class="line">        p-&gt;drawRect(currentRect);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Notify the client it can now render a new surface frame</span></div>
<div class="line">        s-&gt;requestNextFrame();</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="aclass_louvre_1_1_l_base_surface_role_html_a1378b298f947230aaf75d2d87d6a9db6"><div class="ttname"><a href="class_louvre_1_1_l_base_surface_role.html#a1378b298f947230aaf75d2d87d6a9db6">Louvre::LBaseSurfaceRole::surface</a></div><div class="ttdeci">LSurface * surface() const noexcept</div><div class="ttdoc">Returns the surface that has acquired the role provided in the constructor.</div><div class="ttdef"><b>Definition</b> LBaseSurfaceRole.h:121</div></div>
<div class="ttc" id="aclass_louvre_1_1_l_d_n_d_html_a8b46d9f82d039fa3fe51859197f7f91d"><div class="ttname"><a href="class_louvre_1_1_l_d_n_d.html#a8b46d9f82d039fa3fe51859197f7f91d">Louvre::LDND::icon</a></div><div class="ttdeci">LDNDIconRole * icon() const noexcept</div><div class="ttdoc">Drag &amp; drop session icon.</div><div class="ttdef"><b>Definition</b> LDND.cpp:118</div></div>
<div class="ttc" id="aclass_louvre_1_1_l_factory_object_html_ad96f0a085c6542bc6c83459a88bfb560a0718ddbd53ad0bada74c064c006da4d1"><div class="ttname"><a href="class_louvre_1_1_l_factory_object.html#ad96f0a085c6542bc6c83459a88bfb560a0718ddbd53ad0bada74c064c006da4d1">Louvre::LFactoryObject::Type::LOutput</a></div><div class="ttdeci">@ LOutput</div><div class="ttdoc">Represents the LOutput class.</div></div>
<div class="ttc" id="aclass_louvre_1_1_l_factory_object_html_ad96f0a085c6542bc6c83459a88bfb560ada873b27e38118d47ddfb31d8569eb68"><div class="ttname"><a href="class_louvre_1_1_l_factory_object.html#ad96f0a085c6542bc6c83459a88bfb560ada873b27e38118d47ddfb31d8569eb68">Louvre::LFactoryObject::Type::LSurface</a></div><div class="ttdeci">@ LSurface</div><div class="ttdoc">Represents the LSurface class.</div></div>
<div class="ttc" id="aclass_louvre_1_1_l_output_html_a0569e991ee4c6e4242578aca6d999741"><div class="ttname"><a href="class_louvre_1_1_l_output.html#a0569e991ee4c6e4242578aca6d999741">Louvre::LOutput::paintGL</a></div><div class="ttdeci">virtual void paintGL()</div><div class="ttdoc">Paint Event.</div></div>
<div class="ttc" id="aclass_louvre_1_1_l_output_html_a0843c1bb97b8a8cfb3faa6f75e68acd6"><div class="ttname"><a href="class_louvre_1_1_l_output.html#a0843c1bb97b8a8cfb3faa6f75e68acd6">Louvre::LOutput::pos</a></div><div class="ttdeci">const LPoint &amp; pos() const noexcept</div><div class="ttdoc">Gets the output position.</div><div class="ttdef"><b>Definition</b> LOutput.cpp:462</div></div>
<div class="ttc" id="aclass_louvre_1_1_l_output_html_a33473d432755f05c5eda568b383000ff"><div class="ttname"><a href="class_louvre_1_1_l_output.html#a33473d432755f05c5eda568b383000ff">Louvre::LOutput::availableGeometry</a></div><div class="ttdeci">const LRect &amp; availableGeometry() const noexcept</div><div class="ttdoc">Retrieves the rect within the output that is not occupied by exclusive zones.</div><div class="ttdef"><b>Definition</b> LOutput.cpp:66</div></div>
<div class="ttc" id="aclass_louvre_1_1_l_painter_html_a16454a37fc0a0427085de2800c218cf4"><div class="ttname"><a href="class_louvre_1_1_l_painter.html#a16454a37fc0a0427085de2800c218cf4">Louvre::LPainter::clearScreen</a></div><div class="ttdeci">void clearScreen() noexcept</div><div class="ttdoc">Clear the framebuffer.</div><div class="ttdef"><b>Definition</b> LPainter.cpp:839</div></div>
<div class="ttc" id="aclass_louvre_1_1_l_rect_template_html"><div class="ttname"><a href="class_louvre_1_1_l_rect_template.html">Louvre::LRectTemplate&lt; Int32 &gt;</a></div></div>
<div class="ttc" id="aclass_louvre_1_1_l_rect_template_html_a2a2dc2fd45980947abd9dc2f80a7b7bf"><div class="ttname"><a href="class_louvre_1_1_l_rect_template.html#a2a2dc2fd45980947abd9dc2f80a7b7bf">Louvre::LRectTemplate::pos</a></div><div class="ttdeci">constexpr const LPointTemplate&lt; T &gt; &amp; pos() const noexcept</div><div class="ttdoc">2D vector given by the (x,y) components of the rectangle</div><div class="ttdef"><b>Definition</b> LRect.h:128</div></div>
<div class="ttc" id="aclass_louvre_1_1_l_rect_template_html_af6951b309861d44f0657e149461f6915"><div class="ttname"><a href="class_louvre_1_1_l_rect_template.html#af6951b309861d44f0657e149461f6915">Louvre::LRectTemplate::size</a></div><div class="ttdeci">constexpr const LPointTemplate&lt; T &gt; &amp; size() const noexcept</div><div class="ttdoc">2D vector given by the (w,h) components of the rectangle</div><div class="ttdef"><b>Definition</b> LRect.h:131</div></div>
<div class="ttc" id="aclass_louvre_1_1_l_seat_html_abfb3294698b07c4a236e19046fbc2440"><div class="ttname"><a href="class_louvre_1_1_l_seat.html#abfb3294698b07c4a236e19046fbc2440">Louvre::LSeat::dnd</a></div><div class="ttdeci">LDND * dnd() const noexcept</div><div class="ttdoc">Access to the drag &amp; drop session manager.</div><div class="ttdef"><b>Definition</b> LSeat.h:197</div></div>
<div class="ttc" id="aclass_louvre_1_1_l_session_lock_manager_html_a030bc63c24e4bb205344939c91b2ba26"><div class="ttname"><a href="class_louvre_1_1_l_session_lock_manager.html#a030bc63c24e4bb205344939c91b2ba26">Louvre::LSessionLockManager::client</a></div><div class="ttdeci">LClient * client() const noexcept</div><div class="ttdoc">Gets the client locking the session.</div><div class="ttdef"><b>Definition</b> LSessionLockManager.cpp:24</div></div>
<div class="ttc" id="aclass_louvre_1_1_l_session_lock_manager_html_a1830cc3b524929125683b32dbadd16ff"><div class="ttname"><a href="class_louvre_1_1_l_session_lock_manager.html#a1830cc3b524929125683b32dbadd16ff">Louvre::LSessionLockManager::state</a></div><div class="ttdeci">State state() const noexcept</div><div class="ttdoc">Gets the current state of the session.</div><div class="ttdef"><b>Definition</b> LSessionLockManager.h:65</div></div>
<div class="ttc" id="aclass_louvre_1_1_l_session_lock_manager_html_a5d74787dedbc4e11c1ab15bf487e61f8a7a581195d038372012532c1e5c284f29"><div class="ttname"><a href="class_louvre_1_1_l_session_lock_manager.html#a5d74787dedbc4e11c1ab15bf487e61f8a7a581195d038372012532c1e5c284f29">Louvre::LSessionLockManager::Unlocked</a></div><div class="ttdeci">@ Unlocked</div><div class="ttdef"><b>Definition</b> LSessionLockManager.h:27</div></div>
<div class="ttc" id="aclass_louvre_1_1_l_surface_html_ad9c27f2d106edb222bc33c4bfc384f58"><div class="ttname"><a href="class_louvre_1_1_l_surface.html#ad9c27f2d106edb222bc33c4bfc384f58">Louvre::LSurface::raise</a></div><div class="ttdeci">void raise()</div><div class="ttdoc">Raises the surface within its current layer.</div><div class="ttdef"><b>Definition</b> LSurface.cpp:575</div></div>
<div class="ttc" id="anamespace_louvre_html_a62750620c88ee98b1c5286f1fc339c5b"><div class="ttname"><a href="namespace_louvre.html#a62750620c88ee98b1c5286f1fc339c5b">Louvre::compositor</a></div><div class="ttdeci">LCompositor * compositor() noexcept</div><div class="ttdoc">Gets the static LCompositor instance.</div><div class="ttdef"><b>Definition</b> LCompositor.cpp:37</div></div>
<div class="ttc" id="anamespace_louvre_html_aae2b1cd84497a1980827ff545147c58c"><div class="ttname"><a href="namespace_louvre.html#aae2b1cd84497a1980827ff545147c58c">Louvre::sessionLockManager</a></div><div class="ttdeci">LSessionLockManager * sessionLockManager() noexcept</div><div class="ttdoc">Gets the compositor's session lock manager.</div><div class="ttdef"><b>Definition</b> LCompositor.cpp:52</div></div>
<div class="ttc" id="anamespace_louvre_html_acee23df69aa55d791385fb9813b0319a"><div class="ttname"><a href="namespace_louvre.html#acee23df69aa55d791385fb9813b0319a">Louvre::seat</a></div><div class="ttdeci">LSeat * seat() noexcept</div><div class="ttdoc">Gets the compositor's seat.</div><div class="ttdef"><b>Definition</b> LCompositor.cpp:42</div></div>
<div class="ttc" id="anamespace_louvre_html_ad83fc7af7b313dac8820e4d4bd5b4383"><div class="ttname"><a href="namespace_louvre.html#ad83fc7af7b313dac8820e4d4bd5b4383">Louvre::LRect</a></div><div class="ttdeci">LRectTemplate&lt; Int32 &gt; LRect</div><div class="ttdoc">4D vector of 32 bits integers</div><div class="ttdef"><b>Definition</b> LNamespaces.h:267</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ad4dc5e1f724869e9523ce872afd56a1a" name="ad4dc5e1f724869e9523ce872afd56a1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4dc5e1f724869e9523ce872afd56a1a">&#9670;&#160;</a></span>resizeGL()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void resizeGL </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resize Event. </p>
<p>The <a class="el" href="class_louvre_1_1_l_output.html#ad4dc5e1f724869e9523ce872afd56a1a" title="Resize Event.">resizeGL()</a> event is invoked when the output scale or mode changes.</p>
<dl class="section note"><dt>Note</dt><dd>Avoid performing painting operations here, as they won't be visible on the screen. See the <a class="el" href="class_louvre_1_1_l_output.html#a0569e991ee4c6e4242578aca6d999741" title="Paint Event.">paintGL()</a> event.</dd></dl>
<h4><a class="anchor" id="default-implementation-13"></a>
Default Implementation</h4>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="class_louvre_1_1_l_output.html#ad4dc5e1f724869e9523ce872afd56a1a">LOutput::resizeGL</a>()</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_function" href="class_louvre_1_1_l_output.html#a3640e75ecf0af51755b05a1e1262b25c">repaint</a>();</div>
<div class="line">}</div>
<div class="ttc" id="aclass_louvre_1_1_l_output_html_a3640e75ecf0af51755b05a1e1262b25c"><div class="ttname"><a href="class_louvre_1_1_l_output.html#a3640e75ecf0af51755b05a1e1262b25c">Louvre::LOutput::repaint</a></div><div class="ttdeci">void repaint() noexcept</div><div class="ttdoc">Unlocks the rendering thread.</div><div class="ttdef"><b>Definition</b> LOutput.cpp:354</div></div>
<div class="ttc" id="aclass_louvre_1_1_l_output_html_ad4dc5e1f724869e9523ce872afd56a1a"><div class="ttname"><a href="class_louvre_1_1_l_output.html#ad4dc5e1f724869e9523ce872afd56a1a">Louvre::LOutput::resizeGL</a></div><div class="ttdeci">virtual void resizeGL()</div><div class="ttdoc">Resize Event.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="aa15f67e7da7f9351890b2c6258ee9225" name="aa15f67e7da7f9351890b2c6258ee9225"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa15f67e7da7f9351890b2c6258ee9225">&#9670;&#160;</a></span>moveGL()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void moveGL </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move Event. </p>
<p>This event is triggered when the output's position changes, see <a class="el" href="class_louvre_1_1_l_output.html#a6ab8c3ffe18601c1d3d355c385553a4c" title="Set the position of the output.">setPos()</a>.<br  />
 </p><dl class="section note"><dt>Note</dt><dd>Avoid performing painting operations here, as they won't be visible on the screen. See the <a class="el" href="class_louvre_1_1_l_output.html#a0569e991ee4c6e4242578aca6d999741" title="Paint Event.">paintGL()</a> event.</dd></dl>
<h4><a class="anchor" id="default-implementation-14"></a>
Default Implementation</h4>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="class_louvre_1_1_l_output.html#aa15f67e7da7f9351890b2c6258ee9225">LOutput::moveGL</a>()</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_function" href="class_louvre_1_1_l_output.html#a3640e75ecf0af51755b05a1e1262b25c">repaint</a>();</div>
<div class="line">}</div>
<div class="ttc" id="aclass_louvre_1_1_l_output_html_aa15f67e7da7f9351890b2c6258ee9225"><div class="ttname"><a href="class_louvre_1_1_l_output.html#aa15f67e7da7f9351890b2c6258ee9225">Louvre::LOutput::moveGL</a></div><div class="ttdeci">virtual void moveGL()</div><div class="ttdoc">Move Event.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a454d002ee90273a44dfb59a30246129e" name="a454d002ee90273a44dfb59a30246129e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a454d002ee90273a44dfb59a30246129e">&#9670;&#160;</a></span>uninitializeGL()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void uninitializeGL </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Uninitialize Event. </p>
<p>The <a class="el" href="class_louvre_1_1_l_output.html#a454d002ee90273a44dfb59a30246129e" title="Uninitialize Event.">uninitializeGL()</a> event is invoked after the output is removed from the compositor with <a class="el" href="class_louvre_1_1_l_compositor.html#aa6d9794dfb7cb513f834cf503591b864" title="Uninitializes the specified output.">LCompositor::removeOutput()</a> or when the output is unplugged, see <a class="el" href="class_louvre_1_1_l_seat.html#aff161f8b1d3c715362778773b4b612c6" title="Disconnected output.">LSeat::outputUnplugged()</a>.<br  />
 Here you should free your shaders, programs, textures, etc.</p>
<dl class="section note"><dt>Note</dt><dd>Avoid performing painting operations here, as they won't be visible on the screen. See the <a class="el" href="class_louvre_1_1_l_output.html#a0569e991ee4c6e4242578aca6d999741" title="Paint Event.">paintGL()</a> event.</dd></dl>
<h4><a class="anchor" id="default-implementation-15"></a>
Default Implementation</h4>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="class_louvre_1_1_l_output.html#a454d002ee90273a44dfb59a30246129e">LOutput::uninitializeGL</a>()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">/* No default implementation */</span></div>
<div class="line">}</div>
<div class="ttc" id="aclass_louvre_1_1_l_output_html_a454d002ee90273a44dfb59a30246129e"><div class="ttname"><a href="class_louvre_1_1_l_output.html#a454d002ee90273a44dfb59a30246129e">Louvre::LOutput::uninitializeGL</a></div><div class="ttdeci">virtual void uninitializeGL()</div><div class="ttdoc">Uninitialize Event.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a386f3d06f6c9f2d60e66c6da5bf3dd1a" name="a386f3d06f6c9f2d60e66c6da5bf3dd1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a386f3d06f6c9f2d60e66c6da5bf3dd1a">&#9670;&#160;</a></span>setGammaRequest()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void setGammaRequest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_louvre_1_1_l_client.html">LClient</a> *&#160;</td>
          <td class="paramname"><em>client</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_louvre_1_1_l_gamma_table.html">LGammaTable</a> *&#160;</td>
          <td class="paramname"><em>gamma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set gamma table request. </p>
<p>Clients using the <a href="https://wayland.app/protocols/wlr-gamma-control-unstable-v1#zwlr_gamma_control_manager_v1">wlr gamma control</a> protocol can request to set the gamma table for an output.</p>
<dl class="section warning"><dt>Warning</dt><dd>For security reasons, it is advisable to permit only authorized clients to perform such actions. See <a class="el" href="class_louvre_1_1_l_compositor.html#afeaeba54bdfa9a2ba5d1fe4fb0ee3483" title="Globals filter.">LCompositor::globalsFilter()</a>.</dd></dl>
<p>The gamma table (when is not <code>nullptr</code>) always have a size equal to <a class="el" href="class_louvre_1_1_l_output.html#a16a1856622b2e0e1d4f3f81961de6e0c" title="Gets the size of the gamma table.">gammaSize()</a>, hence, it is not necessary to validate that.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">client</td><td>Pointer to the client making the request. </td></tr>
    <tr><td class="paramname">gamma</td><td>Pointer to the <a class="el" href="class_louvre_1_1_l_gamma_table.html" title="Gamma correction table for outputs.">LGammaTable</a> object containing the requested gamma table or <code>nullptr</code> to restore the default table.</td></tr>
  </table>
  </dd>
</dl>
<h4><a class="anchor" id="default-implementation-16"></a>
Default Implementation</h4>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="class_louvre_1_1_l_output.html#a386f3d06f6c9f2d60e66c6da5bf3dd1a">LOutput::setGammaRequest</a>(<a class="code hl_class" href="class_louvre_1_1_l_client.html">LClient</a> *client, <span class="keyword">const</span> <a class="code hl_class" href="class_louvre_1_1_l_gamma_table.html">LGammaTable</a> *gamma)</div>
<div class="line">{</div>
<div class="line">    L_UNUSED(client)</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Sets the client gamma table */</span></div>
<div class="line">    <a class="code hl_function" href="class_louvre_1_1_l_output.html#a245e2751c991363d19e29fc3e22e1989">setGamma</a>(gamma);</div>
<div class="line">}</div>
<div class="ttc" id="aclass_louvre_1_1_l_client_html"><div class="ttname"><a href="class_louvre_1_1_l_client.html">Louvre::LClient</a></div><div class="ttdoc">Representation of a Wayland client.</div><div class="ttdef"><b>Definition</b> LClient.h:37</div></div>
<div class="ttc" id="aclass_louvre_1_1_l_gamma_table_html"><div class="ttname"><a href="class_louvre_1_1_l_gamma_table.html">Louvre::LGammaTable</a></div><div class="ttdoc">Gamma correction table for outputs.</div><div class="ttdef"><b>Definition</b> LGammaTable.h:34</div></div>
<div class="ttc" id="aclass_louvre_1_1_l_output_html_a245e2751c991363d19e29fc3e22e1989"><div class="ttname"><a href="class_louvre_1_1_l_output.html#a245e2751c991363d19e29fc3e22e1989">Louvre::LOutput::setGamma</a></div><div class="ttdeci">bool setGamma(const LGammaTable *gamma) noexcept</div><div class="ttdoc">Sets the gamma correction table for the output.</div><div class="ttdef"><b>Definition</b> LOutput.cpp:142</div></div>
<div class="ttc" id="aclass_louvre_1_1_l_output_html_a386f3d06f6c9f2d60e66c6da5bf3dd1a"><div class="ttname"><a href="class_louvre_1_1_l_output.html#a386f3d06f6c9f2d60e66c6da5bf3dd1a">Louvre::LOutput::setGammaRequest</a></div><div class="ttdeci">virtual void setGammaRequest(LClient *client, const LGammaTable *gamma)</div><div class="ttdoc">Set gamma table request.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a831a684290662b218b58ae77d82299f3" name="a831a684290662b218b58ae77d82299f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a831a684290662b218b58ae77d82299f3">&#9670;&#160;</a></span>leaseRequest()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool leaseRequest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_louvre_1_1_l_client.html">LClient</a> *&#160;</td>
          <td class="paramname"><em>client</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handles client requests to lease the output. </p>
<p>This request is only triggered if the output was previously advertised as leasable with <a class="el" href="class_louvre_1_1_l_output.html#ad7f3f3691fe3e30d5a56299f3c6c74cf" title="Advertises the output as leasable.">setLeasable()</a>.</p>
<p>Accepting the request does not guarantee that the <a class="el" href="class_louvre_1_1_l_output.html#a5b404ffeeead230796583114274bec55" title="Current lease created after an accepted leaseRequest().">lease()</a> property will be immediately set.<br  />
The graphics backend may fail to create it or the client may issue this request for additional outputs before it is created.</p>
<p>If accepted, any other client will stop leasing it. Additionally, if it is being used by the compositor, it will be uninitialized.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> to allow the client, <code>false</code> to deny.</dd></dl>
<h4><a class="anchor" id="default-implementation-17"></a>
Default Implementation</h4>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> <a class="code hl_function" href="class_louvre_1_1_l_output.html#a831a684290662b218b58ae77d82299f3">LOutput::leaseRequest</a>(<a class="code hl_class" href="class_louvre_1_1_l_client.html">LClient</a> *client)</div>
<div class="line">{</div>
<div class="line">    L_UNUSED(client)</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
<div class="ttc" id="aclass_louvre_1_1_l_output_html_a831a684290662b218b58ae77d82299f3"><div class="ttname"><a href="class_louvre_1_1_l_output.html#a831a684290662b218b58ae77d82299f3">Louvre::LOutput::leaseRequest</a></div><div class="ttdeci">virtual bool leaseRequest(LClient *client)</div><div class="ttdoc">Handles client requests to lease the output.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="aa5fd996431679f9db64a6a859eab7743" name="aa5fd996431679f9db64a6a859eab7743"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5fd996431679f9db64a6a859eab7743">&#9670;&#160;</a></span>leaseChanged()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void leaseChanged </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Notifies a change in the <a class="el" href="class_louvre_1_1_l_output.html#a5b404ffeeead230796583114274bec55" title="Current lease created after an accepted leaseRequest().">lease()</a> property. </p>
<p>This event is triggered whenever a client starts or stops leasing the output.</p>
<h4><a class="anchor" id="default-implementation-18"></a>
Default Implementation</h4>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="class_louvre_1_1_l_output.html#aa5fd996431679f9db64a6a859eab7743">LOutput::leaseChanged</a>()</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_function" href="class_louvre_1_1_l_log.html#adacf73b93ca6fa3985f2999f7d6b3b29">LLog::debug</a>(<span class="stringliteral">&quot;[%s] Leased by client: %s.&quot;</span>, <a class="code hl_function" href="class_louvre_1_1_l_output.html#a33256784969e3347f423f72af1727cbd">name</a>(), <a class="code hl_function" href="class_louvre_1_1_l_output.html#a5b404ffeeead230796583114274bec55">lease</a>() ? <span class="stringliteral">&quot;YES&quot;</span> : <span class="stringliteral">&quot;NO&quot;</span>);</div>
<div class="line">}</div>
<div class="ttc" id="aclass_louvre_1_1_l_log_html_adacf73b93ca6fa3985f2999f7d6b3b29"><div class="ttname"><a href="class_louvre_1_1_l_log.html#adacf73b93ca6fa3985f2999f7d6b3b29">Louvre::LLog::debug</a></div><div class="ttdeci">static void debug(const char *format,...)</div><div class="ttdoc">Debugging messages. LOUVRE_DEBUG &gt;= 4.</div><div class="ttdef"><b>Definition</b> LLog.cpp:72</div></div>
<div class="ttc" id="aclass_louvre_1_1_l_output_html_a33256784969e3347f423f72af1727cbd"><div class="ttname"><a href="class_louvre_1_1_l_output.html#a33256784969e3347f423f72af1727cbd">Louvre::LOutput::name</a></div><div class="ttdeci">const char * name() const noexcept</div><div class="ttdoc">Gets the output name.</div><div class="ttdef"><b>Definition</b> LOutput.cpp:482</div></div>
<div class="ttc" id="aclass_louvre_1_1_l_output_html_a5b404ffeeead230796583114274bec55"><div class="ttname"><a href="class_louvre_1_1_l_output.html#a5b404ffeeead230796583114274bec55">Louvre::LOutput::lease</a></div><div class="ttdeci">Protocols::DRMLease::RDRMLease * lease() const noexcept</div><div class="ttdoc">Current lease created after an accepted leaseRequest().</div><div class="ttdef"><b>Definition</b> LOutput.cpp:452</div></div>
<div class="ttc" id="aclass_louvre_1_1_l_output_html_aa5fd996431679f9db64a6a859eab7743"><div class="ttname"><a href="class_louvre_1_1_l_output.html#aa5fd996431679f9db64a6a859eab7743">Louvre::LOutput::leaseChanged</a></div><div class="ttdeci">virtual void leaseChanged()</div><div class="ttdoc">Notifies a change in the lease() property.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a03894018bad5907971d5b9d0ec072c6f" name="a03894018bad5907971d5b9d0ec072c6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03894018bad5907971d5b9d0ec072c6f">&#9670;&#160;</a></span>availableGeometryChanged()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void availableGeometryChanged </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Notifies a change in <a class="el" href="class_louvre_1_1_l_output.html#a33473d432755f05c5eda568b383000ff" title="Retrieves the rect within the output that is not occupied by exclusive zones.">availableGeometry()</a>. </p>
<p>This event is triggered whenever one of the <a class="el" href="class_louvre_1_1_l_output.html#afc3ea58fabda3ae63531b9f99d955adc" title="Retrieves all exclusive zones assigned to this output.">exclusiveZones()</a> changes.</p>
<h4><a class="anchor" id="default-implementation-19"></a>
Default Implementation</h4>
<p>The default implementation adjusts and reconfigures mapped <a class="el" href="class_louvre_1_1_l_toplevel_role.html" title="Toplevel role for surfaces.">LToplevelRole</a> surfaces to prevent occlusion of the exclusive zone on each edge.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="class_louvre_1_1_l_output.html#a03894018bad5907971d5b9d0ec072c6f">LOutput::availableGeometryChanged</a>()</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">const</span> <a class="code hl_class" href="class_louvre_1_1_l_rect_template.html">LRect</a> availGeo { <a class="code hl_function" href="class_louvre_1_1_l_output.html#a0843c1bb97b8a8cfb3faa6f75e68acd6">pos</a>() + <a class="code hl_function" href="class_louvre_1_1_l_output.html#a33473d432755f05c5eda568b383000ff">availableGeometry</a>().<a class="code hl_function" href="class_louvre_1_1_l_rect_template.html#a2a2dc2fd45980947abd9dc2f80a7b7bf">pos</a>(), <a class="code hl_function" href="class_louvre_1_1_l_output.html#a33473d432755f05c5eda568b383000ff">availableGeometry</a>().<a class="code hl_function" href="class_louvre_1_1_l_rect_template.html#af6951b309861d44f0657e149461f6915">size</a>() };</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<a class="code hl_class" href="class_louvre_1_1_l_surface.html">LSurface</a> *surface : <a class="code hl_function" href="namespace_louvre.html#a62750620c88ee98b1c5286f1fc339c5b">compositor</a>()-&gt;surfaces())</div>
<div class="line">    {        </div>
<div class="line">        <a class="code hl_class" href="class_louvre_1_1_l_toplevel_role.html">LToplevelRole</a> *tl { surface-&gt;toplevel() };</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (tl &amp;&amp; !tl-&gt;fullscreen())</div>
<div class="line">        {</div>
<div class="line">            <span class="keyword">const</span> <a class="code hl_typedef" href="namespace_louvre.html#a4df5473974ae0f28f3a4967f296a657b">LSize</a> toplevelExtraSize { tl-&gt;extraGeometry().left + tl-&gt;extraGeometry().right, tl-&gt;extraGeometry().top + tl-&gt;extraGeometry().bottom };</div>
<div class="line">            <a class="code hl_typedef" href="namespace_louvre.html#ad83fc7af7b313dac8820e4d4bd5b4383">LRect</a> toplevelRect { surface-&gt;<a class="code hl_function" href="class_louvre_1_1_l_rect_template.html#a2a2dc2fd45980947abd9dc2f80a7b7bf">pos</a>(), tl-&gt;windowGeometry().size() + toplevelExtraSize };</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">if</span> (<a class="code hl_function" href="namespace_louvre.html#a62750620c88ee98b1c5286f1fc339c5b">compositor</a>()-&gt;mostIntersectedOutput(toplevelRect) != <span class="keyword">this</span>)</div>
<div class="line">                <span class="keywordflow">continue</span>;</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">if</span> (tl-&gt;maximized())</div>
<div class="line">            {</div>
<div class="line">                surface-&gt;setPos(availGeo.pos());</div>
<div class="line">                tl-&gt;configureSize(availGeo.size()</div>
<div class="line">                    - toplevelExtraSize);</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">else</span></div>
<div class="line">            {</div>
<div class="line">                <span class="keywordflow">if</span> (<a class="code hl_function" href="class_louvre_1_1_l_output.html#ac24588e06d25cf65b28c6b5ff8574789">exclusiveEdges</a>().right != 0 &amp;&amp; toplevelRect.x() + toplevelRect.w() &gt; availGeo.x() + availGeo.w())</div>
<div class="line">                    toplevelRect.<a class="code hl_function" href="class_louvre_1_1_l_point_template.html#a229f846fd82293ef8b0c2a69342652a4">setX</a>(availGeo.x() + availGeo.w() - toplevelRect.w());</div>
<div class="line"> </div>
<div class="line">                <span class="keywordflow">if</span> (<a class="code hl_function" href="class_louvre_1_1_l_output.html#ac24588e06d25cf65b28c6b5ff8574789">exclusiveEdges</a>().bottom != 0 &amp;&amp; toplevelRect.y() + toplevelRect.h() &gt; availGeo.y() + availGeo.h())</div>
<div class="line">                    toplevelRect.setY(availGeo.y() + availGeo.h() - toplevelRect.h());</div>
<div class="line"> </div>
<div class="line">                <span class="keywordflow">if</span> (<a class="code hl_function" href="class_louvre_1_1_l_output.html#ac24588e06d25cf65b28c6b5ff8574789">exclusiveEdges</a>().left != 0 &amp;&amp; toplevelRect.x() &lt; availGeo.x())</div>
<div class="line">                    toplevelRect.setX(availGeo.x());</div>
<div class="line"> </div>
<div class="line">                <span class="keywordflow">if</span> (<a class="code hl_function" href="class_louvre_1_1_l_output.html#ac24588e06d25cf65b28c6b5ff8574789">exclusiveEdges</a>().top != 0 &amp;&amp; toplevelRect.y() &lt; availGeo.y())</div>
<div class="line">                    toplevelRect.setY(availGeo.y());</div>
<div class="line"> </div>
<div class="line">                <span class="keywordtype">bool</span> needsConfigure { <span class="keyword">false</span> };</div>
<div class="line"> </div>
<div class="line">                <span class="keywordflow">if</span> (<a class="code hl_function" href="class_louvre_1_1_l_output.html#ac24588e06d25cf65b28c6b5ff8574789">exclusiveEdges</a>().right != 0 &amp;&amp; toplevelRect.w() &gt; availGeo.w())</div>
<div class="line">                {</div>
<div class="line">                    toplevelRect.setW(availGeo.w());</div>
<div class="line">                    needsConfigure = <span class="keyword">true</span>;</div>
<div class="line">                }</div>
<div class="line"> </div>
<div class="line">                <span class="keywordflow">if</span> (<a class="code hl_function" href="class_louvre_1_1_l_output.html#ac24588e06d25cf65b28c6b5ff8574789">exclusiveEdges</a>().bottom != 0 &amp;&amp; toplevelRect.h() &gt; availGeo.h())</div>
<div class="line">                {</div>
<div class="line">                    toplevelRect.setH(availGeo.h());</div>
<div class="line">                    needsConfigure = <span class="keyword">true</span>;</div>
<div class="line">                }</div>
<div class="line"> </div>
<div class="line">                <span class="keywordflow">if</span> (needsConfigure)</div>
<div class="line">                    tl-&gt;configureSize(toplevelRect.size() - toplevelExtraSize);</div>
<div class="line"> </div>
<div class="line">                surface-&gt;setPos(toplevelRect.pos());</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="aclass_louvre_1_1_l_output_html_a03894018bad5907971d5b9d0ec072c6f"><div class="ttname"><a href="class_louvre_1_1_l_output.html#a03894018bad5907971d5b9d0ec072c6f">Louvre::LOutput::availableGeometryChanged</a></div><div class="ttdeci">virtual void availableGeometryChanged()</div><div class="ttdoc">Notifies a change in availableGeometry().</div></div>
<div class="ttc" id="aclass_louvre_1_1_l_output_html_ac24588e06d25cf65b28c6b5ff8574789"><div class="ttname"><a href="class_louvre_1_1_l_output.html#ac24588e06d25cf65b28c6b5ff8574789">Louvre::LOutput::exclusiveEdges</a></div><div class="ttdeci">const LMargins &amp; exclusiveEdges() const noexcept</div><div class="ttdoc">Gets the sum of the space occupied by exclusive zones for each edge.</div><div class="ttdef"><b>Definition</b> LOutput.cpp:71</div></div>
<div class="ttc" id="aclass_louvre_1_1_l_point_template_html_a229f846fd82293ef8b0c2a69342652a4"><div class="ttname"><a href="class_louvre_1_1_l_point_template.html#a229f846fd82293ef8b0c2a69342652a4">Louvre::LPointTemplate::setX</a></div><div class="ttdeci">constexpr void setX(T x) noexcept</div><div class="ttdoc">Assigns the value to the first component of the vector.</div><div class="ttdef"><b>Definition</b> LPoint.h:58</div></div>
<div class="ttc" id="aclass_louvre_1_1_l_surface_html"><div class="ttname"><a href="class_louvre_1_1_l_surface.html">Louvre::LSurface</a></div><div class="ttdoc">A client &quot;window&quot;.</div><div class="ttdef"><b>Definition</b> LSurface.h:109</div></div>
<div class="ttc" id="aclass_louvre_1_1_l_toplevel_role_html"><div class="ttname"><a href="class_louvre_1_1_l_toplevel_role.html">Louvre::LToplevelRole</a></div><div class="ttdoc">Toplevel role for surfaces.</div><div class="ttdef"><b>Definition</b> LToplevelRole.h:77</div></div>
<div class="ttc" id="anamespace_louvre_html_a4df5473974ae0f28f3a4967f296a657b"><div class="ttname"><a href="namespace_louvre.html#a4df5473974ae0f28f3a4967f296a657b">Louvre::LSize</a></div><div class="ttdeci">LPoint LSize</div><div class="ttdoc">2D vector of 32 bits integers</div><div class="ttdef"><b>Definition</b> LNamespaces.h:258</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ab6969bb3bc86f834354210a6b4d7f666" name="ab6969bb3bc86f834354210a6b4d7f666"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6969bb3bc86f834354210a6b4d7f666">&#9670;&#160;</a></span>repaintFilter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool repaintFilter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Temporarily disables repaint calls for this output. </p>
<p>An output locks its rendering thread until <a class="el" href="class_louvre_1_1_l_output.html#a3640e75ecf0af51755b05a1e1262b25c" title="Unlocks the rendering thread.">repaint()</a> is called. However, many objects and implementations within the compositor may automatically trigger repaints to reflect changes, making it difficult to prevent unwanted repaints.</p>
<p>This method intercepts <a class="el" href="class_louvre_1_1_l_output.html#a3640e75ecf0af51755b05a1e1262b25c" title="Unlocks the rendering thread.">repaint()</a> calls and preserves the last rendered frame. When <code>false</code> is returned, the <a class="el" href="class_louvre_1_1_l_output.html#a3640e75ecf0af51755b05a1e1262b25c" title="Unlocks the rendering thread.">repaint()</a> calls are ignored, and <a class="el" href="class_louvre_1_1_l_output.html#a0569e991ee4c6e4242578aca6d999741" title="Paint Event.">paintGL()</a> is not triggered.</p>
<dl class="section note"><dt>Note</dt><dd>During initialization, uninitialization, or mode changes, the rendering thread is forcefully unlocked and the filter is ignored to prevent deadlocks.</dd></dl>
<h4><a class="anchor" id="default-implementation-20"></a>
Default Implementation</h4>
<p>The default implementation accepts all <a class="el" href="class_louvre_1_1_l_output.html#a3640e75ecf0af51755b05a1e1262b25c" title="Unlocks the rendering thread.">repaint()</a> calls.</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> <a class="code hl_function" href="class_louvre_1_1_l_output.html#ab6969bb3bc86f834354210a6b4d7f666">LOutput::repaintFilter</a>()</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
<div class="ttc" id="aclass_louvre_1_1_l_output_html_ab6969bb3bc86f834354210a6b4d7f666"><div class="ttname"><a href="class_louvre_1_1_l_output.html#ab6969bb3bc86f834354210a6b4d7f666">Louvre::LOutput::repaintFilter</a></div><div class="ttdeci">virtual bool repaintFilter()</div><div class="ttdoc">Temporarily disables repaint calls for this output.</div></div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd><code>true</code> if the repaint should proceed, <code>false</code> otherwise. </dd></dl>

</div>
</div>
</div><!-- contents -->
<script>
    var menu = false;
    var burger, nav;
    function resp()
    {
        if (window.innerWidth < 768)
        {
            burger.hidden = false;
            nav.hidden = true;
        }
        else
        {
            burger.hidden = true;
            nav.hidden = false;
        }
        menu = false;
    }
    function toggleMenu()
    {
        nav.hidden = menu;
        menu = !menu;
    }
    window.onload = function()
    {
        if (typeof toggleLevel !== "undefined")
            toggleLevel(2);
        // Get all <a> tags with the "el" class
        var elLinks = document.querySelectorAll('a.el');
        // Loop through the matched elements
        elLinks.forEach(function(link) 
        {
            // Replace "Louvre::" with an empty string in the text content
            link.textContent = link.textContent.replace(/Louvre::/g, '');
        });
        nav = document.getElementById('main-nav');
        burger = document.createElement('div');
        burger.style.position = 'absolute';
        burger.style.top = '14px';
        burger.style.right = burger.style.top;
        burger.innerHTML = '<svg onclick="toggleMenu()" height="32px" viewBox="0 0 448 512"><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg>';
        document.getElementById('top').appendChild(burger);
        resp();
    };
    window.onresize = function()
    {
        resp();
    };
</script>
<div id="nav-path" class="navpath">
    <ul>
        <li class="footer">Project developed by <a href="https://github.com/CuarzoSoftware"><img class="footer" src="https://avatars.githubusercontent.com/u/29326763?s=200&v=4" style="margin-left:2px;position:relative;top:-1px;width:12px;height:12px" alt="cuarzo"/> Cuarzo Software</a></li>
    </ul>
</div>