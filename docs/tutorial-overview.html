<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Louvre: Chapter 2: Quick Overview</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="Logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">Louvre<span id="projectnumber">&#160;v2.18.1-1</span>
   </div>
   <div id="projectbrief">C++ library for Wayland compositors</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Chapter 2: Quick Overview</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Let's start by taking a concise look at how <a class="el" href="namespace_louvre.html" title="Namespaces.">Louvre</a> works.</p>
<h1><a class="anchor" id="interface-methods"></a>
Interface Methods</h1>
<p>First and foremost, it's crucial to understand that <a class="el" href="namespace_louvre.html" title="Namespaces.">Louvre</a> employs virtual methods as interfaces to let you respond to signals or client application requests.</p>
<blockquote class="doxtable">
<p>&zwj;If you're not familiar with virtual methods, I recommend checking out this excellent video explanation by The Cherno: <a href="https://www.youtube.com/watch?v=oIV2KchSyGQ">Watch the video</a>. </p>
</blockquote>
<p>Consider the example of the <a class="el" href="class_louvre_1_1_l_surface.html" title="A client &quot;window&quot;.">Louvre::LSurface</a> class, which typically represents a "client window":</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespace_louvre.html">Louvre</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>YourCustomSurface : <span class="keyword">public</span> <a class="code hl_class" href="class_louvre_1_1_l_surface.html">LSurface</a></div>
<div class="line">{</div>
<div class="line">    <span class="comment">// ... </span></div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> bufferSizeChanged()<span class="keyword"> override</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        <span class="comment">// Here your handle this signal</span></div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> mappingChanged()<span class="keyword"> override</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        <span class="comment">// Here your handle this signal</span></div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// ... </span></div>
<div class="line">};</div>
<div class="ttc" id="aclass_louvre_1_1_l_surface_html"><div class="ttname"><a href="class_louvre_1_1_l_surface.html">Louvre::LSurface</a></div><div class="ttdoc">A client &quot;window&quot;.</div><div class="ttdef"><b>Definition</b> LSurface.h:109</div></div>
<div class="ttc" id="anamespace_louvre_html"><div class="ttname"><a href="namespace_louvre.html">Louvre</a></div><div class="ttdoc">Namespaces.</div><div class="ttdef"><b>Definition</b> LBox.h:7</div></div>
</div><!-- fragment --><p>Both <a class="el" href="class_louvre_1_1_l_surface.html#a57442cc8cc416d6fc061dea6ff22df5e" title="Notifies a change in buffer dimensions.">Louvre::LSurface::bufferSizeChanged()</a> and <a class="el" href="class_louvre_1_1_l_surface.html#a1150cf016134af22675fdb93b240ee78" title="Notifies of a change in the mapped() property.">Louvre::LSurface::mappingChanged()</a> are virtual methods of the <a class="el" href="class_louvre_1_1_l_surface.html" title="A client &quot;window&quot;.">Louvre::LSurface</a> class, and they are not intended for direct invocation by you. Instead, the library triggers these methods to notify you of changes, allowing you to handle them effectively.</p>
<p>It's important to note that not all methods in the library are virtual. Just a few or none per class, and you can easily identify them because they often end with suffixes such as <em>Changed</em>, <em>Request</em>, <em>Signal</em>, and so on. If you're not sure, you can always check the <a href="annotated.html">API documentation</a>.</p>
<p>Also, you don't need to reimplement every class and override all of its methods. You should selectively focus on the classes and methods that are relevant to your specific use case, as the library provides default ways of handling them.</p>
<p>To see the default implementation of each virtual method, please refer to the API documentation, such as <a class="el" href="class_louvre_1_1_l_surface.html#a57442cc8cc416d6fc061dea6ff22df5e" title="Notifies a change in buffer dimensions.">Louvre::LSurface::bufferSizeChanged()</a> and <a class="el" href="class_louvre_1_1_l_surface.html#a1150cf016134af22675fdb93b240ee78" title="Notifies of a change in the mapped() property.">Louvre::LSurface::mappingChanged()</a>.</p>
<h1><a class="anchor" id="understanding-wayland"></a>
Understanding Wayland</h1>
<p>In case you're not aware, Wayland's sole purpose is to provide a client/server architecture and mechanisms through which a compositor can communicate with applications, nothing more than that. All other functionalities, such as rendering and accessing system input, are implemented by the compositor itself, in this case, by <a class="el" href="namespace_louvre.html" title="Namespaces.">Louvre</a>. Messages in Wayland and their parameters are defined in an <code>.xml</code> file, which can be converted into C code using the <a href="https://wayland-book.com/libwayland/wayland-scanner.html">wayland-scanner</a> tool to be used by clients and the compositor. Each XML file is considered a protocol, and there are several, such as the Wayland protocol itself, XDG Shell, Viewporter, etc. You can even create your own protocols. Each protocol has one or more interfaces, which are considered "objects" that have various events (messages from the compositor to the client) and requests (messages from the client to the compositor).</p>
<p>For example, the <a class="el" href="class_louvre_1_1_l_surface.html" title="A client &quot;window&quot;.">Louvre::LSurface</a> class represents the <a href="https://wayland.app/protocols/wayland#wl_surface">wl_surface</a> interface of the Wayland protocol, and you can use it both to listen to client requests and to send them events. Now, as the name suggests, protocols have rules on how the compositor should react to requests. A significant portion of these requests, especially the more tedious ones, are handled directly by <a class="el" href="namespace_louvre.html" title="Namespaces.">Louvre</a> internally. Others are preprocessed and notified to the user through a simpler API, and some are simply identical to the original ones.</p>
<p>For a compositor to be functional, it must correctly handle all these requests. For this reason, <a class="el" href="namespace_louvre.html" title="Namespaces.">Louvre</a> also provides a default implementation for each of them, which you can gradually override to create your own unique compositor. This allows you to see results on the screen from day one and validate each change progressively.</p>
<h1><a class="anchor" id="main-classes"></a>
Main Classes</h1>
<p><a class="el" href="namespace_louvre.html" title="Namespaces.">Louvre</a> provides a diverse range of classes, each serving specific purposes. Here's a quick overview of some crucial classes that will guide you in navigating the documentation effectively:</p>
<h2><a class="anchor" id="lcompositor"></a>
LCompositor</h2>
<p>This is the heart of every <a class="el" href="namespace_louvre.html" title="Namespaces.">Louvre</a> compositor, responsible for tasks such as creating other classes, loading the graphic and input backends, processing events, handling client requests, and much more. One particularly significant aspect to understand is that it includes multiple virtual constructors and destructors for various other classes.</p>
<p>For instance, when a client wishes to create a new surface, the Louvre::LCompositor::createSurfaceRequest() virtual method is invoked:</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespace_louvre.html">Louvre</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>YourCustomCompositor : <span class="keyword">public</span> <a class="code hl_class" href="class_louvre_1_1_l_compositor.html">LCompositor</a></div>
<div class="line">{</div>
<div class="line">    <span class="comment">// ... </span></div>
<div class="line">    </div>
<div class="line">    <a class="code hl_class" href="class_louvre_1_1_l_surface.html">LSurface</a> *createSurfaceRequest(<span class="keyword">const</span> <span class="keywordtype">void</span> *params)<span class="keyword"> override</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">new</span> YourCustomSurface(params);</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> destroySurfaceRequest(<a class="code hl_class" href="class_louvre_1_1_l_surface.html">LSurface</a> *surface)<span class="keyword"> override</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        <span class="comment">// Only notifies; you must not call &#39;delete surface;&#39;</span></div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// ... </span></div>
<div class="line">};</div>
<div class="ttc" id="aclass_louvre_1_1_l_compositor_html"><div class="ttname"><a href="class_louvre_1_1_l_compositor.html">Louvre::LCompositor</a></div><div class="ttdoc">Louvre's core and objects factory.</div><div class="ttdef"><b>Definition</b> LCompositor.h:24</div></div>
</div><!-- fragment --><p>As you might deduce, each virtual constructor/destructor has a default implementation provided by the library as well. For example, the default implementation of Louvre::LCompositor::createSurfaceRequest() returns a new <a class="el" href="class_louvre_1_1_l_surface.html" title="A client &quot;window&quot;.">Louvre::LSurface</a> instance, rather than an instance of <code>YourCustomSurface</code> class.</p>
<p>Therefore, if you intend to use your own subclasses, you should override their respective virtual constructors in <a class="el" href="class_louvre_1_1_l_compositor.html" title="Louvre&#39;s core and objects factory.">Louvre::LCompositor</a>.</p>
<blockquote class="doxtable">
<p>&zwj;It's essential to note that not all classes in <a class="el" href="namespace_louvre.html" title="Namespaces.">Louvre</a> are created in this manner, this approach is specifically applicable to client, backend, and internal compositor resources that provide an interface (virtual methods) you can override. </p>
</blockquote>
<h2><a class="anchor" id="loutput"></a>
LOutput</h2>
<p>The <a class="el" href="class_louvre_1_1_l_output.html" title="A display rendering interface.">Louvre::LOutput</a> class both represents and manages rendering for a specific display. It offers a range of essential virtual methods, including <a class="el" href="class_louvre_1_1_l_output.html#a2aeeb1c8e8bb0f723ebb7129df23d4e8" title="Initialize Event.">Louvre::LOutput::initializeGL()</a>, <a class="el" href="class_louvre_1_1_l_output.html#a0569e991ee4c6e4242578aca6d999741" title="Paint Event.">Louvre::LOutput::paintGL()</a>, <a class="el" href="class_louvre_1_1_l_output.html#ad4dc5e1f724869e9523ce872afd56a1a" title="Resize Event.">Louvre::LOutput::resizeGL()</a>, and others, which you can override to perform your own painting operations.</p>
<h2><a class="anchor" id="lpointer"></a>
LPointer</h2>
<p><a class="el" href="class_louvre_1_1_l_pointer.html" title="Class for handling events generated by pointing devices.">Louvre::LPointer</a> is a singleton class responsible for capturing input events from devices like a mouse or touchpad. It offers various virtual methods for event listening and enables forwarding these events to client applications.</p>
<h2><a class="anchor" id="lkeyboard"></a>
LKeyboard</h2>
<p><a class="el" href="class_louvre_1_1_l_keyboard.html" title="Class for handling keyboard events.">Louvre::LKeyboard</a> is similar to <a class="el" href="class_louvre_1_1_l_pointer.html" title="Class for handling events generated by pointing devices.">Louvre::LPointer</a> but for system keyboard events. It allows you to listen to keyboard events, forward them to clients, and configure keyboard aspects such as the keymap, key press repeat rate, and more.</p>
<p>In the upcoming chapters, we will explore the practical usage of these classes, and many more.</p>
<p><a href="01.md">◀ Chapter 1: Introduction </a> || <a href="03.md">Chapter 3: Setting Up the Project ▶</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<script>
    var menu = false;
    var burger, nav;
    function resp()
    {
        if (window.innerWidth < 768)
        {
            burger.hidden = false;
            nav.hidden = true;
        }
        else
        {
            burger.hidden = true;
            nav.hidden = false;
        }
        menu = false;
    }
    function toggleMenu()
    {
        nav.hidden = menu;
        menu = !menu;
    }
    window.onload = function()
    {
        if (typeof toggleLevel !== "undefined")
            toggleLevel(2);
        // Get all <a> tags with the "el" class
        var elLinks = document.querySelectorAll('a.el');
        // Loop through the matched elements
        elLinks.forEach(function(link) 
        {
            // Replace "Louvre::" with an empty string in the text content
            link.textContent = link.textContent.replace(/Louvre::/g, '');
        });
        nav = document.getElementById('main-nav');
        burger = document.createElement('div');
        burger.style.position = 'absolute';
        burger.style.top = '14px';
        burger.style.right = burger.style.top;
        burger.innerHTML = '<svg onclick="toggleMenu()" height="32px" viewBox="0 0 448 512"><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg>';
        document.getElementById('top').appendChild(burger);
        resp();
    };
    window.onresize = function()
    {
        resp();
    };
</script>
<div id="nav-path" class="navpath">
    <ul>
        <li class="footer">Project developed by <a href="https://github.com/CuarzoSoftware"><img class="footer" src="https://avatars.githubusercontent.com/u/29326763?s=200&v=4" style="margin-left:2px;position:relative;top:-1px;width:12px;height:12px" alt="cuarzo"/> Cuarzo Software</a></li>
    </ul>
</div>