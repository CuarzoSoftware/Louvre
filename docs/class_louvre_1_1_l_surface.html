<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Louvre: LSurface Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="Logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">Louvre<span id="projectnumber">&#160;v2.18.1-1</span>
   </div>
   <div id="projectbrief">C++ library for Wayland compositors</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_louvre.html">Louvre</a></li><li class="navelem"><a class="el" href="class_louvre_1_1_l_surface.html">LSurface</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_louvre_1_1_l_surface-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">LSurface Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A client "window".  
 <a href="class_louvre_1_1_l_surface.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_l_surface_8h_source.html">LSurface.h</a>&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for LSurface:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
 <div class="center">
  <img src="class_louvre_1_1_l_surface.png" usemap="#LSurface_map" alt=""/>
  <map id="LSurface_map" name="LSurface_map">
<area href="class_louvre_1_1_l_factory_object.html" title="Base class for Factory objects." alt="LFactoryObject" shape="rect" coords="0,56,100,80"/>
<area href="class_louvre_1_1_l_object.html" title="Base class for Louvre objects." alt="LObject" shape="rect" coords="0,0,100,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a03bbf64580744af6d161dc054d3fb1fd" id="r_a03bbf64580744af6d161dc054d3fb1fd"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_surface.html#a03bbf64580744af6d161dc054d3fb1fd">Role</a> : UInt32 </td></tr>
<tr class="memdesc:a03bbf64580744af6d161dc054d3fb1fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">ID of library roles.  <a href="class_louvre_1_1_l_surface.html#a03bbf64580744af6d161dc054d3fb1fd">More...</a><br /></td></tr>
<tr class="separator:a03bbf64580744af6d161dc054d3fb1fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6251d534fc6198bc897fd8a089847008" id="r_a6251d534fc6198bc897fd8a089847008"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_surface.html#a6251d534fc6198bc897fd8a089847008">PointerConstraintMode</a> </td></tr>
<tr class="memdesc:a6251d534fc6198bc897fd8a089847008"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer constraint modes.  <a href="class_louvre_1_1_l_surface.html#a6251d534fc6198bc897fd8a089847008">More...</a><br /></td></tr>
<tr class="separator:a6251d534fc6198bc897fd8a089847008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_class_louvre_1_1_l_factory_object"><td colspan="2" onclick="javascript:toggleInherit('pub_types_class_louvre_1_1_l_factory_object')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="class_louvre_1_1_l_factory_object.html">LFactoryObject</a></td></tr>
<tr class="memitem:ad96f0a085c6542bc6c83459a88bfb560 inherit pub_types_class_louvre_1_1_l_factory_object" id="r_ad96f0a085c6542bc6c83459a88bfb560"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_factory_object.html#ad96f0a085c6542bc6c83459a88bfb560">Type</a> : Int32 </td></tr>
<tr class="memdesc:ad96f0a085c6542bc6c83459a88bfb560"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base factory object types.  <a href="class_louvre_1_1_l_factory_object.html#ad96f0a085c6542bc6c83459a88bfb560">More...</a><br /></td></tr>
<tr class="separator:ad96f0a085c6542bc6c83459a88bfb560 inherit pub_types_class_louvre_1_1_l_factory_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a069cc6b8646159314fbcd55faa106b2b" id="r_a069cc6b8646159314fbcd55faa106b2b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_surface.html#a069cc6b8646159314fbcd55faa106b2b">LSurface</a> (const void *params) noexcept</td></tr>
<tr class="memdesc:a069cc6b8646159314fbcd55faa106b2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor of the <a class="el" href="class_louvre_1_1_l_surface.html" title="A client &quot;window&quot;.">LSurface</a> class.  <br /></td></tr>
<tr class="separator:a069cc6b8646159314fbcd55faa106b2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3de927bf7cb148773736c7eec704f57b" id="r_a3de927bf7cb148773736c7eec704f57b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_surface.html#a3de927bf7cb148773736c7eec704f57b">~LSurface</a> ()</td></tr>
<tr class="memdesc:a3de927bf7cb148773736c7eec704f57b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor of the <a class="el" href="class_louvre_1_1_l_surface.html" title="A client &quot;window&quot;.">LSurface</a> class.  <br /></td></tr>
<tr class="separator:a3de927bf7cb148773736c7eec704f57b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47bae11fb88b5ea985dd22b437310f4d" id="r_a47bae11fb88b5ea985dd22b437310f4d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_louvre.html#a6dd0ee7d9f15733c1c631bab2262f51c">LSurfaceLayer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_surface.html#a47bae11fb88b5ea985dd22b437310f4d">layer</a> () const noexcept</td></tr>
<tr class="memdesc:a47bae11fb88b5ea985dd22b437310f4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the layer in which this surface currently resides.  <br /></td></tr>
<tr class="separator:a47bae11fb88b5ea985dd22b437310f4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9924d855d4a3ff48c8d144103588ae1a" id="r_a9924d855d4a3ff48c8d144103588ae1a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_louvre_1_1_l_background_blur.html">LBackgroundBlur</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_surface.html#a9924d855d4a3ff48c8d144103588ae1a">backgroundBlur</a> () const noexcept</td></tr>
<tr class="memdesc:a9924d855d4a3ff48c8d144103588ae1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the background blur controller associated with the surface.  <br /></td></tr>
<tr class="separator:a9924d855d4a3ff48c8d144103588ae1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef41c6d77555ec63040c5baa94f3ffff" id="r_aef41c6d77555ec63040c5baa94f3ffff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_surface.html#aef41c6d77555ec63040c5baa94f3ffff">setPos</a> (const <a class="el" href="namespace_louvre.html#a1111511396cab1b2607e4ac55e1883a3">LPoint</a> &amp;newPos) noexcept</td></tr>
<tr class="memdesc:aef41c6d77555ec63040c5baa94f3ffff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns the position.  <br /></td></tr>
<tr class="separator:aef41c6d77555ec63040c5baa94f3ffff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d24b54d39edb99f9f851090c20d0499" id="r_a1d24b54d39edb99f9f851090c20d0499"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_surface.html#a1d24b54d39edb99f9f851090c20d0499">setPos</a> (<a class="el" href="namespace_louvre.html#a20b0c262d9ef5d263888e463dfa99638">Int32</a> x, <a class="el" href="namespace_louvre.html#a20b0c262d9ef5d263888e463dfa99638">Int32</a> y) noexcept</td></tr>
<tr class="memdesc:a1d24b54d39edb99f9f851090c20d0499"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns the position.  <br /></td></tr>
<tr class="separator:a1d24b54d39edb99f9f851090c20d0499"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa70e56e4e7ccb56992207e10ebc3ac1d" id="r_aa70e56e4e7ccb56992207e10ebc3ac1d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_surface.html#aa70e56e4e7ccb56992207e10ebc3ac1d">setX</a> (<a class="el" href="namespace_louvre.html#a20b0c262d9ef5d263888e463dfa99638">Int32</a> x) noexcept</td></tr>
<tr class="memdesc:aa70e56e4e7ccb56992207e10ebc3ac1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns the x component of the position.  <br /></td></tr>
<tr class="separator:aa70e56e4e7ccb56992207e10ebc3ac1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0612afb87d0124325f84293d40e156d" id="r_ab0612afb87d0124325f84293d40e156d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_surface.html#ab0612afb87d0124325f84293d40e156d">setY</a> (<a class="el" href="namespace_louvre.html#a20b0c262d9ef5d263888e463dfa99638">Int32</a> y) noexcept</td></tr>
<tr class="memdesc:ab0612afb87d0124325f84293d40e156d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns the y component of the position.  <br /></td></tr>
<tr class="separator:ab0612afb87d0124325f84293d40e156d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0843c1bb97b8a8cfb3faa6f75e68acd6" id="r_a0843c1bb97b8a8cfb3faa6f75e68acd6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_louvre.html#a1111511396cab1b2607e4ac55e1883a3">LPoint</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_surface.html#a0843c1bb97b8a8cfb3faa6f75e68acd6">pos</a> () const noexcept</td></tr>
<tr class="memdesc:a0843c1bb97b8a8cfb3faa6f75e68acd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Position given by the compositor.  <br /></td></tr>
<tr class="separator:a0843c1bb97b8a8cfb3faa6f75e68acd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb14a727889d37b9b51c18a9a54745eb" id="r_adb14a727889d37b9b51c18a9a54745eb"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_louvre.html#a1111511396cab1b2607e4ac55e1883a3">LPoint</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_surface.html#adb14a727889d37b9b51c18a9a54745eb">rolePos</a> () const</td></tr>
<tr class="memdesc:adb14a727889d37b9b51c18a9a54745eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Role position.  <br /></td></tr>
<tr class="separator:adb14a727889d37b9b51c18a9a54745eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9595879ae0c4def717bd69d345001ed0" id="r_a9595879ae0c4def717bd69d345001ed0"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_louvre.html#a4df5473974ae0f28f3a4967f296a657b">LSize</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_surface.html#a9595879ae0c4def717bd69d345001ed0">sizeB</a> () const noexcept</td></tr>
<tr class="memdesc:a9595879ae0c4def717bd69d345001ed0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Surface size in buffer coordinates.  <br /></td></tr>
<tr class="separator:a9595879ae0c4def717bd69d345001ed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0e9483bc8188a275f4877e55ec720b0" id="r_af0e9483bc8188a275f4877e55ec720b0"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_louvre.html#a4df5473974ae0f28f3a4967f296a657b">LSize</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_surface.html#af0e9483bc8188a275f4877e55ec720b0">size</a> () const noexcept</td></tr>
<tr class="memdesc:af0e9483bc8188a275f4877e55ec720b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Surface size in surface coordinates.  <br /></td></tr>
<tr class="separator:af0e9483bc8188a275f4877e55ec720b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4d2773573dd5a24998bdf9b617d5b26" id="r_ab4d2773573dd5a24998bdf9b617d5b26"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_louvre_1_1_l_region.html">LRegion</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_surface.html#ab4d2773573dd5a24998bdf9b617d5b26">inputRegion</a> () const noexcept</td></tr>
<tr class="memdesc:ab4d2773573dd5a24998bdf9b617d5b26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Input region in surface coordinates.  <br /></td></tr>
<tr class="separator:ab4d2773573dd5a24998bdf9b617d5b26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f8b9a31339748d52c056897bf1f9347" id="r_a4f8b9a31339748d52c056897bf1f9347"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_louvre_1_1_l_region.html">LRegion</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_surface.html#a4f8b9a31339748d52c056897bf1f9347">opaqueRegion</a> () const noexcept</td></tr>
<tr class="memdesc:a4f8b9a31339748d52c056897bf1f9347"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque region in surface coordinates.  <br /></td></tr>
<tr class="separator:a4f8b9a31339748d52c056897bf1f9347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2bb0159586017db5bbc143fa929c037" id="r_aa2bb0159586017db5bbc143fa929c037"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_louvre_1_1_l_region.html">LRegion</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_surface.html#aa2bb0159586017db5bbc143fa929c037">translucentRegion</a> () const noexcept</td></tr>
<tr class="memdesc:aa2bb0159586017db5bbc143fa929c037"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translucent region in surface coordinates.  <br /></td></tr>
<tr class="separator:aa2bb0159586017db5bbc143fa929c037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a895de383bc5ed5afc287190086c11dae" id="r_a895de383bc5ed5afc287190086c11dae"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_louvre_1_1_l_region.html">LRegion</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_surface.html#a895de383bc5ed5afc287190086c11dae">invisibleRegion</a> () const noexcept</td></tr>
<tr class="memdesc:a895de383bc5ed5afc287190086c11dae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invisible region in surface coordinates.  <br /></td></tr>
<tr class="separator:a895de383bc5ed5afc287190086c11dae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39a66ef5eff7936fcc836dd223c1537d" id="r_a39a66ef5eff7936fcc836dd223c1537d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_louvre_1_1_l_region.html">LRegion</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_surface.html#a39a66ef5eff7936fcc836dd223c1537d">damage</a> () const noexcept</td></tr>
<tr class="memdesc:a39a66ef5eff7936fcc836dd223c1537d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Damaged region in surface coordinates.  <br /></td></tr>
<tr class="separator:a39a66ef5eff7936fcc836dd223c1537d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1c82147d85831cd674c1fe4b91065bd" id="r_ad1c82147d85831cd674c1fe4b91065bd"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_louvre_1_1_l_region.html">LRegion</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_surface.html#ad1c82147d85831cd674c1fe4b91065bd">damageB</a> () const noexcept</td></tr>
<tr class="memdesc:ad1c82147d85831cd674c1fe4b91065bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Damaged region in buffer coordinates.  <br /></td></tr>
<tr class="separator:ad1c82147d85831cd674c1fe4b91065bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77d688c4b02da52e5f2fc20f85024d6b" id="r_a77d688c4b02da52e5f2fc20f85024d6b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_louvre.html#a7de5cf1aefc1d4c90dbe7dc0727654ba">LContentType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_surface.html#a77d688c4b02da52e5f2fc20f85024d6b">contentType</a> () const noexcept</td></tr>
<tr class="memdesc:a77d688c4b02da52e5f2fc20f85024d6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the content type that the surface represents.  <br /></td></tr>
<tr class="separator:a77d688c4b02da52e5f2fc20f85024d6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf7ba2250df7b9183015035fa9faf65d" id="r_adf7ba2250df7b9183015035fa9faf65d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_surface.html#adf7ba2250df7b9183015035fa9faf65d">sendOutputEnterEvent</a> (<a class="el" href="class_louvre_1_1_l_output.html">LOutput</a> *output) noexcept</td></tr>
<tr class="memdesc:adf7ba2250df7b9183015035fa9faf65d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notify the client when the surface enters an output.  <br /></td></tr>
<tr class="separator:adf7ba2250df7b9183015035fa9faf65d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ed50991c54d5cf3e12d8497be39be58" id="r_a2ed50991c54d5cf3e12d8497be39be58"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_surface.html#a2ed50991c54d5cf3e12d8497be39be58">sendOutputLeaveEvent</a> (<a class="el" href="class_louvre_1_1_l_output.html">LOutput</a> *output) noexcept</td></tr>
<tr class="memdesc:a2ed50991c54d5cf3e12d8497be39be58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notify the client when the surface leaves an output.  <br /></td></tr>
<tr class="separator:a2ed50991c54d5cf3e12d8497be39be58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05aaba26b6841b8ea133a64d1d28cb5e" id="r_a05aaba26b6841b8ea133a64d1d28cb5e"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="class_louvre_1_1_l_output.html">LOutput</a> * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_surface.html#a05aaba26b6841b8ea133a64d1d28cb5e">outputs</a> () const noexcept</td></tr>
<tr class="memdesc:a05aaba26b6841b8ea133a64d1d28cb5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Surface intersected outputs.  <br /></td></tr>
<tr class="separator:a05aaba26b6841b8ea133a64d1d28cb5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6919bf7aca736afa49a0f8733bae0e2c" id="r_a6919bf7aca736afa49a0f8733bae0e2c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_surface.html#a6919bf7aca736afa49a0f8733bae0e2c">repaintOutputs</a> () noexcept</td></tr>
<tr class="memdesc:a6919bf7aca736afa49a0f8733bae0e2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Repaints the intersected outputs.  <br /></td></tr>
<tr class="separator:a6919bf7aca736afa49a0f8733bae0e2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02788e60359675cce4314237d9aa6eb2" id="r_a02788e60359675cce4314237d9aa6eb2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_surface.html#a02788e60359675cce4314237d9aa6eb2">minimized</a> () const noexcept</td></tr>
<tr class="memdesc:a02788e60359675cce4314237d9aa6eb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimized property.  <br /></td></tr>
<tr class="separator:a02788e60359675cce4314237d9aa6eb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a842fbbf544354ca39c400d0651c27977" id="r_a842fbbf544354ca39c400d0651c27977"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_surface.html#a842fbbf544354ca39c400d0651c27977">setMinimized</a> (bool state)</td></tr>
<tr class="memdesc:a842fbbf544354ca39c400d0651c27977"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the minimized property.  <br /></td></tr>
<tr class="separator:a842fbbf544354ca39c400d0651c27977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf260d3cedc0fc116d030cc514e4b183" id="r_abf260d3cedc0fc116d030cc514e4b183"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_surface.html#abf260d3cedc0fc116d030cc514e4b183">receiveInput</a> () const noexcept</td></tr>
<tr class="memdesc:abf260d3cedc0fc116d030cc514e4b183"><td class="mdescLeft">&#160;</td><td class="mdescRight">Input capability.  <br /></td></tr>
<tr class="separator:abf260d3cedc0fc116d030cc514e4b183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e457997007c405dfb0e45d1795f574d" id="r_a4e457997007c405dfb0e45d1795f574d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_louvre.html#a20b0c262d9ef5d263888e463dfa99638">Int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_surface.html#a4e457997007c405dfb0e45d1795f574d">bufferScale</a> () const noexcept</td></tr>
<tr class="memdesc:a4e457997007c405dfb0e45d1795f574d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Buffer scale.  <br /></td></tr>
<tr class="separator:a4e457997007c405dfb0e45d1795f574d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64295697b08bc2c6cbb04ddce8ca6193" id="r_a64295697b08bc2c6cbb04ddce8ca6193"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_louvre.html#a700c2230c9a7c049255f06a9ca53b72b">LTransform</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_surface.html#a64295697b08bc2c6cbb04ddce8ca6193">bufferTransform</a> () const noexcept</td></tr>
<tr class="memdesc:a64295697b08bc2c6cbb04ddce8ca6193"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the buffer transform of the surface.  <br /></td></tr>
<tr class="separator:a64295697b08bc2c6cbb04ddce8ca6193"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa62271a8aeb6886831d1a59b5d73b1b5" id="r_aa62271a8aeb6886831d1a59b5d73b1b5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_louvre.html#a7cf2780f5c2644b34dfa6b7d2dd7a541">LRectF</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_surface.html#aa62271a8aeb6886831d1a59b5d73b1b5">srcRect</a> () const noexcept</td></tr>
<tr class="memdesc:aa62271a8aeb6886831d1a59b5d73b1b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the source rect of the surface in surface coordinates.  <br /></td></tr>
<tr class="separator:aa62271a8aeb6886831d1a59b5d73b1b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a487340b99fd4cbd2edbff299f54bdef4" id="r_a487340b99fd4cbd2edbff299f54bdef4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_surface.html#a487340b99fd4cbd2edbff299f54bdef4">hasPointerFocus</a> () const noexcept</td></tr>
<tr class="memdesc:a487340b99fd4cbd2edbff299f54bdef4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the surface has pointer focus.  <br /></td></tr>
<tr class="separator:a487340b99fd4cbd2edbff299f54bdef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac883d24eddf4ec8e2e719e4a4188caab" id="r_ac883d24eddf4ec8e2e719e4a4188caab"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_surface.html#ac883d24eddf4ec8e2e719e4a4188caab">hasKeyboardFocus</a> () const noexcept</td></tr>
<tr class="memdesc:ac883d24eddf4ec8e2e719e4a4188caab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the surface has keyboard focus.  <br /></td></tr>
<tr class="separator:ac883d24eddf4ec8e2e719e4a4188caab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdc3b3701b2671696c36b57ee501ad46" id="r_abdc3b3701b2671696c36b57ee501ad46"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_surface.html#abdc3b3701b2671696c36b57ee501ad46">hasKeyboardGrab</a> () const noexcept</td></tr>
<tr class="memdesc:abdc3b3701b2671696c36b57ee501ad46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the surface is grabbing the keyboard.  <br /></td></tr>
<tr class="separator:abdc3b3701b2671696c36b57ee501ad46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab010fd9d64d973f5d1d6fbb4ed55e974" id="r_ab010fd9d64d973f5d1d6fbb4ed55e974"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_louvre_1_1_l_texture.html">LTexture</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_surface.html#ab010fd9d64d973f5d1d6fbb4ed55e974">texture</a> () const noexcept</td></tr>
<tr class="memdesc:ab010fd9d64d973f5d1d6fbb4ed55e974"><td class="mdescLeft">&#160;</td><td class="mdescRight">OpenGL texture.  <br /></td></tr>
<tr class="separator:ab010fd9d64d973f5d1d6fbb4ed55e974"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a680a08a0cc72cef97515a99e04616ca4" id="r_a680a08a0cc72cef97515a99e04616ca4"><td class="memItemLeft" align="right" valign="top">wl_buffer *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_surface.html#a680a08a0cc72cef97515a99e04616ca4">bufferResource</a> () const noexcept</td></tr>
<tr class="memdesc:a680a08a0cc72cef97515a99e04616ca4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Native <a href="https://wayland.app/protocols/wayland#wl_buffer">wl_buffer</a> handle.  <br /></td></tr>
<tr class="separator:a680a08a0cc72cef97515a99e04616ca4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7796ca9ff7bbb71c0b62dee8c498636f" id="r_a7796ca9ff7bbb71c0b62dee8c498636f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_surface.html#a7796ca9ff7bbb71c0b62dee8c498636f">hasBuffer</a> () const noexcept</td></tr>
<tr class="memdesc:a7796ca9ff7bbb71c0b62dee8c498636f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates if the last attached buffer was NULL.  <br /></td></tr>
<tr class="separator:a7796ca9ff7bbb71c0b62dee8c498636f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d905f76e9e5dc532cada7fc8f21eedf" id="r_a2d905f76e9e5dc532cada7fc8f21eedf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_surface.html#a2d905f76e9e5dc532cada7fc8f21eedf">hasDamage</a> () const noexcept</td></tr>
<tr class="memdesc:a2d905f76e9e5dc532cada7fc8f21eedf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Presence of damage.  <br /></td></tr>
<tr class="separator:a2d905f76e9e5dc532cada7fc8f21eedf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb61c86374487dcee71b7a3eb37cd277" id="r_acb61c86374487dcee71b7a3eb37cd277"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_louvre.html#a7e8aeec7b6541935dfc6f608cd5170ce">UInt32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_surface.html#acb61c86374487dcee71b7a3eb37cd277">damageId</a> () const noexcept</td></tr>
<tr class="memdesc:acb61c86374487dcee71b7a3eb37cd277"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an ID that increments with each commit and new damage addition.  <br /></td></tr>
<tr class="separator:acb61c86374487dcee71b7a3eb37cd277"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23585ebe5d0f8117186848426ea39f0a" id="r_a23585ebe5d0f8117186848426ea39f0a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_surface.html#a23585ebe5d0f8117186848426ea39f0a">requestNextFrame</a> (bool clearDamage=true) noexcept</td></tr>
<tr class="memdesc:a23585ebe5d0f8117186848426ea39f0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">ACK the frame callback.  <br /></td></tr>
<tr class="separator:a23585ebe5d0f8117186848426ea39f0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac563c8ace44bf8111c0ee1c034e967e2" id="r_ac563c8ace44bf8111c0ee1c034e967e2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_surface.html#ac563c8ace44bf8111c0ee1c034e967e2">mapped</a> () const noexcept</td></tr>
<tr class="memdesc:ac563c8ace44bf8111c0ee1c034e967e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mapped property.  <br /></td></tr>
<tr class="separator:ac563c8ace44bf8111c0ee1c034e967e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8212dc8e0490f5dd5671187b07f0773" id="r_ac8212dc8e0490f5dd5671187b07f0773"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_surface.html#ac8212dc8e0490f5dd5671187b07f0773">preferVSync</a> () noexcept</td></tr>
<tr class="memdesc:ac8212dc8e0490f5dd5671187b07f0773"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the VSync preference of the client for this surface.  <br /></td></tr>
<tr class="separator:ac8212dc8e0490f5dd5671187b07f0773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29d4084bafe3a6b0e8d8d111bbbb58c6" id="r_a29d4084bafe3a6b0e8d8d111bbbb58c6"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="class_louvre_1_1_l_surface_view.html">LSurfaceView</a> * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_surface.html#a29d4084bafe3a6b0e8d8d111bbbb58c6">views</a> () const noexcept</td></tr>
<tr class="memdesc:a29d4084bafe3a6b0e8d8d111bbbb58c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">LSurfaceViews created for this surface.  <br /></td></tr>
<tr class="separator:a29d4084bafe3a6b0e8d8d111bbbb58c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13b08f0aa9d16303ebe83f6d090c97f2" id="r_a13b08f0aa9d16303ebe83f6d090c97f2"><td class="memItemLeft" align="right" valign="top">Protocols::Wayland::RSurface *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_surface.html#a13b08f0aa9d16303ebe83f6d090c97f2">surfaceResource</a> () const noexcept</td></tr>
<tr class="memdesc:a13b08f0aa9d16303ebe83f6d090c97f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wayland surface resource.  <br /></td></tr>
<tr class="separator:a13b08f0aa9d16303ebe83f6d090c97f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c5f0c5da7c1420989b6a2d9063c4c7" id="r_a09c5f0c5da7c1420989b6a2d9063c4c7"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Protocols::IdleInhibit::RIdleInhibitor * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_surface.html#a09c5f0c5da7c1420989b6a2d9063c4c7">idleInhibitorResources</a> () const noexcept</td></tr>
<tr class="memdesc:a09c5f0c5da7c1420989b6a2d9063c4c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Idle Inhibitor Resources.  <br /></td></tr>
<tr class="separator:a09c5f0c5da7c1420989b6a2d9063c4c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a030bc63c24e4bb205344939c91b2ba26" id="r_a030bc63c24e4bb205344939c91b2ba26"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_louvre_1_1_l_client.html">LClient</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_surface.html#a030bc63c24e4bb205344939c91b2ba26">client</a> () const noexcept</td></tr>
<tr class="memdesc:a030bc63c24e4bb205344939c91b2ba26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Client owner of the surface.  <br /></td></tr>
<tr class="separator:a030bc63c24e4bb205344939c91b2ba26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96a82bfdfd9c2b81c916f351340d5e17" id="r_a96a82bfdfd9c2b81c916f351340d5e17"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_louvre_1_1_l_surface.html">LSurface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_surface.html#a96a82bfdfd9c2b81c916f351340d5e17">parent</a> () const noexcept</td></tr>
<tr class="memdesc:a96a82bfdfd9c2b81c916f351340d5e17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parent surface.  <br /></td></tr>
<tr class="separator:a96a82bfdfd9c2b81c916f351340d5e17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eef6f8bca2936636a2da7c63c2a561b" id="r_a5eef6f8bca2936636a2da7c63c2a561b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_louvre_1_1_l_surface.html">LSurface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_surface.html#a5eef6f8bca2936636a2da7c63c2a561b">topmostParent</a> () const noexcept</td></tr>
<tr class="memdesc:a5eef6f8bca2936636a2da7c63c2a561b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Topmost parent of the surface.  <br /></td></tr>
<tr class="separator:a5eef6f8bca2936636a2da7c63c2a561b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1051b97fa6b0d82a2f20be803620dd4" id="r_ad1051b97fa6b0d82a2f20be803620dd4"><td class="memItemLeft" align="right" valign="top">const std::list&lt; <a class="el" href="class_louvre_1_1_l_surface.html">LSurface</a> * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_surface.html#ad1051b97fa6b0d82a2f20be803620dd4">children</a> () const noexcept</td></tr>
<tr class="memdesc:ad1051b97fa6b0d82a2f20be803620dd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Child surfaces.  <br /></td></tr>
<tr class="separator:ad1051b97fa6b0d82a2f20be803620dd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5342952f29ba9c4531eeca2e6be86af" id="r_ac5342952f29ba9c4531eeca2e6be86af"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_surface.html#ac5342952f29ba9c4531eeca2e6be86af">isPopupSubchild</a> () const noexcept</td></tr>
<tr class="memdesc:ac5342952f29ba9c4531eeca2e6be86af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the surface is a subchild of a popup.  <br /></td></tr>
<tr class="separator:ac5342952f29ba9c4531eeca2e6be86af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a707a9a4fc34daabd4761ea1fed2af746" id="r_a707a9a4fc34daabd4761ea1fed2af746"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_surface.html#a707a9a4fc34daabd4761ea1fed2af746">hasPopupSubchild</a> () const noexcept</td></tr>
<tr class="memdesc:a707a9a4fc34daabd4761ea1fed2af746"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the surface has a subchild popup.  <br /></td></tr>
<tr class="separator:a707a9a4fc34daabd4761ea1fed2af746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0c74531a689b7ed87bb54cb8054254b" id="r_ad0c74531a689b7ed87bb54cb8054254b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_surface.html#ad0c74531a689b7ed87bb54cb8054254b">isSubchildOf</a> (<a class="el" href="class_louvre_1_1_l_surface.html">LSurface</a> *<a class="el" href="class_louvre_1_1_l_surface.html#a96a82bfdfd9c2b81c916f351340d5e17">parent</a>) const noexcept</td></tr>
<tr class="memdesc:ad0c74531a689b7ed87bb54cb8054254b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the surface is a subchild of the specified parent surface.  <br /></td></tr>
<tr class="separator:ad0c74531a689b7ed87bb54cb8054254b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9c27f2d106edb222bc33c4bfc384f58" id="r_ad9c27f2d106edb222bc33c4bfc384f58"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_surface.html#ad9c27f2d106edb222bc33c4bfc384f58">raise</a> ()</td></tr>
<tr class="memdesc:ad9c27f2d106edb222bc33c4bfc384f58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raises the surface within its current layer.  <br /></td></tr>
<tr class="separator:ad9c27f2d106edb222bc33c4bfc384f58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a011aa286f1843209432e721d51304810" id="r_a011aa286f1843209432e721d51304810"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_louvre_1_1_l_surface.html">LSurface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_surface.html#a011aa286f1843209432e721d51304810">prevSurface</a> () const noexcept</td></tr>
<tr class="memdesc:a011aa286f1843209432e721d51304810"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the previous surface in the compositor surfaces list (<a class="el" href="class_louvre_1_1_l_compositor.html#a02b82f9077f93ed98b9fdd2c963014e8" title="Gets a list of all surfaces created by clients.">LCompositor::surfaces()</a>).  <br /></td></tr>
<tr class="separator:a011aa286f1843209432e721d51304810"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2df3baf64b05fa8b629b3eaefc59c5d" id="r_aa2df3baf64b05fa8b629b3eaefc59c5d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_louvre_1_1_l_surface.html">LSurface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_surface.html#aa2df3baf64b05fa8b629b3eaefc59c5d">nextSurface</a> () const noexcept</td></tr>
<tr class="memdesc:aa2df3baf64b05fa8b629b3eaefc59c5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the next surface in the compositor surfaces list (<a class="el" href="class_louvre_1_1_l_compositor.html#a02b82f9077f93ed98b9fdd2c963014e8" title="Gets a list of all surfaces created by clients.">LCompositor::surfaces()</a>).  <br /></td></tr>
<tr class="separator:aa2df3baf64b05fa8b629b3eaefc59c5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_louvre_1_1_l_factory_object"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_louvre_1_1_l_factory_object')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_louvre_1_1_l_factory_object.html">LFactoryObject</a></td></tr>
<tr class="memitem:a3bd9479f72aa3d1df19e3a247adcf804 inherit pub_methods_class_louvre_1_1_l_factory_object" id="r_a3bd9479f72aa3d1df19e3a247adcf804"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_louvre_1_1_l_factory_object.html#ad96f0a085c6542bc6c83459a88bfb560">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_factory_object.html#a3bd9479f72aa3d1df19e3a247adcf804">factoryObjectType</a> () const noexcept</td></tr>
<tr class="memdesc:a3bd9479f72aa3d1df19e3a247adcf804 inherit pub_methods_class_louvre_1_1_l_factory_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the base factory object type.  <br /></td></tr>
<tr class="separator:a3bd9479f72aa3d1df19e3a247adcf804 inherit pub_methods_class_louvre_1_1_l_factory_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_louvre_1_1_l_object"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_louvre_1_1_l_object')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_louvre_1_1_l_object.html">LObject</a></td></tr>
<tr class="memitem:a5e0338a5b44c364d6b13da9a71ada022 inherit pub_methods_class_louvre_1_1_l_object" id="r_a5e0338a5b44c364d6b13da9a71ada022"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_object.html#a5e0338a5b44c364d6b13da9a71ada022">LObject</a> (const <a class="el" href="class_louvre_1_1_l_object.html">LObject</a> &amp;) noexcept</td></tr>
<tr class="memdesc:a5e0338a5b44c364d6b13da9a71ada022 inherit pub_methods_class_louvre_1_1_l_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <br /></td></tr>
<tr class="separator:a5e0338a5b44c364d6b13da9a71ada022 inherit pub_methods_class_louvre_1_1_l_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2d1ca3cf8daa14eec5716367c8f7cc5 inherit pub_methods_class_louvre_1_1_l_object" id="r_ab2d1ca3cf8daa14eec5716367c8f7cc5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_louvre_1_1_l_object.html">LObject</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_object.html#ab2d1ca3cf8daa14eec5716367c8f7cc5">operator=</a> (const <a class="el" href="class_louvre_1_1_l_object.html">LObject</a> &amp;) noexcept</td></tr>
<tr class="memdesc:ab2d1ca3cf8daa14eec5716367c8f7cc5 inherit pub_methods_class_louvre_1_1_l_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator (each object has its own individual <a class="el" href="class_louvre_1_1_l_weak.html" title="Weak reference to an LObject.">LWeak</a> reference count).  <br /></td></tr>
<tr class="separator:ab2d1ca3cf8daa14eec5716367c8f7cc5 inherit pub_methods_class_louvre_1_1_l_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaa9f556f19f069b6a81ff7ac7038962 inherit pub_methods_class_louvre_1_1_l_object" id="r_aaaa9f556f19f069b6a81ff7ac7038962"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_object.html#aaaa9f556f19f069b6a81ff7ac7038962">setUserData</a> (<a class="el" href="namespace_louvre.html#aae7f8c18b78885d886911ca3c22fac6a">UIntPtr</a> data) const noexcept</td></tr>
<tr class="memdesc:aaaa9f556f19f069b6a81ff7ac7038962 inherit pub_methods_class_louvre_1_1_l_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store an unsigned integer value/pointer.  <br /></td></tr>
<tr class="separator:aaaa9f556f19f069b6a81ff7ac7038962 inherit pub_methods_class_louvre_1_1_l_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca4673ef20b24d63618e7d9061c66c6f inherit pub_methods_class_louvre_1_1_l_object" id="r_aca4673ef20b24d63618e7d9061c66c6f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_louvre.html#aae7f8c18b78885d886911ca3c22fac6a">UIntPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_object.html#aca4673ef20b24d63618e7d9061c66c6f">userData</a> () const noexcept</td></tr>
<tr class="memdesc:aca4673ef20b24d63618e7d9061c66c6f inherit pub_methods_class_louvre_1_1_l_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the stored unsigned integer value/pointer.  <br /></td></tr>
<tr class="separator:aca4673ef20b24d63618e7d9061c66c6f inherit pub_methods_class_louvre_1_1_l_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Roles</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Functionality related to roles. </p>
</td></tr>
<tr class="memitem:a740a064ccce3e2cd36c7c843d346890a" id="r_a740a064ccce3e2cd36c7c843d346890a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_louvre_1_1_l_surface.html#a03bbf64580744af6d161dc054d3fb1fd">Role</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_surface.html#a740a064ccce3e2cd36c7c843d346890a">roleId</a> () const noexcept</td></tr>
<tr class="memdesc:a740a064ccce3e2cd36c7c843d346890a"><td class="mdescLeft">&#160;</td><td class="mdescRight">ID of the role.  <br /></td></tr>
<tr class="separator:a740a064ccce3e2cd36c7c843d346890a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcb0a0c7570cedec2cc38822943a7fff" id="r_adcb0a0c7570cedec2cc38822943a7fff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_louvre_1_1_l_base_surface_role.html">LBaseSurfaceRole</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_surface.html#adcb0a0c7570cedec2cc38822943a7fff">role</a> () const noexcept</td></tr>
<tr class="memdesc:adcb0a0c7570cedec2cc38822943a7fff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Surface role.  <br /></td></tr>
<tr class="separator:adcb0a0c7570cedec2cc38822943a7fff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2486948f8e54c31d79de22f79766d9ea" id="r_a2486948f8e54c31d79de22f79766d9ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_louvre_1_1_l_cursor_role.html">LCursorRole</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_surface.html#a2486948f8e54c31d79de22f79766d9ea">cursorRole</a> () const noexcept</td></tr>
<tr class="memdesc:a2486948f8e54c31d79de22f79766d9ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cursor role.  <br /></td></tr>
<tr class="separator:a2486948f8e54c31d79de22f79766d9ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeabbba055c54e5881a8225a63a6b4c7" id="r_aaeabbba055c54e5881a8225a63a6b4c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_louvre_1_1_l_d_n_d_icon_role.html">LDNDIconRole</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_surface.html#aaeabbba055c54e5881a8225a63a6b4c7">dndIcon</a> () const noexcept</td></tr>
<tr class="memdesc:aaeabbba055c54e5881a8225a63a6b4c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drag &amp; Drop icon role.  <br /></td></tr>
<tr class="separator:aaeabbba055c54e5881a8225a63a6b4c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a744809727c631248ae26aae91fa08a6d" id="r_a744809727c631248ae26aae91fa08a6d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_louvre_1_1_l_toplevel_role.html">LToplevelRole</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_surface.html#a744809727c631248ae26aae91fa08a6d">toplevel</a> () const noexcept</td></tr>
<tr class="memdesc:a744809727c631248ae26aae91fa08a6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toplevel role.  <br /></td></tr>
<tr class="separator:a744809727c631248ae26aae91fa08a6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fbab4b1f9f0d60b9a84d53ee4b25c43" id="r_a5fbab4b1f9f0d60b9a84d53ee4b25c43"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_louvre_1_1_l_popup_role.html">LPopupRole</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_surface.html#a5fbab4b1f9f0d60b9a84d53ee4b25c43">popup</a> () const noexcept</td></tr>
<tr class="memdesc:a5fbab4b1f9f0d60b9a84d53ee4b25c43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Popup role.  <br /></td></tr>
<tr class="separator:a5fbab4b1f9f0d60b9a84d53ee4b25c43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e301296e7228a07b5c450fbf8cbd2e0" id="r_a8e301296e7228a07b5c450fbf8cbd2e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_louvre_1_1_l_subsurface_role.html">LSubsurfaceRole</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_surface.html#a8e301296e7228a07b5c450fbf8cbd2e0">subsurface</a> () const noexcept</td></tr>
<tr class="memdesc:a8e301296e7228a07b5c450fbf8cbd2e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subsurface role.  <br /></td></tr>
<tr class="separator:a8e301296e7228a07b5c450fbf8cbd2e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a503ccd23df24f76263e3d7d597b22380" id="r_a503ccd23df24f76263e3d7d597b22380"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_louvre_1_1_l_session_lock_role.html">LSessionLockRole</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_surface.html#a503ccd23df24f76263e3d7d597b22380">sessionLock</a> () const noexcept</td></tr>
<tr class="memdesc:a503ccd23df24f76263e3d7d597b22380"><td class="mdescLeft">&#160;</td><td class="mdescRight">Session Lock role.  <br /></td></tr>
<tr class="separator:a503ccd23df24f76263e3d7d597b22380"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0893cf0c3ddae63514996e5450e9c859" id="r_a0893cf0c3ddae63514996e5450e9c859"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_louvre_1_1_l_layer_role.html">LLayerRole</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_surface.html#a0893cf0c3ddae63514996e5450e9c859">layerRole</a> () const noexcept</td></tr>
<tr class="memdesc:a0893cf0c3ddae63514996e5450e9c859"><td class="mdescLeft">&#160;</td><td class="mdescRight">Layer role.  <br /></td></tr>
<tr class="separator:a0893cf0c3ddae63514996e5450e9c859"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Pointer Constraints</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="pointer_constraints"></a></p>
<p>Functionality related to pointer constraints.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_louvre_1_1_l_pointer.html#a29ef6f5341dfdf59b55132387def3e1a" title="Pointer move event generated by the input backend.">LPointer::pointerMoveEvent()</a> </dd></dl>
</td></tr>
<tr class="memitem:aff2b39d0b63be670058e1f85cb3a95ee" id="r_aff2b39d0b63be670058e1f85cb3a95ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_louvre_1_1_l_surface.html#a6251d534fc6198bc897fd8a089847008">PointerConstraintMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_surface.html#aff2b39d0b63be670058e1f85cb3a95ee">pointerConstraintMode</a> () const noexcept</td></tr>
<tr class="memdesc:aff2b39d0b63be670058e1f85cb3a95ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current pointer constraint mode.  <br /></td></tr>
<tr class="separator:aff2b39d0b63be670058e1f85cb3a95ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a283c520197dfb0da059145f32f0332e1" id="r_a283c520197dfb0da059145f32f0332e1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_surface.html#a283c520197dfb0da059145f32f0332e1">pointerConstraintModeChanged</a> ()</td></tr>
<tr class="memdesc:a283c520197dfb0da059145f32f0332e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoked when <a class="el" href="class_louvre_1_1_l_surface.html#aff2b39d0b63be670058e1f85cb3a95ee" title="Current pointer constraint mode.">pointerConstraintMode()</a> changes.  <br /></td></tr>
<tr class="separator:a283c520197dfb0da059145f32f0332e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f696343765259838338bb091350f5d8" id="r_a6f696343765259838338bb091350f5d8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_louvre_1_1_l_region.html">LRegion</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_surface.html#a6f696343765259838338bb091350f5d8">pointerConstraintRegion</a> () const noexcept</td></tr>
<tr class="memdesc:a6f696343765259838338bb091350f5d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Region within the surface where the pointer should be locked or confined if pointer constraint is enabled.  <br /></td></tr>
<tr class="separator:a6f696343765259838338bb091350f5d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12e808df10a615440cc3800b0748bc28" id="r_a12e808df10a615440cc3800b0748bc28"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_surface.html#a12e808df10a615440cc3800b0748bc28">pointerConstraintRegionChanged</a> ()</td></tr>
<tr class="memdesc:a12e808df10a615440cc3800b0748bc28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notifies a change in <a class="el" href="class_louvre_1_1_l_surface.html#a6f696343765259838338bb091350f5d8" title="Region within the surface where the pointer should be locked or confined if pointer constraint is ena...">pointerConstraintRegion()</a>.  <br /></td></tr>
<tr class="separator:a12e808df10a615440cc3800b0748bc28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa49cb89a754457f7bc4ebc014c87284c" id="r_aa49cb89a754457f7bc4ebc014c87284c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_surface.html#aa49cb89a754457f7bc4ebc014c87284c">enablePointerConstraint</a> (bool enabled)</td></tr>
<tr class="memdesc:aa49cb89a754457f7bc4ebc014c87284c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notifies the client if the pointer is constrained.  <br /></td></tr>
<tr class="separator:aa49cb89a754457f7bc4ebc014c87284c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb2502acb54891e6e659427a40eaa966" id="r_aeb2502acb54891e6e659427a40eaa966"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_surface.html#aeb2502acb54891e6e659427a40eaa966">pointerConstraintEnabled</a> () const noexcept</td></tr>
<tr class="memdesc:aeb2502acb54891e6e659427a40eaa966"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates if the compositor enabled the pointer constraint for this surface.  <br /></td></tr>
<tr class="separator:aeb2502acb54891e6e659427a40eaa966"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d958c32d8d65ec5c132d572b600f374" id="r_a2d958c32d8d65ec5c132d572b600f374"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_louvre.html#a5517b50113b8b1757430425847186df5">LPointF</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_surface.html#a2d958c32d8d65ec5c132d572b600f374">lockedPointerPosHint</a> () const noexcept</td></tr>
<tr class="memdesc:a2d958c32d8d65ec5c132d572b600f374"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates where the pointer currently is within the surface if the pointer <a class="el" href="class_louvre_1_1_l_surface.html#a6251d534fc6198bc897fd8a089847008a2d2c1d495d2836c20c94c46758ddb504">Lock</a> constrain mode is enabled.  <br /></td></tr>
<tr class="separator:a2d958c32d8d65ec5c132d572b600f374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a584fb32350cfbb659dc6c80993bb2853" id="r_a584fb32350cfbb659dc6c80993bb2853"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_surface.html#a584fb32350cfbb659dc6c80993bb2853">lockedPointerPosHintChanged</a> ()</td></tr>
<tr class="memdesc:a584fb32350cfbb659dc6c80993bb2853"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notifies a change in <a class="el" href="class_louvre_1_1_l_surface.html#a2d958c32d8d65ec5c132d572b600f374" title="Indicates where the pointer currently is within the surface if the pointer Lock constrain mode is ena...">lockedPointerPosHint()</a>.  <br /></td></tr>
<tr class="separator:a584fb32350cfbb659dc6c80993bb2853"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Virtual Methods</h2></td></tr>
<tr class="memitem:a7a1f368d2e0c75ff45866f9d0dd37cdb" id="r_a7a1f368d2e0c75ff45866f9d0dd37cdb"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_surface.html#a7a1f368d2e0c75ff45866f9d0dd37cdb">damageChanged</a> ()</td></tr>
<tr class="memdesc:a7a1f368d2e0c75ff45866f9d0dd37cdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notifies about new damages on the surface.  <br /></td></tr>
<tr class="separator:a7a1f368d2e0c75ff45866f9d0dd37cdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afde528457065bf8c34063d1e04261e1e" id="r_afde528457065bf8c34063d1e04261e1e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_surface.html#afde528457065bf8c34063d1e04261e1e">roleChanged</a> (<a class="el" href="class_louvre_1_1_l_base_surface_role.html">LBaseSurfaceRole</a> *prevRole)</td></tr>
<tr class="memdesc:afde528457065bf8c34063d1e04261e1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notifies a change in role.  <br /></td></tr>
<tr class="separator:afde528457065bf8c34063d1e04261e1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2148e1e9be424c7b640f56f96bd7083f" id="r_a2148e1e9be424c7b640f56f96bd7083f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_surface.html#a2148e1e9be424c7b640f56f96bd7083f">parentChanged</a> ()</td></tr>
<tr class="memdesc:a2148e1e9be424c7b640f56f96bd7083f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notifies a change of parent.  <br /></td></tr>
<tr class="separator:a2148e1e9be424c7b640f56f96bd7083f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1150cf016134af22675fdb93b240ee78" id="r_a1150cf016134af22675fdb93b240ee78"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_surface.html#a1150cf016134af22675fdb93b240ee78">mappingChanged</a> ()</td></tr>
<tr class="memdesc:a1150cf016134af22675fdb93b240ee78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notifies of a change in the <a class="el" href="class_louvre_1_1_l_surface.html#ac563c8ace44bf8111c0ee1c034e967e2" title="Mapped property.">mapped()</a> property.  <br /></td></tr>
<tr class="separator:a1150cf016134af22675fdb93b240ee78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ffb06fa9c6e119757c8294be05f927f" id="r_a7ffb06fa9c6e119757c8294be05f927f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_surface.html#a7ffb06fa9c6e119757c8294be05f927f">bufferScaleChanged</a> ()</td></tr>
<tr class="memdesc:a7ffb06fa9c6e119757c8294be05f927f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notifies a change in buffer scale.  <br /></td></tr>
<tr class="separator:a7ffb06fa9c6e119757c8294be05f927f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac241183ff377da9e7ee255fb57d5f84b" id="r_ac241183ff377da9e7ee255fb57d5f84b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_surface.html#ac241183ff377da9e7ee255fb57d5f84b">bufferTransformChanged</a> ()</td></tr>
<tr class="memdesc:ac241183ff377da9e7ee255fb57d5f84b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notifies a change of the buffer transform.  <br /></td></tr>
<tr class="separator:ac241183ff377da9e7ee255fb57d5f84b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57442cc8cc416d6fc061dea6ff22df5e" id="r_a57442cc8cc416d6fc061dea6ff22df5e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_surface.html#a57442cc8cc416d6fc061dea6ff22df5e">bufferSizeChanged</a> ()</td></tr>
<tr class="memdesc:a57442cc8cc416d6fc061dea6ff22df5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notifies a change in buffer dimensions.  <br /></td></tr>
<tr class="separator:a57442cc8cc416d6fc061dea6ff22df5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22170d484e8ddd9d75d12e21540b296e" id="r_a22170d484e8ddd9d75d12e21540b296e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_surface.html#a22170d484e8ddd9d75d12e21540b296e">sizeChanged</a> ()</td></tr>
<tr class="memdesc:a22170d484e8ddd9d75d12e21540b296e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notifies a change in the surface size.  <br /></td></tr>
<tr class="separator:a22170d484e8ddd9d75d12e21540b296e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2441a40331625612021248ff4621a899" id="r_a2441a40331625612021248ff4621a899"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_surface.html#a2441a40331625612021248ff4621a899">srcRectChanged</a> ()</td></tr>
<tr class="memdesc:a2441a40331625612021248ff4621a899"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notifies a change in the src rect.  <br /></td></tr>
<tr class="separator:a2441a40331625612021248ff4621a899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2df6fb09a18b12ef7bb2d0efe0157271" id="r_a2df6fb09a18b12ef7bb2d0efe0157271"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_surface.html#a2df6fb09a18b12ef7bb2d0efe0157271">opaqueRegionChanged</a> ()</td></tr>
<tr class="memdesc:a2df6fb09a18b12ef7bb2d0efe0157271"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notifies of a change in the opaque region.  <br /></td></tr>
<tr class="separator:a2df6fb09a18b12ef7bb2d0efe0157271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad67a8f1c127c51a1c528c9f27ec76d6c" id="r_ad67a8f1c127c51a1c528c9f27ec76d6c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_surface.html#ad67a8f1c127c51a1c528c9f27ec76d6c">invisibleRegionChanged</a> ()</td></tr>
<tr class="memdesc:ad67a8f1c127c51a1c528c9f27ec76d6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notifies of a change in the invisible region.  <br /></td></tr>
<tr class="separator:ad67a8f1c127c51a1c528c9f27ec76d6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66eeb734d7a1a448557a297efd91e35c" id="r_a66eeb734d7a1a448557a297efd91e35c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_surface.html#a66eeb734d7a1a448557a297efd91e35c">inputRegionChanged</a> ()</td></tr>
<tr class="memdesc:a66eeb734d7a1a448557a297efd91e35c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notifies of a change in the input region.  <br /></td></tr>
<tr class="separator:a66eeb734d7a1a448557a297efd91e35c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac30d215881c074b2cab7d90e5d54e149" id="r_ac30d215881c074b2cab7d90e5d54e149"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_surface.html#ac30d215881c074b2cab7d90e5d54e149">orderChanged</a> ()</td></tr>
<tr class="memdesc:ac30d215881c074b2cab7d90e5d54e149"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notifies when the surface changes its position in the surfaces list.  <br /></td></tr>
<tr class="separator:ac30d215881c074b2cab7d90e5d54e149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6103051c305f39465b025ff9c15c2323" id="r_a6103051c305f39465b025ff9c15c2323"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_surface.html#a6103051c305f39465b025ff9c15c2323">requestedRepaint</a> ()</td></tr>
<tr class="memdesc:a6103051c305f39465b025ff9c15c2323"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request a repaint of the surface.  <br /></td></tr>
<tr class="separator:a6103051c305f39465b025ff9c15c2323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6160ec0911aec529a68eb827717bb9f" id="r_af6160ec0911aec529a68eb827717bb9f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_surface.html#af6160ec0911aec529a68eb827717bb9f">minimizedChanged</a> ()</td></tr>
<tr class="memdesc:af6160ec0911aec529a68eb827717bb9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notifies about changes in the minimized state of the surface.  <br /></td></tr>
<tr class="separator:af6160ec0911aec529a68eb827717bb9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17d11b10d54f0f54fbb8ad6020c135f6" id="r_a17d11b10d54f0f54fbb8ad6020c135f6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_surface.html#a17d11b10d54f0f54fbb8ad6020c135f6">preferVSyncChanged</a> ()</td></tr>
<tr class="memdesc:a17d11b10d54f0f54fbb8ad6020c135f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notifies about changes in the VSync preference.  <br /></td></tr>
<tr class="separator:a17d11b10d54f0f54fbb8ad6020c135f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc79b942fea173935ef3bff4de7406f1" id="r_adc79b942fea173935ef3bff4de7406f1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_surface.html#adc79b942fea173935ef3bff4de7406f1">contentTypeChanged</a> ()</td></tr>
<tr class="memdesc:adc79b942fea173935ef3bff4de7406f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notifies a change of content type.  <br /></td></tr>
<tr class="separator:adc79b942fea173935ef3bff4de7406f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a810cbeacbbe17335c0f6f5d1ba60869a" id="r_a810cbeacbbe17335c0f6f5d1ba60869a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_surface.html#a810cbeacbbe17335c0f6f5d1ba60869a">layerChanged</a> ()</td></tr>
<tr class="memdesc:a810cbeacbbe17335c0f6f5d1ba60869a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notified a c.  <br /></td></tr>
<tr class="separator:a810cbeacbbe17335c0f6f5d1ba60869a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_class_louvre_1_1_l_object"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_class_louvre_1_1_l_object')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="class_louvre_1_1_l_object.html">LObject</a></td></tr>
<tr class="memitem:a923dd55b0ee0726e290f2b96fda86863 inherit pro_methods_class_louvre_1_1_l_object" id="r_a923dd55b0ee0726e290f2b96fda86863"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_object.html#a923dd55b0ee0726e290f2b96fda86863">LObject</a> () noexcept=default</td></tr>
<tr class="memdesc:a923dd55b0ee0726e290f2b96fda86863 inherit pro_methods_class_louvre_1_1_l_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor of the <a class="el" href="class_louvre_1_1_l_object.html" title="Base class for Louvre objects.">LObject</a> class.  <br /></td></tr>
<tr class="separator:a923dd55b0ee0726e290f2b96fda86863 inherit pro_methods_class_louvre_1_1_l_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab82f01a547b3363a86304ad285774a3f inherit pro_methods_class_louvre_1_1_l_object" id="r_ab82f01a547b3363a86304ad285774a3f"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_object.html#ab82f01a547b3363a86304ad285774a3f">~LObject</a> () noexcept</td></tr>
<tr class="memdesc:ab82f01a547b3363a86304ad285774a3f inherit pro_methods_class_louvre_1_1_l_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor of the <a class="el" href="class_louvre_1_1_l_object.html" title="Base class for Louvre objects.">LObject</a> class.  <br /></td></tr>
<tr class="separator:ab82f01a547b3363a86304ad285774a3f inherit pro_methods_class_louvre_1_1_l_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af564f691ad42dec99924f2889175f323 inherit pro_methods_class_louvre_1_1_l_object" id="r_af564f691ad42dec99924f2889175f323"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_object.html#af564f691ad42dec99924f2889175f323">notifyDestruction</a> () noexcept</td></tr>
<tr class="memdesc:af564f691ad42dec99924f2889175f323 inherit pro_methods_class_louvre_1_1_l_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notifies the object destruction.  <br /></td></tr>
<tr class="separator:af564f691ad42dec99924f2889175f323 inherit pro_methods_class_louvre_1_1_l_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A client "window". </p>
<p><a class="anchor" id="lsurface_detailed"></a> In the context of Wayland, surfaces can be thought of as analogous to "application windows." Each surface possesses attributes including position, size, buffer, input region, opaque region, damage region, and a designated role. Clients are responsible for rendering the content of their windows onto a buffer and subsequently transmitting it to the compositor, which is then displayed on the screen.</p>
<h1><a class="anchor" id="Roles"></a>
Roles</h1>
<p>Surfaces on their own lack functionality. This is where roles come into play, as they establish the guidelines for how the compositor interacts with them, dictating their ordering, positioning, geometry interpretation, and more.<br  />
 <a class="el" href="namespace_louvre.html" title="Namespaces.">Louvre</a> currently implements the following roles:</p>
<ul>
<li><a class="el" href="class_louvre_1_1_l_cursor_role.html" title="Cursor role for surfaces.">LCursorRole</a> (derived from the Wayland protocol)</li>
<li><a class="el" href="class_louvre_1_1_l_d_n_d_icon_role.html" title="Drag &amp; drop icon role for surfaces.">LDNDIconRole</a> (derived from the Wayland protocol)</li>
<li><a class="el" href="class_louvre_1_1_l_subsurface_role.html" title="Subsurface role for surfaces.">LSubsurfaceRole</a> (derived from the Wayland protocol)</li>
<li><a class="el" href="class_louvre_1_1_l_popup_role.html" title="Popup role for surfaces.">LPopupRole</a> (derived from the XDG Shell protocol)</li>
<li><a class="el" href="class_louvre_1_1_l_toplevel_role.html" title="Toplevel role for surfaces.">LToplevelRole</a> (derived from the XDG Shell protocol)</li>
<li><a class="el" href="class_louvre_1_1_l_session_lock_role.html" title="Surface displayed during a session lock.">LSessionLockRole</a> (derived from the Session Lock protocol)</li>
<li><a class="el" href="class_louvre_1_1_l_layer_role.html" title="Layer role for surfaces.">LLayerRole</a> (derived from the Layer Shell protocol)</li>
</ul>
<p>The surface's role can be accessed using the <a class="el" href="class_louvre_1_1_l_surface.html#adcb0a0c7570cedec2cc38822943a7fff" title="Surface role.">role()</a> method or, if you already know the role in advance or wish to verify whether it matches one of them, through the dedicated functions: <a class="el" href="class_louvre_1_1_l_surface.html#a2486948f8e54c31d79de22f79766d9ea" title="Cursor role.">cursorRole()</a>, <a class="el" href="class_louvre_1_1_l_surface.html#aaeabbba055c54e5881a8225a63a6b4c7" title="Drag &amp; Drop icon role.">dndIcon()</a>, <a class="el" href="class_louvre_1_1_l_surface.html#a5fbab4b1f9f0d60b9a84d53ee4b25c43" title="Popup role.">popup()</a>, <a class="el" href="class_louvre_1_1_l_surface.html#a744809727c631248ae26aae91fa08a6d" title="Toplevel role.">toplevel()</a>, <a class="el" href="class_louvre_1_1_l_surface.html#a8e301296e7228a07b5c450fbf8cbd2e0" title="Subsurface role.">subsurface()</a>, etc.<br  />
Typically, once a role is assigned, it remains consistent throughout the surface's entire lifecycle.<br  />
You have the option to monitor changes in the surface's role by utilizing the <a class="el" href="class_louvre_1_1_l_surface.html#afde528457065bf8c34063d1e04261e1e" title="Notifies a change in role.">roleChanged()</a> event.<br  />
 To create additional roles beyond those offered by the library you can use the <a class="el" href="class_louvre_1_1_l_base_surface_role.html" title="Base class for surface roles.">LBaseSurfaceRole</a> class.</p>
<h1><a class="anchor" id="Mapping"></a>
Mapping</h1>
<p>In order to render a surface, several conditions must be met, such as having an assigned role and a non-null buffer().<br  />
To determine if a surface is renderable, you can use the <a class="el" href="class_louvre_1_1_l_surface.html#ac563c8ace44bf8111c0ee1c034e967e2" title="Mapped property.">mapped()</a> property. This property is <code>false</code> when the client wants to hide it through some rule of its role, or when the necessary conditions for it to be rendered are not met.<br  />
 </p>
<h1><a class="anchor" id="Callbacks"></a>
Callbacks</h1>
<p>To ensure that surfaces don't update their content more frequently than the refresh rate of the output (<a class="el" href="class_louvre_1_1_l_output.html" title="A display rendering interface.">LOutput</a>) they are displayed on, or in scenarios where they are obscured by other surfaces, callbacks are employed. Clients generate a callback resource and await the compositor's acknowledgment, signaling an optimal time to render the subsequent surface frame. To acknowledge the callback of a surface, use <a class="el" href="class_louvre_1_1_l_surface.html#a23585ebe5d0f8117186848426ea39f0a" title="ACK the frame callback.">requestNextFrame()</a>.</p>
<dl class="section warning"><dt>Warning</dt><dd>Calling <a class="el" href="class_louvre_1_1_l_surface.html#a23585ebe5d0f8117186848426ea39f0a" title="ACK the frame callback.">requestNextFrame()</a> clears the current damage region of the surface.</dd></dl>
<h1><a class="anchor" id="Buffer"></a>
Buffer</h1>
<p>The library automatically converts the surface's buffer into an object that can be used by the selected renderer.<br  />
Since the library currently only offers OpenGL ES 2.0 renderer, the buffer is converted to an OpenGL texture that can be accessed with <a class="el" href="class_louvre_1_1_l_surface.html#ab010fd9d64d973f5d1d6fbb4ed55e974" title="OpenGL texture.">texture()</a>.<br  />
It is also possible to access the native Wayland resource of the buffer with <a class="el" href="class_louvre_1_1_l_surface.html#a680a08a0cc72cef97515a99e04616ca4" title="Native wl_buffer handle.">bufferResource()</a>.</p>
<h1><a class="anchor" id="Damage"></a>
Damage</h1>
<p>To avoid the compositor redrawing the entire area of a surface on each frame, clients notify which regions have changed on their buffers, known as damage. You can access this region with <a class="el" href="class_louvre_1_1_l_surface.html#a39a66ef5eff7936fcc836dd223c1537d" title="Damaged region in surface coordinates.">damage()</a> or <a class="el" href="class_louvre_1_1_l_surface.html#ad1c82147d85831cd674c1fe4b91065bd" title="Damaged region in buffer coordinates.">damageB()</a> and be notified when it changes with the <a class="el" href="class_louvre_1_1_l_surface.html#a7a1f368d2e0c75ff45866f9d0dd37cdb" title="Notifies about new damages on the surface.">damageChanged()</a> event.<br  />
 </p><dl class="section note"><dt>Note</dt><dd>The default implementation of <a class="el" href="class_louvre_1_1_l_output.html#a0569e991ee4c6e4242578aca6d999741" title="Paint Event.">LOutput::paintGL()</a> does not take into account the damage of surfaces, and therefore it renders in an inefficient way. It's recommended to use the <a class="el" href="class_louvre_1_1_l_scene.html" title="Scene.">LScene</a> and <a class="el" href="class_louvre_1_1_l_view.html" title="Base class for LScene views.">LView</a> system for rendering, which efficiently repaints only what is necessary during each frame. If you want to see an example of efficient rendering, check the <a class="el" href="examples_page.html#louvre-views-example">louvre-views</a> or <a class="el" href="examples_page.html#louvre-weston-clone-example">louvre-weston-clone</a> examples.</dd></dl>
<h1><a class="anchor" id="Order"></a>
Order</h1>
<p><a class="el" href="namespace_louvre.html" title="Namespaces.">Louvre</a> maintains a list to keep track of all surfaces created by clients, which can be accessed via <a class="el" href="class_louvre_1_1_l_compositor.html#a02b82f9077f93ed98b9fdd2c963014e8" title="Gets a list of all surfaces created by clients.">LCompositor::surfaces()</a>.<br  />
This list adheres to the Z-axis order as defined by the protocols of their respective roles.<br  />
 Surfaces are always assigned a layer, which is controlled by their role. Both the surfaces list and layers maintain the same order.<br  />
Surfaces are assigned to a layer as follows:</p>
<ul>
<li><b>Background Layer</b>: Only <a class="el" href="class_louvre_1_1_l_layer_role.html" title="Layer role for surfaces.">LLayerRole</a> surfaces can be in this layer, usually used by clients to display wallpapers.</li>
<li><b>Bottom Layer</b>: Only <a class="el" href="class_louvre_1_1_l_layer_role.html" title="Layer role for surfaces.">LLayerRole</a> surfaces can be in this layer, some clients use it to display top bars.</li>
<li><b>Middle Layer</b>: Default layer for surfaces with no role, for non-fullscreen <a class="el" href="class_louvre_1_1_l_toplevel_role.html" title="Toplevel role for surfaces.">LToplevelRole</a> surfaces, and <a class="el" href="class_louvre_1_1_l_session_lock_role.html" title="Surface displayed during a session lock.">LSessionLockRole</a> surfaces.</li>
<li><b>Top Layer</b>: For fullscreen <a class="el" href="class_louvre_1_1_l_toplevel_role.html" title="Toplevel role for surfaces.">LToplevelRole</a> and <a class="el" href="class_louvre_1_1_l_layer_role.html" title="Layer role for surfaces.">LLayerRole</a> surfaces.</li>
<li><b>Overlay Layer</b>: <a class="el" href="class_louvre_1_1_l_cursor_role.html" title="Cursor role for surfaces.">LCursorRole</a>, <a class="el" href="class_louvre_1_1_l_d_n_d_icon_role.html" title="Drag &amp; drop icon role for surfaces.">LDNDIconRole</a>, <a class="el" href="class_louvre_1_1_l_popup_role.html" title="Popup role for surfaces.">LPopupRole</a>, and <a class="el" href="class_louvre_1_1_l_layer_role.html" title="Layer role for surfaces.">LLayerRole</a> surfaces are displayed in this layer.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="class_louvre_1_1_l_subsurface_role.html" title="Subsurface role for surfaces.">LSubsurfaceRole</a> and transient <a class="el" href="class_louvre_1_1_l_toplevel_role.html" title="Toplevel role for surfaces.">LToplevelRole</a> surfaces are always assigned the same layer as their parent surface.</dd></dl>
<p>It is possible to modify the order of surfaces within a layer using the <a class="el" href="class_louvre_1_1_l_surface.html#ad9c27f2d106edb222bc33c4bfc384f58" title="Raises the surface within its current layer.">raise()</a> method, this will normally also raise other surfaces such as subsurfaces.<br  />
You can receive notifications when the order changes by implementing the <a class="el" href="class_louvre_1_1_l_surface.html#ac30d215881c074b2cab7d90e5d54e149" title="Notifies when the surface changes its position in the surfaces list.">orderChanged()</a> and <a class="el" href="class_louvre_1_1_l_surface.html#a810cbeacbbe17335c0f6f5d1ba60869a" title="Notified a c.">layerChanged()</a> virtual methods.<br  />
Use <a class="el" href="class_louvre_1_1_l_surface.html#a011aa286f1843209432e721d51304810" title="Retrieve the previous surface in the compositor surfaces list (LCompositor::surfaces()).">prevSurface()</a> and <a class="el" href="class_louvre_1_1_l_surface.html#aa2df3baf64b05fa8b629b3eaefc59c5d" title="Retrieve the next surface in the compositor surfaces list (LCompositor::surfaces()).">nextSurface()</a> to get the surface behind or on top of the current surface. Keep in mind that these functions may return <code>nullptr</code> if a surface is at the beginning or end of the <a class="el" href="class_louvre_1_1_l_compositor.html#a02b82f9077f93ed98b9fdd2c963014e8" title="Gets a list of all surfaces created by clients.">LCompositor::surfaces()</a> list.<br  />
Surfaces are thought to be rendered in the order they appear in the list. The first surfaces should be located in the background, while the last ones should be in the foreground.</p>
<dl class="section note"><dt>Note</dt><dd>If you want to use a different ordering, you could leverage the <a class="el" href="class_louvre_1_1_l_compositor.html" title="Louvre&#39;s core and objects factory.">LCompositor</a> factory constructor/destructor respectively to listen for when clients create or destroy a surface.</dd></dl>
<h1><a class="anchor" id="Position"></a>
Position</h1>
<p>One of the characteristics of Wayland is that clients have very little information and control over how their surfaces are positioned on the screen.<br  />
For this reason, the rules of their roles generally define it based on an offset relative to another surface, an output or a position given by you.<br  />
<a class="el" href="namespace_louvre.html" title="Namespaces.">Louvre</a> simplifies this by allowing you to assign the position of the surfaces with <a class="el" href="class_louvre_1_1_l_surface.html#aef41c6d77555ec63040c5baa94f3ffff" title="Assigns the position.">setPos()</a> and access the position suggested by its role with <a class="el" href="class_louvre_1_1_l_surface.html#adb14a727889d37b9b51c18a9a54745eb" title="Role position.">rolePos()</a>.<br  />
In some cases, such as in the <a class="el" href="class_louvre_1_1_l_popup_role.html" title="Popup role for surfaces.">LPopupRole</a> or <a class="el" href="class_louvre_1_1_l_subsurface_role.html" title="Subsurface role for surfaces.">LSubsurfaceRole</a> role, the position set with <a class="el" href="class_louvre_1_1_l_surface.html#aef41c6d77555ec63040c5baa94f3ffff" title="Assigns the position.">setPos()</a> is not taken into account.<br  />
You can see the positioning rules of each role in detail by viewing the documentation of <a class="el" href="class_louvre_1_1_l_surface.html#adb14a727889d37b9b51c18a9a54745eb" title="Role position.">rolePos()</a> for each one. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a03bbf64580744af6d161dc054d3fb1fd" name="a03bbf64580744af6d161dc054d3fb1fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03bbf64580744af6d161dc054d3fb1fd">&#9670;&#160;</a></span>Role</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_louvre_1_1_l_surface.html#a03bbf64580744af6d161dc054d3fb1fd">Role</a> : <a class="el" href="namespace_louvre.html#a7e8aeec7b6541935dfc6f608cd5170ce">UInt32</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ID of library roles. </p>
<p>ID of the current role of the surface accessible with <a class="el" href="class_louvre_1_1_l_surface.html#a740a064ccce3e2cd36c7c843d346890a" title="ID of the role.">roleId()</a> </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a03bbf64580744af6d161dc054d3fb1fda18f893264a00711081b62de694f99db4" name="a03bbf64580744af6d161dc054d3fb1fda18f893264a00711081b62de694f99db4"></a>Undefined&#160;</td><td class="fielddoc"><p>No role set. </p>
</td></tr>
<tr><td class="fieldname"><a id="a03bbf64580744af6d161dc054d3fb1fdaa160f21447740f1e2ab2e1cee4119b1a" name="a03bbf64580744af6d161dc054d3fb1fdaa160f21447740f1e2ab2e1cee4119b1a"></a>Toplevel&#160;</td><td class="fielddoc"><p><a class="el" href="class_louvre_1_1_l_toplevel_role.html" title="Toplevel role for surfaces.">LToplevelRole</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a03bbf64580744af6d161dc054d3fb1fda98578dbca692ae4a78bb0a2294c3563e" name="a03bbf64580744af6d161dc054d3fb1fda98578dbca692ae4a78bb0a2294c3563e"></a>Popup&#160;</td><td class="fielddoc"><p><a class="el" href="class_louvre_1_1_l_popup_role.html" title="Popup role for surfaces.">LPopupRole</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a03bbf64580744af6d161dc054d3fb1fdaf71da6f05af0d78c59ac4fedb0cac53f" name="a03bbf64580744af6d161dc054d3fb1fdaf71da6f05af0d78c59ac4fedb0cac53f"></a>Subsurface&#160;</td><td class="fielddoc"><p><a class="el" href="class_louvre_1_1_l_subsurface_role.html" title="Subsurface role for surfaces.">LSubsurfaceRole</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a03bbf64580744af6d161dc054d3fb1fda4b3019bb143755d5bf6b73f1e4e3a29b" name="a03bbf64580744af6d161dc054d3fb1fda4b3019bb143755d5bf6b73f1e4e3a29b"></a>Cursor&#160;</td><td class="fielddoc"><p><a class="el" href="class_louvre_1_1_l_cursor_role.html" title="Cursor role for surfaces.">LCursorRole</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a03bbf64580744af6d161dc054d3fb1fda2c67f54f052020b493e2dde5536e46bc" name="a03bbf64580744af6d161dc054d3fb1fda2c67f54f052020b493e2dde5536e46bc"></a>DNDIcon&#160;</td><td class="fielddoc"><p><a class="el" href="class_louvre_1_1_l_d_n_d_icon_role.html" title="Drag &amp; drop icon role for surfaces.">LDNDIconRole</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a03bbf64580744af6d161dc054d3fb1fda480c64d6ab00eef03ca97ca2f886f777" name="a03bbf64580744af6d161dc054d3fb1fda480c64d6ab00eef03ca97ca2f886f777"></a>SessionLock&#160;</td><td class="fielddoc"><p><a class="el" href="class_louvre_1_1_l_session_lock_role.html" title="Surface displayed during a session lock.">LSessionLockRole</a> (since v2.0.0) </p>
</td></tr>
<tr><td class="fieldname"><a id="a03bbf64580744af6d161dc054d3fb1fda04e9ad186dc292785fa5e6c9abe2379d" name="a03bbf64580744af6d161dc054d3fb1fda04e9ad186dc292785fa5e6c9abe2379d"></a>Layer&#160;</td><td class="fielddoc"><p><a class="el" href="class_louvre_1_1_l_layer_role.html" title="Layer role for surfaces.">LLayerRole</a> (since v2.0.0) </p>
</td></tr>
</table>

</div>
</div>
<a id="a6251d534fc6198bc897fd8a089847008" name="a6251d534fc6198bc897fd8a089847008"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6251d534fc6198bc897fd8a089847008">&#9670;&#160;</a></span>PointerConstraintMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_louvre_1_1_l_surface.html#a6251d534fc6198bc897fd8a089847008">PointerConstraintMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pointer constraint modes. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a6251d534fc6198bc897fd8a089847008af81827737c0ce4664c0f7d1242183310" name="a6251d534fc6198bc897fd8a089847008af81827737c0ce4664c0f7d1242183310"></a>Free&#160;</td><td class="fielddoc"><p>No pointer constraint, the pointer is free to move anywhere. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6251d534fc6198bc897fd8a089847008a2d2c1d495d2836c20c94c46758ddb504" name="a6251d534fc6198bc897fd8a089847008a2d2c1d495d2836c20c94c46758ddb504"></a>Lock&#160;</td><td class="fielddoc"><p>Lock the pointer position somewhere inside <a class="el" href="class_louvre_1_1_l_surface.html#a6f696343765259838338bb091350f5d8" title="Region within the surface where the pointer should be locked or confined if pointer constraint is ena...">pointerConstraintRegion()</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6251d534fc6198bc897fd8a089847008ae2cef45cddb113ca8c6a0fcfe50b6fdf" name="a6251d534fc6198bc897fd8a089847008ae2cef45cddb113ca8c6a0fcfe50b6fdf"></a>Confine&#160;</td><td class="fielddoc"><p>Confine the pointer to <a class="el" href="class_louvre_1_1_l_surface.html#a6f696343765259838338bb091350f5d8" title="Region within the surface where the pointer should be locked or confined if pointer constraint is ena...">pointerConstraintRegion()</a>. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a069cc6b8646159314fbcd55faa106b2b" name="a069cc6b8646159314fbcd55faa106b2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a069cc6b8646159314fbcd55faa106b2b">&#9670;&#160;</a></span>LSurface()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_louvre_1_1_l_surface.html">LSurface</a> </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor of the <a class="el" href="class_louvre_1_1_l_surface.html" title="A client &quot;window&quot;.">LSurface</a> class. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td>Internal parameters provided in <a class="el" href="class_louvre_1_1_l_compositor.html#af3e8f08b72263581c87aa240607438ef" title="Request to create a specific LFactoryObject.">LCompositor::createObjectRequest()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3de927bf7cb148773736c7eec704f57b" name="a3de927bf7cb148773736c7eec704f57b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3de927bf7cb148773736c7eec704f57b">&#9670;&#160;</a></span>~LSurface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">~<a class="el" href="class_louvre_1_1_l_surface.html">LSurface</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructor of the <a class="el" href="class_louvre_1_1_l_surface.html" title="A client &quot;window&quot;.">LSurface</a> class. </p>
<p>Invoked after <a class="el" href="class_louvre_1_1_l_compositor.html#aa8850deab2bf40dc6cb9e276b22e39cb" title="Announce the anticipated destruction of an LFactoryObject.">LCompositor::onAnticipatedObjectDestruction()</a>. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a47bae11fb88b5ea985dd22b437310f4d" name="a47bae11fb88b5ea985dd22b437310f4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47bae11fb88b5ea985dd22b437310f4d">&#9670;&#160;</a></span>layer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_louvre.html#a6dd0ee7d9f15733c1c631bab2262f51c">LSurfaceLayer</a> layer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the layer in which this surface currently resides. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_louvre_1_1_l_compositor.html#ae249a4a9132d58a075aff07ee4d18453" title="Retrieves the list of surfaces within a specific layer.">LCompositor::layer()</a> </dd>
<dd>
<a class="el" href="namespace_louvre.html#a6dd0ee7d9f15733c1c631bab2262f51c" title="Surface layers.">LSurfaceLayer</a> </dd>
<dd>
<a class="el" href="class_louvre_1_1_l_surface.html#a810cbeacbbe17335c0f6f5d1ba60869a" title="Notified a c.">layerChanged()</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The layer ID of the surface. </dd></dl>

</div>
</div>
<a id="a9924d855d4a3ff48c8d144103588ae1a" name="a9924d855d4a3ff48c8d144103588ae1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9924d855d4a3ff48c8d144103588ae1a">&#9670;&#160;</a></span>backgroundBlur()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_louvre_1_1_l_background_blur.html">LBackgroundBlur</a> * backgroundBlur </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the background blur controller associated with the surface. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the background blur controller, guaranteed to exist even if the client does not support the protocol. </dd></dl>

</div>
</div>
<a id="aef41c6d77555ec63040c5baa94f3ffff" name="aef41c6d77555ec63040c5baa94f3ffff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef41c6d77555ec63040c5baa94f3ffff">&#9670;&#160;</a></span>setPos() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setPos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_louvre.html#a1111511396cab1b2607e4ac55e1883a3">LPoint</a> &amp;&#160;</td>
          <td class="paramname"><em>newPos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns the position. </p>
<p>Assigns the position of the surface. </p>

</div>
</div>
<a id="a1d24b54d39edb99f9f851090c20d0499" name="a1d24b54d39edb99f9f851090c20d0499"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d24b54d39edb99f9f851090c20d0499">&#9670;&#160;</a></span>setPos() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setPos </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_louvre.html#a20b0c262d9ef5d263888e463dfa99638">Int32</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_louvre.html#a20b0c262d9ef5d263888e463dfa99638">Int32</a>&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns the position. </p>
<p>Assigns the position of the surface. </p>

</div>
</div>
<a id="aa70e56e4e7ccb56992207e10ebc3ac1d" name="aa70e56e4e7ccb56992207e10ebc3ac1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa70e56e4e7ccb56992207e10ebc3ac1d">&#9670;&#160;</a></span>setX()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setX </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_louvre.html#a20b0c262d9ef5d263888e463dfa99638">Int32</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns the x component of the position. </p>
<p>Assigns the x component of the position of the surface. </p>

</div>
</div>
<a id="ab0612afb87d0124325f84293d40e156d" name="ab0612afb87d0124325f84293d40e156d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0612afb87d0124325f84293d40e156d">&#9670;&#160;</a></span>setY()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setY </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_louvre.html#a20b0c262d9ef5d263888e463dfa99638">Int32</a>&#160;</td>
          <td class="paramname"><em>y</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns the y component of the position. </p>
<p>Assigns the y component of the position of the surface. </p>

</div>
</div>
<a id="a0843c1bb97b8a8cfb3faa6f75e68acd6" name="a0843c1bb97b8a8cfb3faa6f75e68acd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0843c1bb97b8a8cfb3faa6f75e68acd6">&#9670;&#160;</a></span>pos()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_louvre.html#a1111511396cab1b2607e4ac55e1883a3">LPoint</a> &amp; pos </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Position given by the compositor. </p>
<p>Position of the surface assigned with <a class="el" href="class_louvre_1_1_l_surface.html#aef41c6d77555ec63040c5baa94f3ffff" title="Assigns the position.">setPos()</a>, <a class="el" href="class_louvre_1_1_l_surface.html#aa70e56e4e7ccb56992207e10ebc3ac1d" title="Assigns the x component of the position.">setX()</a> or <a class="el" href="class_louvre_1_1_l_surface.html#ab0612afb87d0124325f84293d40e156d" title="Assigns the y component of the position.">setY()</a>. </p>

</div>
</div>
<a id="adb14a727889d37b9b51c18a9a54745eb" name="adb14a727889d37b9b51c18a9a54745eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb14a727889d37b9b51c18a9a54745eb">&#9670;&#160;</a></span>rolePos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_louvre.html#a1111511396cab1b2607e4ac55e1883a3">LPoint</a> &amp; rolePos </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Role position. </p>
<p>Role position in surface coordinates. If the surface has no role, the same value as <a class="el" href="class_louvre_1_1_l_surface.html#a0843c1bb97b8a8cfb3faa6f75e68acd6" title="Position given by the compositor.">pos()</a> is returned. </p>

</div>
</div>
<a id="a9595879ae0c4def717bd69d345001ed0" name="a9595879ae0c4def717bd69d345001ed0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9595879ae0c4def717bd69d345001ed0">&#9670;&#160;</a></span>sizeB()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_louvre.html#a4df5473974ae0f28f3a4967f296a657b">LSize</a> &amp; sizeB </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Surface size in buffer coordinates. </p>

</div>
</div>
<a id="af0e9483bc8188a275f4877e55ec720b0" name="af0e9483bc8188a275f4877e55ec720b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0e9483bc8188a275f4877e55ec720b0">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_louvre.html#a4df5473974ae0f28f3a4967f296a657b">LSize</a> &amp; size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Surface size in surface coordinates. </p>

</div>
</div>
<a id="ab4d2773573dd5a24998bdf9b617d5b26" name="ab4d2773573dd5a24998bdf9b617d5b26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4d2773573dd5a24998bdf9b617d5b26">&#9670;&#160;</a></span>inputRegion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_louvre_1_1_l_region.html">LRegion</a> &amp; inputRegion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Input region in surface coordinates. </p>
<p>Region of the surface that is capable of receiving input, in surface coordinates.</p>
<p>Already clipped by the surface bounds. </p>

</div>
</div>
<a id="a4f8b9a31339748d52c056897bf1f9347" name="a4f8b9a31339748d52c056897bf1f9347"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f8b9a31339748d52c056897bf1f9347">&#9670;&#160;</a></span>opaqueRegion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_louvre_1_1_l_region.html">LRegion</a> &amp; opaqueRegion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Opaque region in surface coordinates. </p>
<p>Already clipped by the surface bounds. </p>

</div>
</div>
<a id="aa2bb0159586017db5bbc143fa929c037" name="aa2bb0159586017db5bbc143fa929c037"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2bb0159586017db5bbc143fa929c037">&#9670;&#160;</a></span>translucentRegion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_louvre_1_1_l_region.html">LRegion</a> &amp; translucentRegion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Translucent region in surface coordinates. </p>
<p>Translucent region in surface coordinates (inverted opaque region).</p>
<p>Already clipped by the surface bounds. </p>

</div>
</div>
<a id="a895de383bc5ed5afc287190086c11dae" name="a895de383bc5ed5afc287190086c11dae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a895de383bc5ed5afc287190086c11dae">&#9670;&#160;</a></span>invisibleRegion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_louvre_1_1_l_region.html">LRegion</a> &amp; invisibleRegion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invisible region in surface coordinates. </p>
<p>Region within the surface that is completely transparent.</p>
<dl class="section note"><dt>Note</dt><dd>The invisible region protocol is experimental and thus not enabled by default in <code><a class="el" href="class_louvre_1_1_l_compositor.html#a1e03e3983ef2f3495537eb4ff0fc9996" title="Wayland globals initialization.">LCompositor::createGlobalsRequest()</a></code>.</dd></dl>
<p>Already clipped by the surface bounds. </p>

</div>
</div>
<a id="a39a66ef5eff7936fcc836dd223c1537d" name="a39a66ef5eff7936fcc836dd223c1537d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39a66ef5eff7936fcc836dd223c1537d">&#9670;&#160;</a></span>damage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_louvre_1_1_l_region.html">LRegion</a> &amp; damage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Damaged region in surface coordinates. </p>
<p>Already clipped by the surface bounds. </p>

</div>
</div>
<a id="ad1c82147d85831cd674c1fe4b91065bd" name="ad1c82147d85831cd674c1fe4b91065bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1c82147d85831cd674c1fe4b91065bd">&#9670;&#160;</a></span>damageB()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_louvre_1_1_l_region.html">LRegion</a> &amp; damageB </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Damaged region in buffer coordinates. </p>
<p>Already clipped by the surface bounds. </p>

</div>
</div>
<a id="a77d688c4b02da52e5f2fc20f85024d6b" name="a77d688c4b02da52e5f2fc20f85024d6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77d688c4b02da52e5f2fc20f85024d6b">&#9670;&#160;</a></span>contentType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_louvre.html#a7de5cf1aefc1d4c90dbe7dc0727654ba">LContentType</a> contentType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the content type that the surface represents. </p>
<p>Clients using the Content Type Hint protocol can indicate the type of content a particular surface is displaying.<br  />
This information can be used, for example, to adapt the compositor behavior and to optimize the functioning of hardware displays when assigned to outputs through <a class="el" href="class_louvre_1_1_l_output.html#af0c36b2fb823c8128b04f77ae9c488a5" title="Sets the content type hint.">LOutput::setContentType()</a>.</p>
<p>The default value is <a class="el" href="namespace_louvre.html#a7de5cf1aefc1d4c90dbe7dc0727654baa9b954e76f820119b19d48566706f709e">LContentTypeNone</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_louvre_1_1_l_output.html#af0c36b2fb823c8128b04f77ae9c488a5" title="Sets the content type hint.">LOutput::setContentType()</a> and <a class="el" href="class_louvre_1_1_l_surface.html#adc79b942fea173935ef3bff4de7406f1" title="Notifies a change of content type.">LSurface::contentTypeChanged()</a> </dd></dl>

</div>
</div>
<a id="adf7ba2250df7b9183015035fa9faf65d" name="adf7ba2250df7b9183015035fa9faf65d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf7ba2250df7b9183015035fa9faf65d">&#9670;&#160;</a></span>sendOutputEnterEvent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sendOutputEnterEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_louvre_1_1_l_output.html">LOutput</a> *&#160;</td>
          <td class="paramname"><em>output</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Notify the client when the surface enters an output. </p>
<p>This method notifies the surface's client that the surface has become visible within the display area of a specific output. The client application can use this information to synchronize the surface's scale with that of the output. You can access the list of outputs where the surface is visible using the <a class="el" href="class_louvre_1_1_l_surface.html#a05aaba26b6841b8ea133a64d1d28cb5e" title="Surface intersected outputs.">outputs()</a> method.</p>
<dl class="section note"><dt>Note</dt><dd>This method can be safely called multiple times with the same output as an argument because it internally checks whether the client has already been notified.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output</td><td>The output into which the surface has entered. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2ed50991c54d5cf3e12d8497be39be58" name="a2ed50991c54d5cf3e12d8497be39be58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ed50991c54d5cf3e12d8497be39be58">&#9670;&#160;</a></span>sendOutputLeaveEvent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sendOutputLeaveEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_louvre_1_1_l_output.html">LOutput</a> *&#160;</td>
          <td class="paramname"><em>output</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Notify the client when the surface leaves an output. </p>
<p>This method informs the surface's client application that the surface is no longer visible on a particular output. You can access the list of outputs where the surface is still visible using the <a class="el" href="class_louvre_1_1_l_surface.html#a05aaba26b6841b8ea133a64d1d28cb5e" title="Surface intersected outputs.">outputs()</a> method.</p>
<dl class="section note"><dt>Note</dt><dd>This method can be safely called multiple times with the same output as an argument because it internally checks whether the client has already been notified.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output</td><td>The output from which the surface is no longer visible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a05aaba26b6841b8ea133a64d1d28cb5e" name="a05aaba26b6841b8ea133a64d1d28cb5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05aaba26b6841b8ea133a64d1d28cb5e">&#9670;&#160;</a></span>outputs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="class_louvre_1_1_l_output.html">LOutput</a> * &gt; &amp; outputs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Surface intersected outputs. </p>
<p>Vector of output pointers in which the surface is visible, modifiable with the <a class="el" href="class_louvre_1_1_l_surface.html#adf7ba2250df7b9183015035fa9faf65d" title="Notify the client when the surface enters an output.">sendOutputEnterEvent()</a> and <a class="el" href="class_louvre_1_1_l_surface.html#a2ed50991c54d5cf3e12d8497be39be58" title="Notify the client when the surface leaves an output.">sendOutputLeaveEvent()</a> methods. </p>

</div>
</div>
<a id="a6919bf7aca736afa49a0f8733bae0e2c" name="a6919bf7aca736afa49a0f8733bae0e2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6919bf7aca736afa49a0f8733bae0e2c">&#9670;&#160;</a></span>repaintOutputs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void repaintOutputs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Repaints the intersected outputs. </p>
<p>Invokes the <a class="el" href="class_louvre_1_1_l_output.html#a3640e75ecf0af51755b05a1e1262b25c" title="Unlocks the rendering thread.">LOutput::repaint()</a> method on all outputs listed in <a class="el" href="class_louvre_1_1_l_surface.html#a05aaba26b6841b8ea133a64d1d28cb5e" title="Surface intersected outputs.">outputs()</a>. </p>

</div>
</div>
<a id="a02788e60359675cce4314237d9aa6eb2" name="a02788e60359675cce4314237d9aa6eb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02788e60359675cce4314237d9aa6eb2">&#9670;&#160;</a></span>minimized()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool minimized </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Minimized property. </p>
<p>Stores the minimized state of the surface set with <a class="el" href="class_louvre_1_1_l_surface.html#a842fbbf544354ca39c400d0651c27977" title="Sets the minimized property.">setMinimized()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the surface is minimized and <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a842fbbf544354ca39c400d0651c27977" name="a842fbbf544354ca39c400d0651c27977"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a842fbbf544354ca39c400d0651c27977">&#9670;&#160;</a></span>setMinimized()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setMinimized </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the minimized property. </p>
<p>Minimize/unminimize the surface and all its children. </p>

</div>
</div>
<a id="abf260d3cedc0fc116d030cc514e4b183" name="abf260d3cedc0fc116d030cc514e4b183"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf260d3cedc0fc116d030cc514e4b183">&#9670;&#160;</a></span>receiveInput()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool receiveInput </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Input capability. </p>
<p>Indicates whether the surface is able to receive pointer or touch input events. </p>

</div>
</div>
<a id="a4e457997007c405dfb0e45d1795f574d" name="a4e457997007c405dfb0e45d1795f574d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e457997007c405dfb0e45d1795f574d">&#9670;&#160;</a></span>bufferScale()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_louvre.html#a20b0c262d9ef5d263888e463dfa99638">Int32</a> bufferScale </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Buffer scale. </p>
<p>Scale of the surface buffer. You can listen for changes to this property with the <a class="el" href="class_louvre_1_1_l_surface.html#a7ffb06fa9c6e119757c8294be05f927f" title="Notifies a change in buffer scale.">bufferScaleChanged()</a> event. </p>

</div>
</div>
<a id="a64295697b08bc2c6cbb04ddce8ca6193" name="a64295697b08bc2c6cbb04ddce8ca6193"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64295697b08bc2c6cbb04ddce8ca6193">&#9670;&#160;</a></span>bufferTransform()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_louvre.html#a700c2230c9a7c049255f06a9ca53b72b">LTransform</a> bufferTransform </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the buffer transform of the surface. </p>
<dl class="section return"><dt>Returns</dt><dd>The buffer transform applied to the surface. </dd></dl>

</div>
</div>
<a id="aa62271a8aeb6886831d1a59b5d73b1b5" name="aa62271a8aeb6886831d1a59b5d73b1b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa62271a8aeb6886831d1a59b5d73b1b5">&#9670;&#160;</a></span>srcRect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_louvre.html#a7cf2780f5c2644b34dfa6b7d2dd7a541">LRectF</a> &amp; srcRect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the source rect of the surface in surface coordinates. </p>
<p>For clients using the Viewporter protocol, a custom <a class="el" href="class_louvre_1_1_l_surface.html#aa62271a8aeb6886831d1a59b5d73b1b5" title="Gets the source rect of the surface in surface coordinates.">srcRect()</a> detached from the buffer size can be specified. For clients not using the protocol, the source rect covers the entire surface buffer. </p>

</div>
</div>
<a id="a487340b99fd4cbd2edbff299f54bdef4" name="a487340b99fd4cbd2edbff299f54bdef4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a487340b99fd4cbd2edbff299f54bdef4">&#9670;&#160;</a></span>hasPointerFocus()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool hasPointerFocus </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the surface has pointer focus. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the surface has pointer focus, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ac883d24eddf4ec8e2e719e4a4188caab" name="ac883d24eddf4ec8e2e719e4a4188caab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac883d24eddf4ec8e2e719e4a4188caab">&#9670;&#160;</a></span>hasKeyboardFocus()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool hasKeyboardFocus </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the surface has keyboard focus. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the surface has keyboard focus, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="abdc3b3701b2671696c36b57ee501ad46" name="abdc3b3701b2671696c36b57ee501ad46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdc3b3701b2671696c36b57ee501ad46">&#9670;&#160;</a></span>hasKeyboardGrab()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool hasKeyboardGrab </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the surface is grabbing the keyboard. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the surface is grabbing the keyboard, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ab010fd9d64d973f5d1d6fbb4ed55e974" name="ab010fd9d64d973f5d1d6fbb4ed55e974"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab010fd9d64d973f5d1d6fbb4ed55e974">&#9670;&#160;</a></span>texture()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_louvre_1_1_l_texture.html">LTexture</a> * texture </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>OpenGL texture. </p>
<p>Representation of the surface's buffer as an OpenGL texture.</p>
<dl class="section warning"><dt>Warning</dt><dd>It could return <code>nullptr</code> if the surface is not currently mapped. </dd></dl>

</div>
</div>
<a id="a680a08a0cc72cef97515a99e04616ca4" name="a680a08a0cc72cef97515a99e04616ca4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a680a08a0cc72cef97515a99e04616ca4">&#9670;&#160;</a></span>bufferResource()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">wl_buffer * bufferResource </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Native <a href="https://wayland.app/protocols/wayland#wl_buffer">wl_buffer</a> handle. </p>
<p>Handle to the last commited Wayland buffer of the surface.</p>
<dl class="section warning"><dt>Warning</dt><dd>It could return <code>nullptr</code> if the surface is not currently mapped. </dd></dl>

</div>
</div>
<a id="a7796ca9ff7bbb71c0b62dee8c498636f" name="a7796ca9ff7bbb71c0b62dee8c498636f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7796ca9ff7bbb71c0b62dee8c498636f">&#9670;&#160;</a></span>hasBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool hasBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates if the last attached buffer was NULL. </p>
<dl class="section note"><dt>Note</dt><dd>Even if this method returns <code>true</code>, <a class="el" href="class_louvre_1_1_l_surface.html#a680a08a0cc72cef97515a99e04616ca4" title="Native wl_buffer handle.">bufferResource()</a> may return <code>nullptr</code> if the buffer was destroyed before being replaced by another attach and commit.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the last attached buffer was not NULL, otherwise <code>false</code>. </dd></dl>

</div>
</div>
<a id="a2d905f76e9e5dc532cada7fc8f21eedf" name="a2d905f76e9e5dc532cada7fc8f21eedf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d905f76e9e5dc532cada7fc8f21eedf">&#9670;&#160;</a></span>hasDamage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool hasDamage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Presence of damage. </p>
<p>Indicates if the surface has new damage since the last time the <a class="el" href="class_louvre_1_1_l_surface.html#a23585ebe5d0f8117186848426ea39f0a" title="ACK the frame callback.">requestNextFrame()</a> method was called.<br  />
You can access the damaged region with <a class="el" href="class_louvre_1_1_l_surface.html#a39a66ef5eff7936fcc836dd223c1537d" title="Damaged region in surface coordinates.">damage()</a> or <a class="el" href="class_louvre_1_1_l_surface.html#ad1c82147d85831cd674c1fe4b91065bd" title="Damaged region in buffer coordinates.">damageB()</a>. </p>

</div>
</div>
<a id="acb61c86374487dcee71b7a3eb37cd277" name="acb61c86374487dcee71b7a3eb37cd277"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb61c86374487dcee71b7a3eb37cd277">&#9670;&#160;</a></span>damageId()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_louvre.html#a7e8aeec7b6541935dfc6f608cd5170ce">UInt32</a> damageId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets an ID that increments with each commit and new damage addition. </p>
<p>The ID increments every time the surface is committed and new damage is added.</p>
<dl class="section return"><dt>Returns</dt><dd>The incremental damage ID of the surface. </dd></dl>

</div>
</div>
<a id="a23585ebe5d0f8117186848426ea39f0a" name="a23585ebe5d0f8117186848426ea39f0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23585ebe5d0f8117186848426ea39f0a">&#9670;&#160;</a></span>requestNextFrame()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void requestNextFrame </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>clearDamage</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ACK the frame callback. </p>
<p>Notifies the surface that it's time for it to draw its next frame.<br  />
If not called, the given surface should not update its content.</p>
<dl class="section warning"><dt>Warning</dt><dd>This method clears the current damage region of the surface. </dd></dl>

</div>
</div>
<a id="ac563c8ace44bf8111c0ee1c034e967e2" name="ac563c8ace44bf8111c0ee1c034e967e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac563c8ace44bf8111c0ee1c034e967e2">&#9670;&#160;</a></span>mapped()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mapped </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mapped property. </p>
<p>Indicates if the surface can be rendered. </p>

</div>
</div>
<a id="ac8212dc8e0490f5dd5671187b07f0773" name="ac8212dc8e0490f5dd5671187b07f0773"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8212dc8e0490f5dd5671187b07f0773">&#9670;&#160;</a></span>preferVSync()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool preferVSync </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the VSync preference of the client for this surface. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_louvre_1_1_l_output.html#aad3bf6e06d340d3dc8d267e4e654afeb" title="Turns VSync on or off.">LOutput::enableVSync()</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if VSync is preferred, <code>false</code> if tearing is preferred. </dd></dl>

</div>
</div>
<a id="a29d4084bafe3a6b0e8d8d111bbbb58c6" name="a29d4084bafe3a6b0e8d8d111bbbb58c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29d4084bafe3a6b0e8d8d111bbbb58c6">&#9670;&#160;</a></span>views()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="class_louvre_1_1_l_surface_view.html">LSurfaceView</a> * &gt; &amp; views </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>LSurfaceViews created for this surface. </p>

</div>
</div>
<a id="a13b08f0aa9d16303ebe83f6d090c97f2" name="a13b08f0aa9d16303ebe83f6d090c97f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13b08f0aa9d16303ebe83f6d090c97f2">&#9670;&#160;</a></span>surfaceResource()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Wayland::RSurface * surfaceResource </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wayland surface resource. </p>
<p>Returns the resource generated by the <a href="https://wayland.app/protocols/wayland#wl_surface">wl_surface</a> interface of the Wayland protocol. </p>

</div>
</div>
<a id="a09c5f0c5da7c1420989b6a2d9063c4c7" name="a09c5f0c5da7c1420989b6a2d9063c4c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09c5f0c5da7c1420989b6a2d9063c4c7">&#9670;&#160;</a></span>idleInhibitorResources()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; IdleInhibit::RIdleInhibitor * &gt; idleInhibitorResources </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Idle Inhibitor Resources. </p>

</div>
</div>
<a id="a030bc63c24e4bb205344939c91b2ba26" name="a030bc63c24e4bb205344939c91b2ba26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a030bc63c24e4bb205344939c91b2ba26">&#9670;&#160;</a></span>client()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_louvre_1_1_l_client.html">LClient</a> * client </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Client owner of the surface. </p>

</div>
</div>
<a id="a96a82bfdfd9c2b81c916f351340d5e17" name="a96a82bfdfd9c2b81c916f351340d5e17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96a82bfdfd9c2b81c916f351340d5e17">&#9670;&#160;</a></span>parent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_louvre_1_1_l_surface.html">LSurface</a> * parent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parent surface. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the parent surface or <code>nullptr</code> if it does not have a parent. </dd></dl>

</div>
</div>
<a id="a5eef6f8bca2936636a2da7c63c2a561b" name="a5eef6f8bca2936636a2da7c63c2a561b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eef6f8bca2936636a2da7c63c2a561b">&#9670;&#160;</a></span>topmostParent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_louvre_1_1_l_surface.html">LSurface</a> * topmostParent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Topmost parent of the surface. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the topmost parent of the surface, or <code>nullptr</code> if it does not have a parent. </dd></dl>

</div>
</div>
<a id="ad1051b97fa6b0d82a2f20be803620dd4" name="ad1051b97fa6b0d82a2f20be803620dd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1051b97fa6b0d82a2f20be803620dd4">&#9670;&#160;</a></span>children()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::list&lt; <a class="el" href="class_louvre_1_1_l_surface.html">LSurface</a> * &gt; &amp; children </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Child surfaces. </p>
<p>List of child surfaces. </p>

</div>
</div>
<a id="ac5342952f29ba9c4531eeca2e6be86af" name="ac5342952f29ba9c4531eeca2e6be86af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5342952f29ba9c4531eeca2e6be86af">&#9670;&#160;</a></span>isPopupSubchild()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool isPopupSubchild </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the surface is a subchild of a popup. </p>
<p>This method determines whether the surface is a subchild of a popup surface. It returns <code>true</code> if the surface is a subchild of a popup surface in the hierarchy; otherwise, it returns <code>false</code>.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the surface is a subchild of a popup surface, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a707a9a4fc34daabd4761ea1fed2af746" name="a707a9a4fc34daabd4761ea1fed2af746"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a707a9a4fc34daabd4761ea1fed2af746">&#9670;&#160;</a></span>hasPopupSubchild()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool hasPopupSubchild </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the surface has a subchild popup. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the surface has a subchild popup, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ad0c74531a689b7ed87bb54cb8054254b" name="ad0c74531a689b7ed87bb54cb8054254b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0c74531a689b7ed87bb54cb8054254b">&#9670;&#160;</a></span>isSubchildOf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool isSubchildOf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_louvre_1_1_l_surface.html">LSurface</a> *&#160;</td>
          <td class="paramname"><em>parent</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the surface is a subchild of the specified parent surface. </p>
<p>This method checks whether the surface is a subchild of the provided parent surface.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>A pointer to the potential parent <a class="el" href="class_louvre_1_1_l_surface.html" title="A client &quot;window&quot;.">LSurface</a> to check against. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the surface is a subchild of the provided parent surface, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ad9c27f2d106edb222bc33c4bfc384f58" name="ad9c27f2d106edb222bc33c4bfc384f58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9c27f2d106edb222bc33c4bfc384f58">&#9670;&#160;</a></span>raise()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void raise </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Raises the surface within its current layer. </p>
<p>This method reinserts the surface at the end of its current layer's list, ensuring its position above other surfaces within the same layer.<br  />
If the surface is parent of other surfaces, those child surfaces will also be raised to maintain the hierarchical order required by certain protocols.</p>
<dl class="section note"><dt>Note</dt><dd>Calling this method during the handling of an <code><a class="el" href="class_louvre_1_1_l_surface.html#ac30d215881c074b2cab7d90e5d54e149" title="Notifies when the surface changes its position in the surfaces list.">orderChanged()</a></code> event is not allowed, and doing so will result in a no-op. </dd></dl>

</div>
</div>
<a id="a011aa286f1843209432e721d51304810" name="a011aa286f1843209432e721d51304810"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a011aa286f1843209432e721d51304810">&#9670;&#160;</a></span>prevSurface()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_louvre_1_1_l_surface.html">LSurface</a> * prevSurface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the previous surface in the compositor surfaces list (<a class="el" href="class_louvre_1_1_l_compositor.html#a02b82f9077f93ed98b9fdd2c963014e8" title="Gets a list of all surfaces created by clients.">LCompositor::surfaces()</a>). </p>
<p>This method returns a pointer to the surface that precedes the current surface in the compositor's surfaces list. If the current surface is the first one in the list, the method returns <code>nullptr</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the previous <a class="el" href="class_louvre_1_1_l_surface.html" title="A client &quot;window&quot;.">LSurface</a> or <code>nullptr</code> if the current surface is the first in the list. </dd></dl>

</div>
</div>
<a id="aa2df3baf64b05fa8b629b3eaefc59c5d" name="aa2df3baf64b05fa8b629b3eaefc59c5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2df3baf64b05fa8b629b3eaefc59c5d">&#9670;&#160;</a></span>nextSurface()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_louvre_1_1_l_surface.html">LSurface</a> * nextSurface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the next surface in the compositor surfaces list (<a class="el" href="class_louvre_1_1_l_compositor.html#a02b82f9077f93ed98b9fdd2c963014e8" title="Gets a list of all surfaces created by clients.">LCompositor::surfaces()</a>). </p>
<p>This method returns a pointer to the surface that follows the current surface in the compositor's surfaces list. If the current surface is the last one in the list, the method returns <code>nullptr</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the next <a class="el" href="class_louvre_1_1_l_surface.html" title="A client &quot;window&quot;.">LSurface</a> or <code>nullptr</code> if the current surface is the last in the list. </dd></dl>

</div>
</div>
<a id="a740a064ccce3e2cd36c7c843d346890a" name="a740a064ccce3e2cd36c7c843d346890a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a740a064ccce3e2cd36c7c843d346890a">&#9670;&#160;</a></span>roleId()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_louvre_1_1_l_surface.html#a03bbf64580744af6d161dc054d3fb1fd">LSurface::Role</a> roleId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ID of the role. </p>
<dl class="section return"><dt>Returns</dt><dd>The ID of the surface's role or <a class="el" href="class_louvre_1_1_l_surface.html#a03bbf64580744af6d161dc054d3fb1fda18f893264a00711081b62de694f99db4" title="No role set.">LSurface::Undefined</a> if it does not have a role. </dd></dl>

</div>
</div>
<a id="adcb0a0c7570cedec2cc38822943a7fff" name="adcb0a0c7570cedec2cc38822943a7fff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcb0a0c7570cedec2cc38822943a7fff">&#9670;&#160;</a></span>role()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_louvre_1_1_l_base_surface_role.html">LBaseSurfaceRole</a> * role </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Surface role. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the surface's role or <code>nullptr</code> if it does not have a role. </dd></dl>

</div>
</div>
<a id="a2486948f8e54c31d79de22f79766d9ea" name="a2486948f8e54c31d79de22f79766d9ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2486948f8e54c31d79de22f79766d9ea">&#9670;&#160;</a></span>cursorRole()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_louvre_1_1_l_cursor_role.html">LCursorRole</a> * cursorRole </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cursor role. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to an instance of <a class="el" href="class_louvre_1_1_l_cursor_role.html" title="Cursor role for surfaces.">LCursorRole</a> or <code>nullptr</code> if it has a different role. </dd></dl>

</div>
</div>
<a id="aaeabbba055c54e5881a8225a63a6b4c7" name="aaeabbba055c54e5881a8225a63a6b4c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaeabbba055c54e5881a8225a63a6b4c7">&#9670;&#160;</a></span>dndIcon()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_louvre_1_1_l_d_n_d_icon_role.html">LDNDIconRole</a> * dndIcon </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Drag &amp; Drop icon role. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to an instance of <a class="el" href="class_louvre_1_1_l_d_n_d_icon_role.html" title="Drag &amp; drop icon role for surfaces.">LDNDIconRole</a> or <code>nullptr</code> if it has a different role. </dd></dl>

</div>
</div>
<a id="a744809727c631248ae26aae91fa08a6d" name="a744809727c631248ae26aae91fa08a6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a744809727c631248ae26aae91fa08a6d">&#9670;&#160;</a></span>toplevel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_louvre_1_1_l_toplevel_role.html">LToplevelRole</a> * toplevel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Toplevel role. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to an instance of <a class="el" href="class_louvre_1_1_l_toplevel_role.html" title="Toplevel role for surfaces.">LToplevelRole</a> or <code>nullptr</code> if it has a different role. </dd></dl>

</div>
</div>
<a id="a5fbab4b1f9f0d60b9a84d53ee4b25c43" name="a5fbab4b1f9f0d60b9a84d53ee4b25c43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fbab4b1f9f0d60b9a84d53ee4b25c43">&#9670;&#160;</a></span>popup()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_louvre_1_1_l_popup_role.html">LPopupRole</a> * popup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Popup role. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to an instance of <a class="el" href="class_louvre_1_1_l_popup_role.html" title="Popup role for surfaces.">LPopupRole</a> or <code>nullptr</code> if it has a different role. </dd></dl>

</div>
</div>
<a id="a8e301296e7228a07b5c450fbf8cbd2e0" name="a8e301296e7228a07b5c450fbf8cbd2e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e301296e7228a07b5c450fbf8cbd2e0">&#9670;&#160;</a></span>subsurface()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_louvre_1_1_l_subsurface_role.html">LSubsurfaceRole</a> * subsurface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subsurface role. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to an instance of <a class="el" href="class_louvre_1_1_l_subsurface_role.html" title="Subsurface role for surfaces.">LSubsurfaceRole</a> or <code>nullptr</code> if it has a different role. </dd></dl>

</div>
</div>
<a id="a503ccd23df24f76263e3d7d597b22380" name="a503ccd23df24f76263e3d7d597b22380"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a503ccd23df24f76263e3d7d597b22380">&#9670;&#160;</a></span>sessionLock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_louvre_1_1_l_session_lock_role.html">LSessionLockRole</a> * sessionLock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Session Lock role. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to an instance of <a class="el" href="class_louvre_1_1_l_session_lock_role.html" title="Surface displayed during a session lock.">LSessionLockRole</a> or <code>nullptr</code> if it has a different role. </dd></dl>

</div>
</div>
<a id="a0893cf0c3ddae63514996e5450e9c859" name="a0893cf0c3ddae63514996e5450e9c859"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0893cf0c3ddae63514996e5450e9c859">&#9670;&#160;</a></span>layerRole()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_louvre_1_1_l_layer_role.html">LLayerRole</a> * layerRole </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Layer role. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to an instance of <a class="el" href="class_louvre_1_1_l_layer_role.html" title="Layer role for surfaces.">LLayerRole</a> or <code>nullptr</code> if it has a different role. </dd></dl>

</div>
</div>
<a id="aff2b39d0b63be670058e1f85cb3a95ee" name="aff2b39d0b63be670058e1f85cb3a95ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff2b39d0b63be670058e1f85cb3a95ee">&#9670;&#160;</a></span>pointerConstraintMode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_louvre_1_1_l_surface.html#a6251d534fc6198bc897fd8a089847008">LSurface::PointerConstraintMode</a> pointerConstraintMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Current pointer constraint mode. </p>
<p>Returns the current mode in which the client wants to constrain the pointer.</p>
<dl class="section note"><dt>Note</dt><dd>The pointer constraint is not enabled automatically, see <a class="el" href="class_louvre_1_1_l_surface.html#aa49cb89a754457f7bc4ebc014c87284c" title="Notifies the client if the pointer is constrained.">enablePointerConstraint()</a>. </dd></dl>

</div>
</div>
<a id="a283c520197dfb0da059145f32f0332e1" name="a283c520197dfb0da059145f32f0332e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a283c520197dfb0da059145f32f0332e1">&#9670;&#160;</a></span>pointerConstraintModeChanged()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void pointerConstraintModeChanged </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invoked when <a class="el" href="class_louvre_1_1_l_surface.html#aff2b39d0b63be670058e1f85cb3a95ee" title="Current pointer constraint mode.">pointerConstraintMode()</a> changes. </p>
<p>Each time the pointer constraint mode changes, the pointer constraint is disabled and <a class="el" href="class_louvre_1_1_l_surface.html#aa49cb89a754457f7bc4ebc014c87284c" title="Notifies the client if the pointer is constrained.">enablePointerConstraint()</a> must be called again to enable it.</p>
<h4><a class="anchor" id="default-implementation-47"></a>
Default implementation</h4>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="class_louvre_1_1_l_surface.html#a283c520197dfb0da059145f32f0332e1">LSurface::pointerConstraintModeChanged</a>()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">/* No default implementation */</span></div>
<div class="line">}</div>
<div class="ttc" id="aclass_louvre_1_1_l_surface_html_a283c520197dfb0da059145f32f0332e1"><div class="ttname"><a href="class_louvre_1_1_l_surface.html#a283c520197dfb0da059145f32f0332e1">Louvre::LSurface::pointerConstraintModeChanged</a></div><div class="ttdeci">virtual void pointerConstraintModeChanged()</div><div class="ttdoc">Invoked when pointerConstraintMode() changes.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a6f696343765259838338bb091350f5d8" name="a6f696343765259838338bb091350f5d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f696343765259838338bb091350f5d8">&#9670;&#160;</a></span>pointerConstraintRegion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_louvre_1_1_l_region.html">LRegion</a> &amp; pointerConstraintRegion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Region within the surface where the pointer should be locked or confined if pointer constraint is enabled. </p>
<p>Returns the region within the surface where the pointer should be locked or confined if the pointer constraint is enabled.</p>
<dl class="section return"><dt>Returns</dt><dd>The region where the pointer should be constrained within the surface. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_louvre_1_1_l_region.html#af4c9899d869bc3172674c4a061450f02" title="Returns the point within the region closest to the given point.">LRegion::closestPointFrom()</a> </dd></dl>

</div>
</div>
<a id="a12e808df10a615440cc3800b0748bc28" name="a12e808df10a615440cc3800b0748bc28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12e808df10a615440cc3800b0748bc28">&#9670;&#160;</a></span>pointerConstraintRegionChanged()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void pointerConstraintRegionChanged </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Notifies a change in <a class="el" href="class_louvre_1_1_l_surface.html#a6f696343765259838338bb091350f5d8" title="Region within the surface where the pointer should be locked or confined if pointer constraint is ena...">pointerConstraintRegion()</a>. </p>
<h4><a class="anchor" id="default-implementation-48"></a>
Default implementation</h4>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="class_louvre_1_1_l_surface.html#a12e808df10a615440cc3800b0748bc28">LSurface::pointerConstraintRegionChanged</a>()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">/* No default implementation */</span></div>
<div class="line">}</div>
<div class="ttc" id="aclass_louvre_1_1_l_surface_html_a12e808df10a615440cc3800b0748bc28"><div class="ttname"><a href="class_louvre_1_1_l_surface.html#a12e808df10a615440cc3800b0748bc28">Louvre::LSurface::pointerConstraintRegionChanged</a></div><div class="ttdeci">virtual void pointerConstraintRegionChanged()</div><div class="ttdoc">Notifies a change in pointerConstraintRegion().</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="aa49cb89a754457f7bc4ebc014c87284c" name="aa49cb89a754457f7bc4ebc014c87284c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa49cb89a754457f7bc4ebc014c87284c">&#9670;&#160;</a></span>enablePointerConstraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void enablePointerConstraint </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Notifies the client if the pointer is constrained. </p>
<p>The surface must have pointer focus prior to calling this method and have either a <a class="el" href="class_louvre_1_1_l_surface.html#a6251d534fc6198bc897fd8a089847008a2d2c1d495d2836c20c94c46758ddb504">Lock</a> or <a class="el" href="class_louvre_1_1_l_surface.html#a6251d534fc6198bc897fd8a089847008ae2cef45cddb113ca8c6a0fcfe50b6fdf">Confine</a> <a class="el" href="class_louvre_1_1_l_surface.html#a6251d534fc6198bc897fd8a089847008">PointerConstraintMode</a>, otherwise, it is a no-op.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enabled</td><td>Boolean indicating if the pointer constraint is enabled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeb2502acb54891e6e659427a40eaa966" name="aeb2502acb54891e6e659427a40eaa966"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb2502acb54891e6e659427a40eaa966">&#9670;&#160;</a></span>pointerConstraintEnabled()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pointerConstraintEnabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates if the compositor enabled the pointer constraint for this surface. </p>
<p>It is automatically set to <code>false</code> if the surface loses pointer focus or the <a class="el" href="class_louvre_1_1_l_surface.html#aff2b39d0b63be670058e1f85cb3a95ee" title="Current pointer constraint mode.">pointerConstraintMode()</a> property changes.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_louvre_1_1_l_surface.html#aa49cb89a754457f7bc4ebc014c87284c" title="Notifies the client if the pointer is constrained.">enablePointerConstraint()</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the pointer constraint is enabled for this surface, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a2d958c32d8d65ec5c132d572b600f374" name="a2d958c32d8d65ec5c132d572b600f374"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d958c32d8d65ec5c132d572b600f374">&#9670;&#160;</a></span>lockedPointerPosHint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_louvre.html#a5517b50113b8b1757430425847186df5">LPointF</a> &amp; lockedPointerPosHint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates where the pointer currently is within the surface if the pointer <a class="el" href="class_louvre_1_1_l_surface.html#a6251d534fc6198bc897fd8a089847008a2d2c1d495d2836c20c94c46758ddb504">Lock</a> constrain mode is enabled. </p>
<p>If <a class="el" href="class_louvre_1_1_l_surface.html#aff2b39d0b63be670058e1f85cb3a95ee" title="Current pointer constraint mode.">pointerConstraintMode()</a> is not <a class="el" href="class_louvre_1_1_l_surface.html#a6251d534fc6198bc897fd8a089847008a2d2c1d495d2836c20c94c46758ddb504">Lock</a> or the client has never set this property, it returns <code>(-1.f, -1.f)</code>. </p>

</div>
</div>
<a id="a584fb32350cfbb659dc6c80993bb2853" name="a584fb32350cfbb659dc6c80993bb2853"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a584fb32350cfbb659dc6c80993bb2853">&#9670;&#160;</a></span>lockedPointerPosHintChanged()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void lockedPointerPosHintChanged </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Notifies a change in <a class="el" href="class_louvre_1_1_l_surface.html#a2d958c32d8d65ec5c132d572b600f374" title="Indicates where the pointer currently is within the surface if the pointer Lock constrain mode is ena...">lockedPointerPosHint()</a>. </p>
<h4><a class="anchor" id="default-implementation-49"></a>
Default implementation</h4>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="class_louvre_1_1_l_surface.html#a584fb32350cfbb659dc6c80993bb2853">LSurface::lockedPointerPosHintChanged</a>()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">/* No default implementation */</span></div>
<div class="line">}</div>
<div class="ttc" id="aclass_louvre_1_1_l_surface_html_a584fb32350cfbb659dc6c80993bb2853"><div class="ttname"><a href="class_louvre_1_1_l_surface.html#a584fb32350cfbb659dc6c80993bb2853">Louvre::LSurface::lockedPointerPosHintChanged</a></div><div class="ttdeci">virtual void lockedPointerPosHintChanged()</div><div class="ttdoc">Notifies a change in lockedPointerPosHint().</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a7a1f368d2e0c75ff45866f9d0dd37cdb" name="a7a1f368d2e0c75ff45866f9d0dd37cdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a1f368d2e0c75ff45866f9d0dd37cdb">&#9670;&#160;</a></span>damageChanged()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void damageChanged </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Notifies about new damages on the surface. </p>
<p>Reimplement this virtual method if you want to be notified when the surface has new damage.</p>
<h4><a class="anchor" id="default-implementation-50"></a>
Default Implementation</h4>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="class_louvre_1_1_l_surface.html#a7a1f368d2e0c75ff45866f9d0dd37cdb">LSurface::damageChanged</a>()</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_function" href="class_louvre_1_1_l_surface.html#a6919bf7aca736afa49a0f8733bae0e2c">repaintOutputs</a>();</div>
<div class="line">}</div>
<div class="ttc" id="aclass_louvre_1_1_l_surface_html_a6919bf7aca736afa49a0f8733bae0e2c"><div class="ttname"><a href="class_louvre_1_1_l_surface.html#a6919bf7aca736afa49a0f8733bae0e2c">Louvre::LSurface::repaintOutputs</a></div><div class="ttdeci">void repaintOutputs() noexcept</div><div class="ttdoc">Repaints the intersected outputs.</div><div class="ttdef"><b>Definition</b> LSurface.cpp:211</div></div>
<div class="ttc" id="aclass_louvre_1_1_l_surface_html_a7a1f368d2e0c75ff45866f9d0dd37cdb"><div class="ttname"><a href="class_louvre_1_1_l_surface.html#a7a1f368d2e0c75ff45866f9d0dd37cdb">Louvre::LSurface::damageChanged</a></div><div class="ttdeci">virtual void damageChanged()</div><div class="ttdoc">Notifies about new damages on the surface.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="afde528457065bf8c34063d1e04261e1e" name="afde528457065bf8c34063d1e04261e1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afde528457065bf8c34063d1e04261e1e">&#9670;&#160;</a></span>roleChanged()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void roleChanged </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_louvre_1_1_l_base_surface_role.html">LBaseSurfaceRole</a> *&#160;</td>
          <td class="paramname"><em>prevRole</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Notifies a change in role. </p>
<p>Indicates that the current <code><a class="el" href="class_louvre_1_1_l_surface.html#adcb0a0c7570cedec2cc38822943a7fff" title="Surface role.">role()</a></code> has changed. Initially, the role is <code>nullptr</code>.</p>
<p>The role always transitions either from <code>nullptr</code> to a valid role or from a role back to <code>nullptr</code>, but never directly from one role (<code>roleA</code>) to another (<code>roleB</code>).</p>
<p>During the execution of this method, the surface is always <b>unmapped</b>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prevRole</td><td>Handle to the previous role, or <code>nullptr</code> if no role was assigned. The current role is always obtained via <code><a class="el" href="class_louvre_1_1_l_surface.html#adcb0a0c7570cedec2cc38822943a7fff" title="Surface role.">role()</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<h4><a class="anchor" id="default-implementation-51"></a>
Default Implementation</h4>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="class_louvre_1_1_l_surface.html#afde528457065bf8c34063d1e04261e1e">LSurface::roleChanged</a>(<a class="code hl_class" href="class_louvre_1_1_l_base_surface_role.html">LBaseSurfaceRole</a> *prevRole)</div>
<div class="line">{</div>
<div class="line">    L_UNUSED(prevRole)</div>
<div class="line">    <a class="code hl_function" href="class_louvre_1_1_l_surface.html#a6919bf7aca736afa49a0f8733bae0e2c">repaintOutputs</a>();</div>
<div class="line">}</div>
<div class="ttc" id="aclass_louvre_1_1_l_base_surface_role_html"><div class="ttname"><a href="class_louvre_1_1_l_base_surface_role.html">Louvre::LBaseSurfaceRole</a></div><div class="ttdoc">Base class for surface roles.</div><div class="ttdef"><b>Definition</b> LBaseSurfaceRole.h:43</div></div>
<div class="ttc" id="aclass_louvre_1_1_l_surface_html_afde528457065bf8c34063d1e04261e1e"><div class="ttname"><a href="class_louvre_1_1_l_surface.html#afde528457065bf8c34063d1e04261e1e">Louvre::LSurface::roleChanged</a></div><div class="ttdeci">virtual void roleChanged(LBaseSurfaceRole *prevRole)</div><div class="ttdoc">Notifies a change in role.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a2148e1e9be424c7b640f56f96bd7083f" name="a2148e1e9be424c7b640f56f96bd7083f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2148e1e9be424c7b640f56f96bd7083f">&#9670;&#160;</a></span>parentChanged()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void parentChanged </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Notifies a change of parent. </p>
<p>Reimplement this virtual method if you want to be notified when the surface changes its parent.</p>
<h4><a class="anchor" id="default-implementation-52"></a>
Default implementation</h4>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="class_louvre_1_1_l_surface.html#a2148e1e9be424c7b640f56f96bd7083f">LSurface::parentChanged</a>()</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_function" href="class_louvre_1_1_l_surface.html#a6919bf7aca736afa49a0f8733bae0e2c">repaintOutputs</a>();</div>
<div class="line">}</div>
<div class="ttc" id="aclass_louvre_1_1_l_surface_html_a2148e1e9be424c7b640f56f96bd7083f"><div class="ttname"><a href="class_louvre_1_1_l_surface.html#a2148e1e9be424c7b640f56f96bd7083f">Louvre::LSurface::parentChanged</a></div><div class="ttdeci">virtual void parentChanged()</div><div class="ttdoc">Notifies a change of parent.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a1150cf016134af22675fdb93b240ee78" name="a1150cf016134af22675fdb93b240ee78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1150cf016134af22675fdb93b240ee78">&#9670;&#160;</a></span>mappingChanged()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void mappingChanged </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Notifies of a change in the <a class="el" href="class_louvre_1_1_l_surface.html#ac563c8ace44bf8111c0ee1c034e967e2" title="Mapped property.">mapped()</a> property. </p>
<p>A surface is always initially unmapped. It becomes mapped when the client assigns it a role, attaches a valid buffer (texture), and requests it to be presented. If any of these conditions are not met, <a class="el" href="class_louvre_1_1_l_surface.html#ac563c8ace44bf8111c0ee1c034e967e2" title="Mapped property.">mapped()</a> returns false.</p>
<p>A surface is always unmapped before its <a class="el" href="class_louvre_1_1_l_surface.html#adcb0a0c7570cedec2cc38822943a7fff" title="Surface role.">role()</a> is changed.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_louvre_1_1_l_surface.html#ac563c8ace44bf8111c0ee1c034e967e2" title="Mapped property.">mapped()</a></dd></dl>
<h4><a class="anchor" id="default-implementation-58"></a>
Default implementation</h4>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="class_louvre_1_1_l_surface.html#a1150cf016134af22675fdb93b240ee78">LSurface::mappingChanged</a>()</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_function" href="namespace_louvre.html#a62750620c88ee98b1c5286f1fc339c5b">compositor</a>()-&gt;<a class="code hl_function" href="class_louvre_1_1_l_compositor.html#a05c977b22d20e051621dc42e183c2165">repaintAllOutputs</a>();</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="class_louvre_1_1_l_output.html">LOutput</a> *activeOutput { <a class="code hl_function" href="namespace_louvre.html#a0ebe6057a764ac1de2b90e50c6a7916c">cursor</a>()-&gt;<a class="code hl_function" href="class_louvre_1_1_l_cursor.html#a78cead834241e232298bef395516b2ee">output</a>() };</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (!activeOutput)</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* If the surface is a toplevel, we place it at the center of the screen */</span></div>
<div class="line">    <span class="keywordflow">if</span> (<a class="code hl_function" href="class_louvre_1_1_l_surface.html#ac563c8ace44bf8111c0ee1c034e967e2">mapped</a>() &amp;&amp; <a class="code hl_function" href="class_louvre_1_1_l_surface.html#a744809727c631248ae26aae91fa08a6d">toplevel</a>())</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">const</span> <a class="code hl_class" href="class_louvre_1_1_l_point_template.html">LSize</a> <a class="code hl_function" href="class_louvre_1_1_l_surface.html#af0e9483bc8188a275f4877e55ec720b0">size</a> {</div>
<div class="line">            <a class="code hl_function" href="class_louvre_1_1_l_surface.html#a744809727c631248ae26aae91fa08a6d">toplevel</a>()-&gt;<a class="code hl_function" href="class_louvre_1_1_l_toplevel_role.html#ad1e743fb0701cd487e363cc3609f3ac3">windowGeometry</a>().<a class="code hl_function" href="class_louvre_1_1_l_rect_template.html#af6951b309861d44f0657e149461f6915">size</a>()</div>
<div class="line">            + <a class="code hl_typedef" href="namespace_louvre.html#a4df5473974ae0f28f3a4967f296a657b">LSize</a>(<a class="code hl_function" href="class_louvre_1_1_l_surface.html#a744809727c631248ae26aae91fa08a6d">toplevel</a>()-&gt;extraGeometry().left + <a class="code hl_function" href="class_louvre_1_1_l_surface.html#a744809727c631248ae26aae91fa08a6d">toplevel</a>()-&gt;extraGeometry().right,</div>
<div class="line">                    <a class="code hl_function" href="class_louvre_1_1_l_surface.html#a744809727c631248ae26aae91fa08a6d">toplevel</a>()-&gt;extraGeometry().top + <a class="code hl_function" href="class_louvre_1_1_l_surface.html#a744809727c631248ae26aae91fa08a6d">toplevel</a>()-&gt;extraGeometry().bottom)</div>
<div class="line">        };</div>
<div class="line"> </div>
<div class="line">        <span class="keyword">const</span> <a class="code hl_typedef" href="namespace_louvre.html#a4df5473974ae0f28f3a4967f296a657b">LSize</a> availGeoPos { activeOutput-&gt;pos() + activeOutput-&gt;availableGeometry().pos() };</div>
<div class="line"> </div>
<div class="line">        <a class="code hl_function" href="class_louvre_1_1_l_surface.html#aef41c6d77555ec63040c5baa94f3ffff">setPos</a>(availGeoPos + (activeOutput-&gt;availableGeometry().size() - <a class="code hl_function" href="class_louvre_1_1_l_surface.html#af0e9483bc8188a275f4877e55ec720b0">size</a>) / 2);</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (<a class="code hl_function" href="class_louvre_1_1_l_surface.html#a0843c1bb97b8a8cfb3faa6f75e68acd6">pos</a>().y() &lt; availGeoPos.<a class="code hl_function" href="class_louvre_1_1_l_point_template.html#aac45bdeb9d3b7ce4c7b45c1546dcd849">y</a>())</div>
<div class="line">            <a class="code hl_function" href="class_louvre_1_1_l_surface.html#ab0612afb87d0124325f84293d40e156d">setY</a>(availGeoPos.y());</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="aclass_louvre_1_1_l_compositor_html_a05c977b22d20e051621dc42e183c2165"><div class="ttname"><a href="class_louvre_1_1_l_compositor.html#a05c977b22d20e051621dc42e183c2165">Louvre::LCompositor::repaintAllOutputs</a></div><div class="ttdeci">void repaintAllOutputs() noexcept</div><div class="ttdoc">Unlocks the rendering thread of all initialized outputs.</div><div class="ttdef"><b>Definition</b> LCompositor.cpp:455</div></div>
<div class="ttc" id="aclass_louvre_1_1_l_cursor_html_a78cead834241e232298bef395516b2ee"><div class="ttname"><a href="class_louvre_1_1_l_cursor.html#a78cead834241e232298bef395516b2ee">Louvre::LCursor::output</a></div><div class="ttdeci">LOutput * output() const noexcept</div><div class="ttdoc">Gets the current cursor output.</div><div class="ttdef"><b>Definition</b> LCursor.cpp:350</div></div>
<div class="ttc" id="aclass_louvre_1_1_l_output_html"><div class="ttname"><a href="class_louvre_1_1_l_output.html">Louvre::LOutput</a></div><div class="ttdoc">A display rendering interface.</div><div class="ttdef"><b>Definition</b> LOutput.h:215</div></div>
<div class="ttc" id="aclass_louvre_1_1_l_point_template_html"><div class="ttname"><a href="class_louvre_1_1_l_point_template.html">Louvre::LPointTemplate&lt; Int32 &gt;</a></div></div>
<div class="ttc" id="aclass_louvre_1_1_l_point_template_html_aac45bdeb9d3b7ce4c7b45c1546dcd849"><div class="ttname"><a href="class_louvre_1_1_l_point_template.html#aac45bdeb9d3b7ce4c7b45c1546dcd849">Louvre::LPointTemplate::y</a></div><div class="ttdeci">constexpr T y() const noexcept</div><div class="ttdoc">Second component of the vector.</div><div class="ttdef"><b>Definition</b> LPoint.h:40</div></div>
<div class="ttc" id="aclass_louvre_1_1_l_rect_template_html_af6951b309861d44f0657e149461f6915"><div class="ttname"><a href="class_louvre_1_1_l_rect_template.html#af6951b309861d44f0657e149461f6915">Louvre::LRectTemplate::size</a></div><div class="ttdeci">constexpr const LPointTemplate&lt; T &gt; &amp; size() const noexcept</div><div class="ttdoc">2D vector given by the (w,h) components of the rectangle</div><div class="ttdef"><b>Definition</b> LRect.h:131</div></div>
<div class="ttc" id="aclass_louvre_1_1_l_surface_html_a0843c1bb97b8a8cfb3faa6f75e68acd6"><div class="ttname"><a href="class_louvre_1_1_l_surface.html#a0843c1bb97b8a8cfb3faa6f75e68acd6">Louvre::LSurface::pos</a></div><div class="ttdeci">const LPoint &amp; pos() const noexcept</div><div class="ttdoc">Position given by the compositor.</div><div class="ttdef"><b>Definition</b> LSurface.cpp:336</div></div>
<div class="ttc" id="aclass_louvre_1_1_l_surface_html_a1150cf016134af22675fdb93b240ee78"><div class="ttname"><a href="class_louvre_1_1_l_surface.html#a1150cf016134af22675fdb93b240ee78">Louvre::LSurface::mappingChanged</a></div><div class="ttdeci">virtual void mappingChanged()</div><div class="ttdoc">Notifies of a change in the mapped() property.</div></div>
<div class="ttc" id="aclass_louvre_1_1_l_surface_html_a744809727c631248ae26aae91fa08a6d"><div class="ttname"><a href="class_louvre_1_1_l_surface.html#a744809727c631248ae26aae91fa08a6d">Louvre::LSurface::toplevel</a></div><div class="ttdeci">LToplevelRole * toplevel() const noexcept</div><div class="ttdoc">Toplevel role.</div><div class="ttdef"><b>Definition</b> LSurface.cpp:70</div></div>
<div class="ttc" id="aclass_louvre_1_1_l_surface_html_ab0612afb87d0124325f84293d40e156d"><div class="ttname"><a href="class_louvre_1_1_l_surface.html#ab0612afb87d0124325f84293d40e156d">Louvre::LSurface::setY</a></div><div class="ttdeci">void setY(Int32 y) noexcept</div><div class="ttdoc">Assigns the y component of the position.</div><div class="ttdef"><b>Definition</b> LSurface.cpp:139</div></div>
<div class="ttc" id="aclass_louvre_1_1_l_surface_html_ac563c8ace44bf8111c0ee1c034e967e2"><div class="ttname"><a href="class_louvre_1_1_l_surface.html#ac563c8ace44bf8111c0ee1c034e967e2">Louvre::LSurface::mapped</a></div><div class="ttdeci">bool mapped() const noexcept</div><div class="ttdoc">Mapped property.</div><div class="ttdef"><b>Definition</b> LSurface.cpp:456</div></div>
<div class="ttc" id="aclass_louvre_1_1_l_surface_html_aef41c6d77555ec63040c5baa94f3ffff"><div class="ttname"><a href="class_louvre_1_1_l_surface.html#aef41c6d77555ec63040c5baa94f3ffff">Louvre::LSurface::setPos</a></div><div class="ttdeci">void setPos(const LPoint &amp;newPos) noexcept</div><div class="ttdoc">Assigns the position.</div><div class="ttdef"><b>Definition</b> LSurface.cpp:123</div></div>
<div class="ttc" id="aclass_louvre_1_1_l_surface_html_af0e9483bc8188a275f4877e55ec720b0"><div class="ttname"><a href="class_louvre_1_1_l_surface.html#af0e9483bc8188a275f4877e55ec720b0">Louvre::LSurface::size</a></div><div class="ttdeci">const LSize &amp; size() const noexcept</div><div class="ttdoc">Surface size in surface coordinates.</div><div class="ttdef"><b>Definition</b> LSurface.cpp:149</div></div>
<div class="ttc" id="aclass_louvre_1_1_l_toplevel_role_html_ad1e743fb0701cd487e363cc3609f3ac3"><div class="ttname"><a href="class_louvre_1_1_l_toplevel_role.html#ad1e743fb0701cd487e363cc3609f3ac3">Louvre::LToplevelRole::windowGeometry</a></div><div class="ttdeci">const LRect &amp; windowGeometry() const noexcept</div><div class="ttdoc">Window geometry in surface coordinates.</div><div class="ttdef"><b>Definition</b> LToplevelRole.h:541</div></div>
<div class="ttc" id="anamespace_louvre_html_a0ebe6057a764ac1de2b90e50c6a7916c"><div class="ttname"><a href="namespace_louvre.html#a0ebe6057a764ac1de2b90e50c6a7916c">Louvre::cursor</a></div><div class="ttdeci">LCursor * cursor() noexcept</div><div class="ttdoc">Gets the compositor's cursor.</div><div class="ttdef"><b>Definition</b> LCompositor.cpp:47</div></div>
<div class="ttc" id="anamespace_louvre_html_a4df5473974ae0f28f3a4967f296a657b"><div class="ttname"><a href="namespace_louvre.html#a4df5473974ae0f28f3a4967f296a657b">Louvre::LSize</a></div><div class="ttdeci">LPoint LSize</div><div class="ttdoc">2D vector of 32 bits integers</div><div class="ttdef"><b>Definition</b> LNamespaces.h:258</div></div>
<div class="ttc" id="anamespace_louvre_html_a62750620c88ee98b1c5286f1fc339c5b"><div class="ttname"><a href="namespace_louvre.html#a62750620c88ee98b1c5286f1fc339c5b">Louvre::compositor</a></div><div class="ttdeci">LCompositor * compositor() noexcept</div><div class="ttdoc">Gets the static LCompositor instance.</div><div class="ttdef"><b>Definition</b> LCompositor.cpp:37</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a7ffb06fa9c6e119757c8294be05f927f" name="a7ffb06fa9c6e119757c8294be05f927f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ffb06fa9c6e119757c8294be05f927f">&#9670;&#160;</a></span>bufferScaleChanged()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void bufferScaleChanged </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Notifies a change in buffer scale. </p>
<p>Reimplement this virtual method if you want to be notified when the surface's buffer scale changes.</p>
<h4><a class="anchor" id="default-implementation-59"></a>
Default Implementation</h4>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="class_louvre_1_1_l_surface.html#a7ffb06fa9c6e119757c8294be05f927f">LSurface::bufferScaleChanged</a>()</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_function" href="class_louvre_1_1_l_surface.html#a6919bf7aca736afa49a0f8733bae0e2c">repaintOutputs</a>();</div>
<div class="line">}</div>
<div class="ttc" id="aclass_louvre_1_1_l_surface_html_a7ffb06fa9c6e119757c8294be05f927f"><div class="ttname"><a href="class_louvre_1_1_l_surface.html#a7ffb06fa9c6e119757c8294be05f927f">Louvre::LSurface::bufferScaleChanged</a></div><div class="ttdeci">virtual void bufferScaleChanged()</div><div class="ttdoc">Notifies a change in buffer scale.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ac241183ff377da9e7ee255fb57d5f84b" name="ac241183ff377da9e7ee255fb57d5f84b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac241183ff377da9e7ee255fb57d5f84b">&#9670;&#160;</a></span>bufferTransformChanged()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void bufferTransformChanged </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Notifies a change of the buffer transform. </p>
<p>Reimplement this virtual method if you want to be notified when the surface's buffer transform changes.</p>
<h4><a class="anchor" id="default-implementation-60"></a>
Default Implementation</h4>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="class_louvre_1_1_l_surface.html#ac241183ff377da9e7ee255fb57d5f84b">LSurface::bufferTransformChanged</a>()</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_function" href="class_louvre_1_1_l_surface.html#a6919bf7aca736afa49a0f8733bae0e2c">repaintOutputs</a>();</div>
<div class="line">}</div>
<div class="ttc" id="aclass_louvre_1_1_l_surface_html_ac241183ff377da9e7ee255fb57d5f84b"><div class="ttname"><a href="class_louvre_1_1_l_surface.html#ac241183ff377da9e7ee255fb57d5f84b">Louvre::LSurface::bufferTransformChanged</a></div><div class="ttdeci">virtual void bufferTransformChanged()</div><div class="ttdoc">Notifies a change of the buffer transform.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a57442cc8cc416d6fc061dea6ff22df5e" name="a57442cc8cc416d6fc061dea6ff22df5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57442cc8cc416d6fc061dea6ff22df5e">&#9670;&#160;</a></span>bufferSizeChanged()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void bufferSizeChanged </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Notifies a change in buffer dimensions. </p>
<p>Reimplement this virtual method if you want to be notified when the buffer size (<a class="el" href="class_louvre_1_1_l_surface.html#a9595879ae0c4def717bd69d345001ed0" title="Surface size in buffer coordinates.">sizeB()</a>) changes.</p>
<h4><a class="anchor" id="default-implementation-61"></a>
Default Implementation</h4>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="class_louvre_1_1_l_surface.html#a57442cc8cc416d6fc061dea6ff22df5e">LSurface::bufferSizeChanged</a>()</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_function" href="class_louvre_1_1_l_surface.html#a6919bf7aca736afa49a0f8733bae0e2c">repaintOutputs</a>();</div>
<div class="line">}</div>
<div class="ttc" id="aclass_louvre_1_1_l_surface_html_a57442cc8cc416d6fc061dea6ff22df5e"><div class="ttname"><a href="class_louvre_1_1_l_surface.html#a57442cc8cc416d6fc061dea6ff22df5e">Louvre::LSurface::bufferSizeChanged</a></div><div class="ttdeci">virtual void bufferSizeChanged()</div><div class="ttdoc">Notifies a change in buffer dimensions.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a22170d484e8ddd9d75d12e21540b296e" name="a22170d484e8ddd9d75d12e21540b296e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22170d484e8ddd9d75d12e21540b296e">&#9670;&#160;</a></span>sizeChanged()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sizeChanged </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Notifies a change in the surface size. </p>
<p>Reimplement this virtual method if you want to be notified when the surface <a class="el" href="class_louvre_1_1_l_surface.html#af0e9483bc8188a275f4877e55ec720b0" title="Surface size in surface coordinates.">size()</a> changes.</p>
<dl class="section note"><dt>Note</dt><dd>This event differs from <a class="el" href="class_louvre_1_1_l_surface.html#a57442cc8cc416d6fc061dea6ff22df5e" title="Notifies a change in buffer dimensions.">bufferSizeChanged()</a>. The surface <a class="el" href="class_louvre_1_1_l_surface.html#af0e9483bc8188a275f4877e55ec720b0" title="Surface size in surface coordinates.">size()</a> may change when the client applies a different scale factor, transform or sets a custom destination size while using the Viewport protocol.</dd></dl>
<h4><a class="anchor" id="default-implementation-62"></a>
Default Implementation</h4>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="class_louvre_1_1_l_surface.html#a22170d484e8ddd9d75d12e21540b296e">LSurface::sizeChanged</a>()</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_function" href="class_louvre_1_1_l_surface.html#a6919bf7aca736afa49a0f8733bae0e2c">repaintOutputs</a>();</div>
<div class="line">}</div>
<div class="ttc" id="aclass_louvre_1_1_l_surface_html_a22170d484e8ddd9d75d12e21540b296e"><div class="ttname"><a href="class_louvre_1_1_l_surface.html#a22170d484e8ddd9d75d12e21540b296e">Louvre::LSurface::sizeChanged</a></div><div class="ttdeci">virtual void sizeChanged()</div><div class="ttdoc">Notifies a change in the surface size.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a2441a40331625612021248ff4621a899" name="a2441a40331625612021248ff4621a899"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2441a40331625612021248ff4621a899">&#9670;&#160;</a></span>srcRectChanged()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void srcRectChanged </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Notifies a change in the src rect. </p>
<p>Reimplement this virtual method if you want to be notified when <a class="el" href="class_louvre_1_1_l_surface.html#aa62271a8aeb6886831d1a59b5d73b1b5" title="Gets the source rect of the surface in surface coordinates.">srcRect()</a> changes.</p>
<h4><a class="anchor" id="default-implementation-63"></a>
Default Implementation</h4>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="class_louvre_1_1_l_surface.html#a2441a40331625612021248ff4621a899">LSurface::srcRectChanged</a>()</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_function" href="class_louvre_1_1_l_surface.html#a6919bf7aca736afa49a0f8733bae0e2c">repaintOutputs</a>();</div>
<div class="line">}</div>
<div class="ttc" id="aclass_louvre_1_1_l_surface_html_a2441a40331625612021248ff4621a899"><div class="ttname"><a href="class_louvre_1_1_l_surface.html#a2441a40331625612021248ff4621a899">Louvre::LSurface::srcRectChanged</a></div><div class="ttdeci">virtual void srcRectChanged()</div><div class="ttdoc">Notifies a change in the src rect.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a2df6fb09a18b12ef7bb2d0efe0157271" name="a2df6fb09a18b12ef7bb2d0efe0157271"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2df6fb09a18b12ef7bb2d0efe0157271">&#9670;&#160;</a></span>opaqueRegionChanged()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void opaqueRegionChanged </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Notifies of a change in the opaque region. </p>
<p>Reimplement this virtual method if you wish to be notified when the surface changes its opaque region.</p>
<h4><a class="anchor" id="default-implementation-64"></a>
Default Implementation</h4>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="class_louvre_1_1_l_surface.html#a2df6fb09a18b12ef7bb2d0efe0157271">LSurface::opaqueRegionChanged</a>()</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_function" href="class_louvre_1_1_l_surface.html#a6919bf7aca736afa49a0f8733bae0e2c">repaintOutputs</a>();</div>
<div class="line">}</div>
<div class="ttc" id="aclass_louvre_1_1_l_surface_html_a2df6fb09a18b12ef7bb2d0efe0157271"><div class="ttname"><a href="class_louvre_1_1_l_surface.html#a2df6fb09a18b12ef7bb2d0efe0157271">Louvre::LSurface::opaqueRegionChanged</a></div><div class="ttdeci">virtual void opaqueRegionChanged()</div><div class="ttdoc">Notifies of a change in the opaque region.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ad67a8f1c127c51a1c528c9f27ec76d6c" name="ad67a8f1c127c51a1c528c9f27ec76d6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad67a8f1c127c51a1c528c9f27ec76d6c">&#9670;&#160;</a></span>invisibleRegionChanged()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void invisibleRegionChanged </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Notifies of a change in the invisible region. </p>
<p>Reimplement this virtual method if you wish to be notified when the surface changes its invisible region.</p>
<h4><a class="anchor" id="default-implementation-65"></a>
Default Implementation</h4>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="class_louvre_1_1_l_surface.html#ad67a8f1c127c51a1c528c9f27ec76d6c">LSurface::invisibleRegionChanged</a>()</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_function" href="class_louvre_1_1_l_surface.html#a6919bf7aca736afa49a0f8733bae0e2c">repaintOutputs</a>();</div>
<div class="line">}</div>
<div class="ttc" id="aclass_louvre_1_1_l_surface_html_ad67a8f1c127c51a1c528c9f27ec76d6c"><div class="ttname"><a href="class_louvre_1_1_l_surface.html#ad67a8f1c127c51a1c528c9f27ec76d6c">Louvre::LSurface::invisibleRegionChanged</a></div><div class="ttdeci">virtual void invisibleRegionChanged()</div><div class="ttdoc">Notifies of a change in the invisible region.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a66eeb734d7a1a448557a297efd91e35c" name="a66eeb734d7a1a448557a297efd91e35c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66eeb734d7a1a448557a297efd91e35c">&#9670;&#160;</a></span>inputRegionChanged()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void inputRegionChanged </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Notifies of a change in the input region. </p>
<p>Reimplement this virtual method if you want to be notified when the surface changes its input region.</p>
<h4><a class="anchor" id="default-implementation-66"></a>
Default Implementation</h4>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="class_louvre_1_1_l_surface.html#a66eeb734d7a1a448557a297efd91e35c">LSurface::inputRegionChanged</a>()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">/* No default implementation */</span></div>
<div class="line">}</div>
<div class="ttc" id="aclass_louvre_1_1_l_surface_html_a66eeb734d7a1a448557a297efd91e35c"><div class="ttname"><a href="class_louvre_1_1_l_surface.html#a66eeb734d7a1a448557a297efd91e35c">Louvre::LSurface::inputRegionChanged</a></div><div class="ttdeci">virtual void inputRegionChanged()</div><div class="ttdoc">Notifies of a change in the input region.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ac30d215881c074b2cab7d90e5d54e149" name="ac30d215881c074b2cab7d90e5d54e149"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac30d215881c074b2cab7d90e5d54e149">&#9670;&#160;</a></span>orderChanged()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void orderChanged </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Notifies when the surface changes its position in the surfaces list. </p>
<p>Override this virtual method if you wish to be informed about changes in the order of the surface within the compositor's list of surfaces.</p>
<h4><a class="anchor" id="default-implementation-67"></a>
Default Implementation</h4>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="class_louvre_1_1_l_surface.html#ac30d215881c074b2cab7d90e5d54e149">LSurface::orderChanged</a>()</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_function" href="class_louvre_1_1_l_surface.html#a6919bf7aca736afa49a0f8733bae0e2c">repaintOutputs</a>();</div>
<div class="line">}</div>
<div class="ttc" id="aclass_louvre_1_1_l_surface_html_ac30d215881c074b2cab7d90e5d54e149"><div class="ttname"><a href="class_louvre_1_1_l_surface.html#ac30d215881c074b2cab7d90e5d54e149">Louvre::LSurface::orderChanged</a></div><div class="ttdeci">virtual void orderChanged()</div><div class="ttdoc">Notifies when the surface changes its position in the surfaces list.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a6103051c305f39465b025ff9c15c2323" name="a6103051c305f39465b025ff9c15c2323"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6103051c305f39465b025ff9c15c2323">&#9670;&#160;</a></span>requestedRepaint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void requestedRepaint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Request a repaint of the surface. </p>
<p>This request can be initiated either by the library or by the client, serving as an explicit command to repaint the surface.</p>
<h4><a class="anchor" id="default-implementation-68"></a>
Default Implementation</h4>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="class_louvre_1_1_l_surface.html#a6103051c305f39465b025ff9c15c2323">LSurface::requestedRepaint</a>()</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_function" href="class_louvre_1_1_l_surface.html#a6919bf7aca736afa49a0f8733bae0e2c">repaintOutputs</a>();</div>
<div class="line">}</div>
<div class="ttc" id="aclass_louvre_1_1_l_surface_html_a6103051c305f39465b025ff9c15c2323"><div class="ttname"><a href="class_louvre_1_1_l_surface.html#a6103051c305f39465b025ff9c15c2323">Louvre::LSurface::requestedRepaint</a></div><div class="ttdeci">virtual void requestedRepaint()</div><div class="ttdoc">Request a repaint of the surface.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="af6160ec0911aec529a68eb827717bb9f" name="af6160ec0911aec529a68eb827717bb9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6160ec0911aec529a68eb827717bb9f">&#9670;&#160;</a></span>minimizedChanged()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void minimizedChanged </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Notifies about changes in the minimized state of the surface. </p>
<p>This method is called to signal changes in the minimized state of the surface.</p>
<h4><a class="anchor" id="default-implementation-69"></a>
Default Implementation</h4>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="class_louvre_1_1_l_surface.html#af6160ec0911aec529a68eb827717bb9f">LSurface::minimizedChanged</a>()</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_function" href="class_louvre_1_1_l_surface.html#a6919bf7aca736afa49a0f8733bae0e2c">repaintOutputs</a>();</div>
<div class="line">}</div>
<div class="ttc" id="aclass_louvre_1_1_l_surface_html_af6160ec0911aec529a68eb827717bb9f"><div class="ttname"><a href="class_louvre_1_1_l_surface.html#af6160ec0911aec529a68eb827717bb9f">Louvre::LSurface::minimizedChanged</a></div><div class="ttdeci">virtual void minimizedChanged()</div><div class="ttdoc">Notifies about changes in the minimized state of the surface.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a17d11b10d54f0f54fbb8ad6020c135f6" name="a17d11b10d54f0f54fbb8ad6020c135f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17d11b10d54f0f54fbb8ad6020c135f6">&#9670;&#160;</a></span>preferVSyncChanged()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void preferVSyncChanged </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Notifies about changes in the VSync preference. </p>
<p>This event is triggered when the <a class="el" href="class_louvre_1_1_l_surface.html#ac8212dc8e0490f5dd5671187b07f0773" title="Gets the VSync preference of the client for this surface.">preferVSync()</a> property changes.</p>
<h4><a class="anchor" id="default-implementation-70"></a>
Default Implementation</h4>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="class_louvre_1_1_l_surface.html#a17d11b10d54f0f54fbb8ad6020c135f6">LSurface::preferVSyncChanged</a>()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">/* No default implementation */</span></div>
<div class="line">}</div>
<div class="ttc" id="aclass_louvre_1_1_l_surface_html_a17d11b10d54f0f54fbb8ad6020c135f6"><div class="ttname"><a href="class_louvre_1_1_l_surface.html#a17d11b10d54f0f54fbb8ad6020c135f6">Louvre::LSurface::preferVSyncChanged</a></div><div class="ttdeci">virtual void preferVSyncChanged()</div><div class="ttdoc">Notifies about changes in the VSync preference.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="adc79b942fea173935ef3bff4de7406f1" name="adc79b942fea173935ef3bff4de7406f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc79b942fea173935ef3bff4de7406f1">&#9670;&#160;</a></span>contentTypeChanged()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void contentTypeChanged </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Notifies a change of content type. </p>
<p>This event is triggered when the <a class="el" href="class_louvre_1_1_l_surface.html#a77d688c4b02da52e5f2fc20f85024d6b" title="Returns the content type that the surface represents.">contentType()</a> property changes.</p>
<h4><a class="anchor" id="default-implementation-71"></a>
Default Implementation</h4>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="class_louvre_1_1_l_surface.html#adc79b942fea173935ef3bff4de7406f1">LSurface::contentTypeChanged</a>()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">/* No default implementation */</span></div>
<div class="line">}</div>
<div class="ttc" id="aclass_louvre_1_1_l_surface_html_adc79b942fea173935ef3bff4de7406f1"><div class="ttname"><a href="class_louvre_1_1_l_surface.html#adc79b942fea173935ef3bff4de7406f1">Louvre::LSurface::contentTypeChanged</a></div><div class="ttdeci">virtual void contentTypeChanged()</div><div class="ttdoc">Notifies a change of content type.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a810cbeacbbe17335c0f6f5d1ba60869a" name="a810cbeacbbe17335c0f6f5d1ba60869a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a810cbeacbbe17335c0f6f5d1ba60869a">&#9670;&#160;</a></span>layerChanged()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void layerChanged </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Notified a c. </p>
<p>This event is triggered when the <a class="el" href="class_louvre_1_1_l_surface.html#a47bae11fb88b5ea985dd22b437310f4d" title="Retrieves the layer in which this surface currently resides.">layer()</a> property changes.</p>
<h4><a class="anchor" id="default-implementation-72"></a>
Default Implementation</h4>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="class_louvre_1_1_l_surface.html#a810cbeacbbe17335c0f6f5d1ba60869a">LSurface::layerChanged</a>()</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_function" href="class_louvre_1_1_l_surface.html#a6919bf7aca736afa49a0f8733bae0e2c">repaintOutputs</a>();</div>
<div class="line">}</div>
<div class="ttc" id="aclass_louvre_1_1_l_surface_html_a810cbeacbbe17335c0f6f5d1ba60869a"><div class="ttname"><a href="class_louvre_1_1_l_surface.html#a810cbeacbbe17335c0f6f5d1ba60869a">Louvre::LSurface::layerChanged</a></div><div class="ttdeci">virtual void layerChanged()</div><div class="ttdoc">Notified a c.</div></div>
</div><!-- fragment --> 
</div>
</div>
</div><!-- contents -->
<script>
    var menu = false;
    var burger, nav;
    function resp()
    {
        if (window.innerWidth < 768)
        {
            burger.hidden = false;
            nav.hidden = true;
        }
        else
        {
            burger.hidden = true;
            nav.hidden = false;
        }
        menu = false;
    }
    function toggleMenu()
    {
        nav.hidden = menu;
        menu = !menu;
    }
    window.onload = function()
    {
        if (typeof toggleLevel !== "undefined")
            toggleLevel(2);
        // Get all <a> tags with the "el" class
        var elLinks = document.querySelectorAll('a.el');
        // Loop through the matched elements
        elLinks.forEach(function(link) 
        {
            // Replace "Louvre::" with an empty string in the text content
            link.textContent = link.textContent.replace(/Louvre::/g, '');
        });
        nav = document.getElementById('main-nav');
        burger = document.createElement('div');
        burger.style.position = 'absolute';
        burger.style.top = '14px';
        burger.style.right = burger.style.top;
        burger.innerHTML = '<svg onclick="toggleMenu()" height="32px" viewBox="0 0 448 512"><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg>';
        document.getElementById('top').appendChild(burger);
        resp();
    };
    window.onresize = function()
    {
        resp();
    };
</script>
<div id="nav-path" class="navpath">
    <ul>
        <li class="footer">Project developed by <a href="https://github.com/CuarzoSoftware"><img class="footer" src="https://avatars.githubusercontent.com/u/29326763?s=200&v=4" style="margin-left:2px;position:relative;top:-1px;width:12px;height:12px" alt="cuarzo"/> Cuarzo Software</a></li>
    </ul>
</div>