# Louvre

Louvre is a C++ library whose goal is to reduce the learning curve required to create Wayland compositors and allow developers to focus on its creative aspects.\n
To archieve this, it implements and simplifies the protocols required by applications developed with GTK, Qt, Chromium, SDL, EFL using the **factory** design pattern and virtual methods. It also abstracts direct interaction with the Linux kernel APIs for displaying graphical content and accessing input through dynamic libraries called graphic and input backends.

<center>
    <img src="https://lh3.googleusercontent.com/N4-3a8oHenubTsj6HSDzTQfqv_rnwAD2KBolsHru1EQdX-koRbYzAcLtUm2WTESM5V0QSaVeGAOvZso08Te5sObAtCFMj393IdUA4RyUvkvrZthHL6V8zCVkIbif6n3mSmxtbjIuAg=w2400"/>
</center>

<h1>Requests</h1>

Client requests in Louvre are processed in two layers:

* **Layer 1**: In this layer, the library internally handles requests that have **a predetermined way of being implemented** and are therefore irrelevant to the developer. The rest of the requests are simplified and sent to the second layer.

* **Layer 2**: In this layer, requests are processed in the **virtual methods** of the library's classes. As these are virtual methods, the library can provide a default way of handling each request that the developer can override if needed.\n
This let us see a functional compositor on the screen from the beginig of the development, allowing developers to discover and learn each functionality of the API progressively and in an interactive way. This also prevents from having to write hundreds of lines of code correctly before any progress can be validated, which is a common issue of others libraries.

<h1>Backends</h1>

<h2>Graphic Backends</h2>

Graphical backends in Louvre are dynamic libraries which let the compositor be displayed on different contexts. For example, on an X11 compositor, nested on another Wayland compositor, or directly on screen with the DRM Linux API.\n
The library offers two graphical backends located in ```/usr/etc/Louvre/backends``` which can be dynamically loaded when the compositor starts.

* **LGraphicBackendX11** : This backend allows to display the compositor on a fullscreen window on top of an X11 compositor.
* **LGraphicBackendDRM** : This backend allows to display the compositor directly on the screen using DRM.

By default the library tries to load the DRM backend.

<h2>Input Backends</h2>

Just like graphical backends, the input backends are dynamic libraries that allow the compositor to listen for input events from the keyboard, mouse, touchpad, etc.\n

The library offers two input backends:

* **LInputBackendX11** : This backend provides access to the input events generated by an X11 compositor. It must be used together with the X11 graphical backend.
* **LInputBackendLibinput** : This backend provides access to events generated by Libinput. It is recommended to be used in conjunction with the graphical DRM backend.

By default the library tries to load the Libinput backend.

<h1>Performance</h1>

Most Wayland compositors use a single thread, which drastically slows down their performance when rendering complex scenarios. The reason for this is due to **vertical sync**, where the compositor must wait a few milliseconds before it can swap the framebuffer it just rendered with the one being displayed on screen. This is done in order to synchronize the swapping with the monitor refresh rate (*vblank*) and avoid the **tearing effect**. When working with a single thread, compositors have "dead times" that prevent them from processing and rendering the content in time for the next frame. That's why they end up skipping one frame, causing their refresh rate to drop in half.\n
To avoid this problem, Louvre works with multiple threads. Each output (monitor) renders its content on its own thread, allowing the compositor to continue processing requests and render to other outputs while one is busy. This prevents the compositor from having dead times and therefore allows it to maintain a high refresh rate.

<center>
    <img src="https://lh3.googleusercontent.com/wdXZIQuVM36T8IRdufyMMJjplibF6HhKO-5Y8dklme93S1vxMtGPjXNFH17PtfBF5SsIm6o4TCYkSmQ-a9J2BstZt-nNsuC5iz6EunC1C__Vc1P2l_ZW0lx-UkBKyDuqZIdkQPO69g=w2400"/>
</center>

<h1>Surface Roles</h1>

In Wayland, surfaces are what we typically refer to as "application windows". For a surface to be valid, it must have among other things a role, which dictates the rules for how it should be positioned, hierarchically ordered, and have its geometry interpreted.\n
These rules can be challenging to implement correctly, which is why Louvre handles them for you and provides a standard interface through the Louvre::LBaseSurfaceRole and Louvre::LSurface classes to set and retrieve their attributes.\n
For example, to access the position of a surface based on its role, the Louvre::LSurface::rolePosC() method should be used.\n
If you want to modify its default implementation, you can override the virtual method Louvre::LBaseSurfaceRole::rolePosC() for any role.\n
The Louvre::LBaseSurfaceRole class can also be used to integrate additional surface roles to those included in the library.

<h1>Rendering</h1>

To simplify rendering, the library includes the Louvre::LPainter class which has a set of basic functions for 2D rendering without the need to directly use OpenGL.\n
Each output has its own instance of **LPainter** which can be accessed with Louvre::LOutput::painter().\n
If you want to use your own OpenGL programs and the **LPainter** functions at the same time, remember to call Louvre::LPainter::bindProgram() before using them.

<h1>Scales</h1>

As monitors have increasingly higher resolutions, applications developed for older monitors may appear small on modern displays. To prevent this in Wayland, compositors often ask applications to render their content at double scale. However, as a compositor may render on multiple monitors with different scales simultaneously, it is necessary to define a coordinate system that allows for consistent rendering of surfaces and other graphical content.\n
To address this, Louvre works with three coordinate systems:

<h2>Surface coordinates</h2>

In this system, dimensions are divided by the scale in use. For example, if a surface has a buffer with dimensions (100x100) and a scale of 2, it will be interpreted as (50x50). On the other hand, if the scale is 1, the dimensions will remain the same (100x100). Although this coordinate system is consistent across different scales, it can result in a loss of precision when using scales larger than 1.

<h2>Buffer Coordinates</h2>

In the buffer coordinate system, dimensions do not change based on the scale being used and always represent the highest possible level of detail. However, this system is inconsistent when working with different scales.

<h2>Compositor Coordinates</h2>

In this system, dimensions are transformed to the global scale of the compositor (Louvre::LCompositor::globalScale()). The global scale of the compositor is determined by the largest scale of the initialized outputs. For example, if you are rendering to two monitors with scales 1 and 2, respectively, the global compositor scale would be 2. Unlike the surface coordinate system, the buffer dimensions of a surface are not divided by its scale, instead they are transformed to the global scale of the compositor which prevents loss of precision. This coordinate system is consistent when working with different scales and also allows for the highest level of precision.\n
To know which coordinate system a method or property of a class uses, the library adds suffixes **S**, **B**, and **C** which refer to surface, buffer, and compositor coordinates respectively. For example, the Louvre::LSurface::rolePosC() method returns the position of a surface based on its role in compositor coordinates.\n

> Louvre primarily uses compositor coordinates to simplify development and eliminate the need for frequent transformations.