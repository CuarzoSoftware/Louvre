# Chapter 10: Toplevels

As previously discussed, toplevel surfaces represent the typical windows containing a topbar and buttons for close, minimize, and maximize actions. They are perhaps the most common type of surfaces encountered in a compositor during everyday use.

<center>
<img style="max-width:45vw" src="https://lh3.googleusercontent.com/PvNaxLgkjaPryJ8W_P3bDOccQu1m-zNEcI7aH_R8WggzylV5LQZtuzLTUSImThDI8IVsAI9DERF4cwvSqPAEAyjsihHuPCQlZAbvu33iMC2iXvpTswZC3RBNDyKm1YEWDnnKeCn2Qw=w2400"/>
</center>

Toplevels can either exist independently or serve as children of other toplevels, such as dialogs. The functionality of toplevels is primarily managed within the Louvre::LToplevelRole class. In this chapter, we will learn how to interact with them and handle their various requests.

### State Flags

Toplevel surfaces can exhibit different states, which are listed in the Louvre::LToplevelRole::State flags enum. Among these states, the most common ones include::

* Louvre::LToplevelRole::Activated: When this flag is set, the toplevel's decorations are highlighted above others. Only one toplevel can be active at a time.

* Louvre::LToplevelRole::Maximized: When this flag is enabled, the toplevel typically removes its decorations and occupies a significant portion of the screen.

* Louvre::LToplevelRole::Fullscreen: Enabling this flag typically results in the toplevel removing its decorations and completely occupying the entire screen, always staying displayed above other surfaces.

* Louvre::LToplevelRole::Resizing: This flag indicates an ongoing interactive resizing session, usually initiated when the user drags one of its corners.

To set the state of a toplevel, you can choose from various Louvre::LToplevelRole::configure() variants. This method also accepts the size you wish to assign to the toplevel. If you pass a size of (0,0), the client can determine its own size. You can retrieve the current toplevel state flags using the Louvre::LToplevelRole::states() property.

It's essential to note that the state of a toplevel doesn't change immediately after calling configure. You must wait for the respective property listener to detect when its state has actually changed. For instance, if you configure a toplevel with the Louvre::LToplevelRole::Maximized flag, you should wait for the Louvre::LToplevelRole::maximizedChanged() event to properly position it.

### Window Geometry

The size of a toplevel is not determined by its surface size but by its window geometry (Louvre::LToplevelRole::windowGeometry()). The window geometry specifies the rectangle within the surface that encompasses the actual toplevel window, excluding its decorative elements like shadows. This is the size you should take into account when configuring it.

<center>
<img style="max-width:25vw;min-width:400px" src="https://lh3.googleusercontent.com/pw/AIL4fc9WuCZOWGGC6v7ZepWA7VOWygycmNFEngEHX7J9ODdmzm1Qs4au1KYPMRJ_102tfvOXFBcL-Kwghm0bSKbd4U6der3p94l1drpn3ONqb9yfv-uFgHQ=w2400"/>
</center>

### Decorations

By default, clients handle their own toplevel decorations. However, some applications, like Qt applications, implement the [XDG Decoration](https://wayland.app/protocols/xdg-decoration-unstable-v1) protocol, allowing the compositor to take charge of drawing the decorations.

It's worth noting that this protocol is still somewhat experimental, and only a limited number of clients support it. Therefore, for the purpose of this tutorial, we will focus on client-side decorations. If you're interested in exploring server-side decorations, you can refer to the **louvre-views** example, which creates macOS-style decorations for toplevels that support it.

### Interactive Events

Clients can request to initiate interactive moving or resizing of toplevels, typically triggered by the user clicking on its top bar or one of its corners. We will explore how to handle these requests shortly.

Alright, brace yourselves, folks! We're about to dive into the exciting task of creating our very own Louvre::LToplevelRole subclass. Drum roll, please... Introducing, `EToplevel`! Surprising, right?

#### src/EToplevel.h

```cpp
#ifndef ETOPLEVEL_H
#define ETOPLEVEL_H

#include <LToplevelRole.h>

using namespace Louvre;

class EToplevel : public LToplevelRole
{
public:
    EToplevel(Params *params);

    void configureRequest() override;
};

#endif // ETOPLEVEL_H
```

Here, we're overriding the virtual method Louvre::LToplevelRole::configureRequest(). This method is invoked when the toplevel is created and every time it's mapped again after being unmapped. Within this method, we should call Louvre::LToplevelRole::configure() to properly adjust the states and size of the toplevel.

#### src/EToplevel.cpp

```cpp
#include "EToplevel.h"

EToplevel::EToplevel(Params *params) : LToplevelRole(params) {}

void EToplevel::configureRequest()
{
    // Request the client to draw its own window decorations
    setDecorationMode(ClientSide);

    // Activates the Toplevel with size (0,0) so that the client can decide the size
    configure(LSize(0, 0), states() | LToplevelRole::Activated);
}
```

In this case, we're making a request to the client to utilize client-side decorations. Additionally, we're configuring the toplevel with a size of (0,0), allowing the client to determine its own size. Furthermore, we're adding the Louvre::LToplevelRole::Activated state using the "|" operator. If you're not yet familiar with working with bit flags, you can refer to [this post](https://dietertack.medium.com/using-bit-flags-in-c-d39ec6e30f08) for a detailed guide on handling them.

Additionally, don't overlook its virtual constructor.

#### src/ECompositor.h

```cpp
    // ...

    // Virtual constructors
    LOutput *createOutputRequest() override;
    LSurface *createSurfaceRequest(LSurface::Params *params) override;
    LPointer *createPointerRequest(LPointer::Params *params) override;
    LKeyboard *createKeyboardRequest(LKeyboard::Params *params) override;
    LToplevelRole *createToplevelRoleRequest(LToplevelRole::Params *params) override;

    // ...
```

#### src/ECompositor.h

```cpp
// ...

#include "EToplevel.h"

// ...

LToplevelRole *ECompositor::createToplevelRoleRequest(LToplevelRole::Params *params)
{
    return new EToplevel(params);
}
```

[TODO]

<a href="md_md_tutorial_09.html">◀ Chapter 9: Keyboard Events</a> || <a href="md_md_tutorial_11.html"> Chapter 11: Popups ▶</a>