# Chapter 7: Rendering

Rendering logic in Louvre is executed on the outputs. Each output works on its own thread and has its own shared OpenGL context so that all can access the same textures.\n

# Output Lifecycle

## Initialization

As we saw in the previous chapter, for an output to be able to render, it must first be initialized with Louvre::LCompositor::addOutput().\n
Once initialized, the graphic backend invokes the virtual method Louvre::LOutput::initializeGL() within which initial configuration is often performed, such as compiling shaders, creating programs, loading textures, etc.

## Rendering

Then, each time the Louvre::LOutput::repaint() method is called, the graphic backend will schedule the next rendering frame and invoke the Louvre::LOutput::paintGL() virtual method within which the surfaces and content of the compositor can be rendered.\n

> ⚠️ To schedule a new rendering frame, you must use **repaint()** and never call **paintGL()** directly. This is because each output works on its own thread and some OpenGL resources are not shared between threads/contexts. In addition, calling **paintGL()** directly could waste GPU processing by rendering content multiple times before it is displayed on screen. The **repaint()** method, on the other hand, can be called from any thread and multiple times during the same frame, which does not mean that the **paintGL()** method will be invoked instantly and multiple times, it only ensures that it will be invoked 1 time before the next screen vblank.

## Resizing

If the mode of an initialized output is changed to one with a different resolution than the current one, the Louvre::LOutput::resizeGL() method is invoked within which the output content can be adjusted to the new dimensions.

## Uninitialization

Finally, when an output is removed from the compositor with Louvre::LCompositor::removeOutput(), the Louvre::LOutput::uninitializeGL() method is invoked within which any OpenGL resources created during initialization should be released.

# LPainter

To simplify rendering, the library includes the Louvre::LPainter class which has a set of basic functions for 2D rendering without needing to use OpenGL directly.\n
Each output has its own instance of **LPainter** which can be accessed with Louvre::LOutput::painter().\n
If you want to use your own OpenGL programs and the **LPainter** functions at the same time, remember to call Louvre::LPainter::bindProgram() before using them.

# Reimplementing LOutput

Let's create a new subclass of Louvre::LOutput called MyOutput.\n\n

**MyOutput.h**

<pre class="cpp-code"><span class="add">#ifndef MYOUTPUT_H
#define MYOUTPUT_H

#include <LOutput.h>

using namespace Louvre;

class MyOutput : public LOutput
{
public:
    MyOutput();
};

#endif // MYOUTPUT_H</span></pre>

**MyOutput.cpp**

<pre class="cpp-code"><span class="add">#include <MyOutput.h>
#include <MyCompositor.h>
#include <LPainter.h>
#include <LSurface.h>
#include <LCursor.h>
#include <LOpenGL.h>

MyOutput::MyOutput()
{

}</span></pre>

Now let's rewrite its virtual constructor.\n\n

**MyCompositor.h**

<pre class="cpp-code">
#ifndef MYCOMPOSITOR_H
#define MYCOMPOSITOR_H

#include <LCompositor.h>

using namespace Louvre;

class MyCompositor : public LCompositor
{
public:
    MyCompositor();

    void arrangeOutputs();

    // Virtual methods
    void initialized() override;

    // Virtual constructors
    LOutputManager *createOutputManagerRequest(LOutputManager::Params *params) override;
    <span class="add">LOutput *createOutputRequest() override;</span>
};

#endif // MYCOMPOSITOR_H
</pre>

**MyCompositor.cpp** ( remember to add ```#include <MyOutput.h>``` )

<pre class="cpp-code"><span class="add">LOutput *MyCompositor::createOutputRequest()
{
    return new MyOutput();
}</span></pre>

# initializeGL()

The default implementation of Louvre::LOutput::initializeGL() assigns the color used to clear the screen at the beggining of each frame.\n
Let's override it and assign a different color:

**MyOutput.h**

<pre class="cpp-code">
class MyOutput : public LOutput
{
public:
    MyOutput();
 
    <span class="add">// Virtual methods
    void initializeGL() override;</span>
};
</pre>

**MyOutput.cpp**

<pre class="cpp-code"><span class="add">void MyOutput::initializeGL()
{
    painter()->setClearColor(0.357f, 0.757f, 0.82f, 1.f);
}</span></pre>

If you compile and run the compositor, you will see that the background is now calipso.\n

> Remember you can launch ***weston-terminal*** by pressing **F1** or **fn+F1** and kill the compositor with **Ctrl+Shift+Esc**.

# paintGL() 

Let's override the Louvre::LOutput::paintGL() method to change the default rendering logic:\n

**MyOutput.h**

<pre class="cpp-code">
class MyOutput : public LOutput
{
public:
    MyOutput();
 
    // Virtual methods
    void initializeGL() override;
    <span class="add">void paintGL() override;</span>
};
</pre>

**MyOutput.cpp**

<pre class="cpp-code"><span class="add">void MyOutput::paintGL()
{
    LPainter *p = painter();
    p->clearScreen();
}</span></pre>

If you compile and run the compositor, you will see only the colored background and probably the cursor but not the applications.\n
Let's see how to render them.

## Surfaces

Application windows in Wayland are called surfaces (Louvre::LSurface). Each surface has a buffer (texture), input region, opaque region, damage region, a role, and a position given by its role (in conjunction with the compositor).\n
The Louvre::LCompositor class keeps track of all surfaces created by clients in a list whose order respects the hierarchy defined by their roles.\n
You can access this list with Louvre::LCompositor::surfaces().\n
Surfaces will be discussed in depth in the following chapters, for now let's see how to display them on screen.\n
Let's create a new function **drawSurfaces()** and call it at the end of **paintGL()**.\n\n

**MyOutput.h**

<pre class="cpp-code">
class MyOutput : public LOutput
{
public:
    MyOutput();

    // Virtual methods
    void initializeGL() override;
    void paintGL() override;

    <span class="add">void drawSurfaces();</span>
};
</pre>

**MyOutput.cpp**

<pre class="cpp-code">
<span class="add">void MyOutput::drawSurfaces()
{
    LPainter *p = painter();

    LRect srcRectB, dstRectC;

    for(LSurface *s : compositor()->surfaces())
    {
        srcRectB = LRect(
                    LPoint(0,0),   // Upper left corner of the texture (in buffer coordinates)
                    s->sizeB());   // Width and height of the texture (in buffer coordinates)

        dstRectC = LRect(
                    s->rolePosC(), // Position of the surface according to its role (in compositor coordinates)
                    s->sizeC());   // Size of the surface (in compositor coordinates)

        p->drawTextureC(s->texture(), srcRectB, dstRectC);
    }
}</span>

void MyOutput::paintGL()
{
    LPainter *p = painter();
    p->clearScreen();
    <span class="add">drawSurfaces();</span>
}
</pre>

In **drawSurfaces()**, we are iterating over each surface in the compositor's list and drawing them on screen with the Louvre::LPainter::drawTextureC() method.
The **drawTextureC()** method takes as arguments a texture, a source rectangle or subrectangle of the texture, and the destination rectangle where we want to show it on screen.
In this case, in each iteration we pass the texture of the surface, the source rectangle given by the size of the texture, and the destination rectangle composed of the position of the surface according to its role and its size in compositor coordinates.\n

> All coordinate spaces in Louvre define their origin at the top-left corner.

If you compile and run the compositor, you will notice several strange things:

1. Applications windows do not update their content.
2. The cursor appears duplicated in the upper left corner.
3. Applications do not update their position when dragged, and/or they look blurry.

### Solution to problem 1

To solve the first problem, we must call the Louvre::LSurface::requestNextFrame() method on each surface after we render it.\n\n

**MyOutput.cpp**

<pre class="cpp-code">
void MyOutput::drawSurfaces()
{
    LPainter *p = painter();

    LRect srcRectB, dstRectC;

    for(LSurface *s : compositor()->surfaces())
    {
        srcRectB = LRect(
                    LPoint(0,0),   // Upper left corner of the texture (in buffer coordinates)
                    s->sizeB());   // Width and height of the texture (in buffer coordinates)

        dstRectC = LRect(
                    s->rolePosC(), // Position of the surface according to its role (in compositor coordinates)
                    s->sizeC());   // Size of the surface (in compositor coordinates)

        p->drawTextureC(s->texture(), srcRectB, dstRectC);

        <span class="add">// Notify the client that it is a good time for the surface to render the next frame
        s->requestNextFrame();</span>
    }
}
</pre>

This method is used to prevent applications from updating their content at a higher rate than the monitors they are visible on and to prevent them from wasting processing resources when they are hidden behind other applications or minimized.\n

> ⚠️ As you may have noticed, the way we are currently rendering is not the most optimal since we are clearing the screen and redrawing all surfaces every frame. In the following chapters we will see how to use surface damages and techniques to render efficiently.

### Solution to problem 2

The reason of the second problem is that clients use surfaces to assign the texture of the cursor and therefore these also appear in the compositor's surfaces list. We will see in depth how the library handles cursors in the following chapters. For now, let's avoid rendering surfaces with a cursor role.

**MyOutput.cpp**

<pre class="cpp-code">
void MyOutput::drawSurfaces()
{
    LPainter *p = painter();

    LRect srcRectB, dstRectC;

    for(LSurface *s : compositor()->surfaces())
    {
        <span class="add">// Do not render unmapped or minimized surfaces
        if(!s->mapped() || s->minimized())
            continue;
        // If it has a cursor or DND role, skip but still ask them to update their content
        else if(s->cursor() || s->dndIcon())
            goto callback;</span>

        srcRectB = LRect(
                    LPoint(0,0),   // Upper left corner of the texture (in buffer coordinates)
                    s->sizeB());   // Width and height of the texture (in buffer coordinates)

        dstRectC = LRect(
                    s->rolePosC(), // Position of the surface according to its role (in compositor coordinates)
                    s->sizeC());   // Size of the surface (in compositor coordinates)

        p->drawTextureC(s->texture(), srcRectB, dstRectC);

        // Notify the client that it is a good time for the surface to render the next frame
        <span class="add">callback:</span>
        s->requestNextFrame();
    }
}
</pre>

The added lines prevent the compositor from rendering unmapped surfaces (that do not have a buffer or role), minimized surfaces, and finally, we skip those with a cursor or drag & drop icon role, but still invoke **requestNextFrame()** in case the client wants to update them (update their buffers or modify their hotspot).

### Solution to problem 3

The reason why surfaces might look blurry is that clients do not know on which outputs they are visible and therefore what scale to use to render their content, so they use scale 1 by default.\n
And the reason why the position of the surfaces is not updated is because the library also does not have this information. There are virtual methods in the Louvre::LSurface class that invoke the **repaint()** method by default on the outputs where a surface is visible when its content or position changes. So in order for the library to know on which outputs a surface is visible, we must use the Louvre::LSurface::sendOutputEnterEvent() and Louvre::LSurface::sendOutputLeaveEvent() methods, which update the Louvre::LSurface::outputs() list and also notify the client.\n

> The library does not take care of calculating the outputs on which a surface is visible because it cannot know how the developer will end up positioning and rendering them on screen.

**MyOutput.cpp**

<pre class="cpp-code">
void MyOutput::drawSurfaces()
{
    LPainter *p = painter();

    LRect srcRectB, dstRectC;

    for(LSurface *s : compositor()->surfaces())
    {
        // Skip unmapped or minimized surfaces
        if(!s->mapped() || s->minimized())
            continue;
        // If it has a cursor or DND role, skip but still request next frame
        else if(s->cursor() || s->dndIcon())
            goto callback;

        srcRectB = LRect(
                    LPoint(0,0),   // Upper left corner of the texture (in buffer coordinates)
                    s->sizeB());   // Width and height of the texture (in buffer coordinates)

        dstRectC = LRect(
                    s->rolePosC(), // Position of the surface according to its role (in compositor coordinates)
                    s->sizeC());   // Size of the surface (in compositor coordinates)

        p->drawTextureC(s->texture(), srcRectB, dstRectC);

        callback:

        <span class="add">// Calculate which initialized outputs intersect the surface
        for(LOutput *o : compositor()->outputs())
        {
            if(o->rectC().intersects(dstRectC))
                s->sendOutputEnterEvent(o);
            else
                s->sendOutputLeaveEvent(o);
        }</span>

        // Notify the client that it is a good time for the surface to render the next frame
        s->requestNextFrame();
    }
}
</pre>

The added lines iterate through the outputs initialized by the compositor and check if the destination rectangle of the surface intersects them.
If it does, the **sendOutputEnterEvent()** method is called and **sendOutputLeaveEvent()** otherwise.\n

> It is safe to call these methods multiple times with the same output as an argument, the library internally checks if the output exists in the list and if the client has already been notified.

# Cursor

The library includes the Louvre::LCursor class to efficiently display cursors on the screen through hardware composition, thus avoiding repainting the outputs each time the cursor moves. However, some graphic backends or video cards do not support this feature and therefore the cursor must be drawn manually with OpenGL.\n
To check if the backend supports hardware composition, the Louvre::LCursor::hasHardwareSupport() method can be used.\n
Let's create a new function **drawCursor()** and call it at the end of **paintGL()**:

**MyOutput.h**

<pre class="cpp-code">
class MyOutput : public LOutput
{
public:
    MyOutput();

    // Virtual methods
    void initializeGL() override;
    void paintGL() override;

    void drawSurfaces();
    <span class="add">void drawCursor();</span>
};
</pre>

**MyOutput.cpp**

<pre class="cpp-code"><span class="add">void MyOutput::drawCursor()
{
    // Render the cursor if hardware composition is not supported
    if(!cursor()->hasHardwareSupport())
    {
        painter()->drawTextureC(
            cursor()->texture(),
            LRect(0,cursor()->texture()->sizeB()), // (0,0,w,h)
            cursor()->rectC());
    }
}</span>

void MyOutput::paintGL()
{
    LPainter *p = painter();
    p->clearScreen();

    drawSurfaces();
    <span class="add">drawCursor();</span>
}
</pre>

We draw the cursor (if hardware compositing is not supported) after rendering the surfaces so that it always appears on top of them.\n

> Note that we are not using any surface with a cursor role, instead we are using the single instance of Louvre::LCursor of the compositor.

# Drag & drop icons

The drag & drop icon role is used by clients when dragging a resource between surfaces (images, files, text, etc).\n
Let's create a new function **drawDNDIcon()** and call it at the end of **paintGL()** before **drawCursor()**.\n\n

**MyOutput.h**

<pre class="cpp-code">
class MyOutput : public LOutput
{
public:
    MyOutput();

    // Virtual methods
    void initializeGL() override;
    void paintGL() override;

    void drawSurfaces();
    <span class="add">void drawDNDIcon();</span>
    void drawCursor();
};
</pre>

**MyOutput.cpp**

<pre class="cpp-code"><span class="add">void MyOutput::drawDNDIcon()
{
    // Check if there is an ongoing drag & drop session with an icon
    if(seat()->dndManager()->icon())
    {
        LSurface *s = seat()->dndManager()->icon()->surface();

        if(!s->mapped())
            goto callbackDND;

        // Set the position of the icon to be the same as the cursor's position
        s->setPosC(cursor()->posC());

        // Draw the drag & drop icon
        painter()->drawTextureC(
                    s->texture(),
                    LRect(0, s->sizeB()),
                    LRect(s->rolePosC(),s->sizeC()));

        callbackDND:
        s->requestNextFrame();
    }
}</span>

void MyOutput::paintGL()
{
    LPainter *p = painter();
    p->clearScreen();

    drawSurfaces();
    <span class="add">drawDNDIcon();</span>
    drawCursor();
}
</pre>

First we check if there is an ongoing drag & drop session with an icon, then we check if the icon is mapped, if it is, we set its position to be the same as the cursor's position and render it.\n
Run **weston-dnd** from **weston-terminal** and test dragging the figures to other windows or changing their position..

<center>
    <img src="https://lh3.googleusercontent.com/4u7kK5OyLuRY95Mpe-KSXAMpaH2yzaUJvGYeuTjl7QQy40F3tjBGtZCCfpZmCfFn2qtlq6xa0M51pSznEtzDwwHiocOMHNIZe8Nfp_tvIULSc3uMMxW_IZScTt3OCut40oaQeWFAGg=w2400"/>
</center><br>

> If your monitor has high definition, you may notice that **weston-dnd** looks blurry. This is because it is a simple Wayland client and does not handle multiple scales (it always uses scale 1). Without using compositor coordinates, **weston-dnd** would appear tiny..

# Background texture

Let's change the background color for an image. To do this, find a PNG image and place it in the directory where the compositor's executable is located.\n
Now, define a pointer to a texture (Louvre::LTexture) and a new function **drawBackground()** in **MyOutput.h**.\n\n

**MyOutput.h**

<pre class="cpp-code">
class MyOutput : public LOutput
{
public:
    MyOutput();

    <span class="add">LTexture *backgroundTexture;</span>

    // Virtual methods
    void initializeGL() override;
    void paintGL() override;

    <span class="add">void drawBackground();</span>
    void drawSurfaces();
    void drawDNDIcon();
    void drawCursor();
};
</pre>

In **initializeGL()** let's replace the line that assigns the background color and use the segment to load the image:\n\n

**MyOutput.cpp**

<pre class="cpp-code">
void MyOutput::initializeGL()
{
    <span class="add">backgroundTexture = LOpenGL::loadTexture("wallpaper.png");

    // Validate it is successfully loaded
    if(!backgroundTexture)
    {
        LLog::fatal("Could not load the background texture.");
        compositor()->finish();
    }</span>
}

<span class="add">void MyOutput::drawBackground()
{
    painter()->drawTextureC(backgroundTexture,           // Background texture
                    LRect(0,backgroundTexture->sizeB()), // Entire texture rect
                    rectC());                            // Current output's rect
}</span>
</pre>

Remember to replace *wallpaper.png* with the name of your image.\n

> To see messages generated by Louvre::LLog::fatal() in the console, you must assign the environment variable **LOUVRE_DEBUG** to an integer greater than 0.

And in **paintGL()**, replace the line ```p->clearScreen();``` with ```drawBackground();```.\n\n

**MyOutput.cpp**

<pre class="cpp-code">
void MyOutput::paintGL()
{
    <span class="add">drawBackground();</span>
    drawSurfaces();
    drawDNDIcon();
    drawCursor();
}
</pre>

If you compile and run the compositor, you will see that the background image is now displayed.\n

<center>
    <img src="https://lh3.googleusercontent.com/cb_2LIT88tlWNFiVDJMFYDNgf3akajxAmnQcC5KR5IlB2FfTBHmjjHVx2M9g0oaTbLrI_jKdFgDPUFhBN8-7zXdT1lBIxDv-ZA91xI9MtAeCJpGE8gYnKj_UQ7KbUJJh18jk1_sVaA=w2400"/>
</center>

Finally, reimplement the virtual method **uninitializeGL()** to delete the texture when the output is uninitialized:\n\n

**MyOutput.h**

<pre class="cpp-code">
class MyOutput : public LOutput
{
public:
    MyOutput();

    LTexture *backgroundTexture;

    // Virtual methods
    void initializeGL() override;
    void paintGL() override;
    <span class="add">void uninitializeGL() override;</span>

    void drawBackground();
    void drawSurfaces();
    void drawDNDIcon();
    void drawCursor();
};
</pre>

**MyOutput.cpp**

<pre class="cpp-code">
<span class="add">void MyOutput::uninitializeGL()
{
    delete backgroundTexture;
}</span>
</pre>

# Minimized windows menu

Let's add a menu in the top region of the screen to show thumbnails of minimized surfaces.\n
To do this, first define the height of the menu and the margin of the thumbnails in a macro in **MyCompositor.h** so that it is accessible from multiple classes.

**MyCompositor.h**

<pre class="cpp-code">
<span class="add">#define MENU_H 32
#define MINI_M 4</span>
</pre>

Now let's create a new function **drawMenu()** and call it at the end of **paintGL()** before rendering the drag & drop icon.\n\n

**MyOutput.h**

<pre class="cpp-code">
class MyOutput : public LOutput
{
public:
    MyOutput();

    LTexture *backgroundTexture;

    // Virtual methods
    void initializeGL() override;
    void paintGL() override;
    void uninitializeGL() override;

    void drawBackground();
    void drawSurfaces();
    <span class="add">void drawMenu();</span>
    void drawDNDIcon();
    void drawCursor();
};
</pre>

**MyOutput.cpp**

<pre class="cpp-code">
<span class="add">void MyOutput::drawMenu()
{
    // The height of the menu in surface coordinates is multiplied by the global scale to transform it to compositor coordinates
    Int32 menuH = MENU_H * compositor()->globalScale();
    
    // Render the menu background
    p->drawColorC(LRect(posC(),LSize(sizeC().w(),menuH)), // (pos_x_salida, pos_y_salida, ancho_salida, altura_menu)
                  1.f,
                  1.f,
                  1.f,
                  0.9f);
}</span>

void MyOutput::paintGL()
{
    drawBackground();
    drawSurfaces();
    <span class="add">drawMenu();</span>
    drawDNDIcon();
    drawCursor();
}
</pre>

We can consider that the menu height (32) and the margin (4) are in surface coordinates, or in other words, as if they were the size in pixels on a low-definition output with scale 1.\n
To convert it to compositor coordinates, we must multiply it by the global scale. This way, if we change the scale of the output, or render on multiple outputs with different scales, the menu height and margin will be consistent.\n
The Louvre::LPainter::drawColorC() method allows to draw solid color rectangles. In this case we are drawing a semi-transparent white rectangle as the background of the menu, with the calculated height and the width of the output.

<center>
    <img src="https://photos.app.goo.gl/VmAF6gCkeu6Uweoh8"/>
</center>

Now let's draw the thumbnails of the minimized surfaces.\n
To do this, add the following lines at the end of **drawMenu()**:\n\n

**MyOutput.cpp**

<pre class="cpp-code">
<span class="add">// Draw the minimized surfaces
Int32 miniM = MINI_M * compositor()->globalScale(); // Margin of the thumbnails with the menu and between them
Int32 miniH = menuH - 2 * miniM;                    // Height of the thumbnails (height of the menu - 2 times the margin)
Int32 miniW;                                        // Width of the thumbnail (calculated on each iteration)
Int32 miniX = posC().x() + miniM;                   // X position of the thumbnail (initialized with the output position + the margin value)

for(LSurface *s : compositor()->surfaces())
{
    if(s->minimized() && s->mapped())
    {
        // We calculate the width while maintaining the original aspect ratio
        miniW = (s->sizeB().w()  *miniH) / s->sizeB().h();

        // We draw the thumbnail
        p->drawTextureC(s->texture(),
                        LRect(0,s->sizeB()),
                        LRect(miniX, miniM, miniW, miniH));

        // We calculate the X position of the next one
        miniX += miniW + miniM;
    }
}</span>
</pre>

First, we transform the margin to compositor coordinates and then calculate the height of the thumbnails by subtracting 2 times the margin from the height of the menu.\n
In the loop, we iterate the surfaces again, but this time we only render the ones that are mapped and minimized.\n
If you compile and run the compositor and minimize a surface, you will see its thumbnail appear in the menu.\n
You can press **F8** or **fn+F8** to un-minimize them.\n

> If you want your thumbnails to keep updating, add the **requestNextFrame()** method at the end of each iteration.
\n

<center>
    <img src="https://lh3.googleusercontent.com/b4lRF-Gt46BmJ1Ovb-YjkxvMGQgBVLRwMKymGsRM_ZZzTnC4cKe205GuxZ_DweuwuZPY4Nv1CMulG-GzMpETfwJxhYt5PlCBDe6584VaRqdoRJZlTGCyU6fD0Jjbo4JAkN-E-Zw9Ng=w2400"/>
</center>

You may notice that when moving, scaling or maximizing surfaces, they may end up being positioned behind the menu which does not look visually pleasing. In the upcoming sections, we will explore ways to address this issue and implement the functionality of un-minimizing a particular surface by clicking on its thumbnail in the menu.