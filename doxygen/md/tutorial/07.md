# Chapter 7: Surfaces

You may already have an idea of what a surface is, but let's clarify it. Think of a surface as a canvas created by a Wayland client, which the compositor can render on the screen. The client can request the compositor to use it as a cursor, a drag & drop icon, a toplevel window, and so on. This specific use assigned by the client is known as the surface role. Each surface role provides instructions on how the compositor should position, stack, and interact with it.

You can determine the assigned role of a surface using Louvre::LSurface::roleId() and access it through Louvre::LSurface::role(). Alternatively, you can directly parse it using functions like Louvre::LSurface::cursorRole(), Louvre::LSurface::dndIcon(), Louvre::LSurface::toplevel(), etc. For example, to check if a surface has a toplevel role, you can call Louvre::LSurface::toplevel(), which may return a Louvre::LToplevelRole instance or nullptr if it has a different role or none at all. We will delve into the details of each specific role in future chapters, so please be patient.

### Position

As mentioned earlier, each role provides information on how the compositor should position the surface. Typically, this position is either a local offset relative to another surface or an offset relative to a position of your choice. For instance, toplevel surfaces for example, representing typical app windows with a title bar, close, minimize, and maximize buttons, often have window decorations such as shadows. 
When positioning a toplevel window, you want to place it relative to its top-left corner but ignore its decorations. This is why toplevels offer a window geometry rect (Louvre::LToplevelRole::windowGeometry()) that specifies which part of its texture belongs to the window and which part constitutes decorations. 

<center>
<img style="width:25vw" src="https://lh3.googleusercontent.com/pw/AIL4fc9WuCZOWGGC6v7ZepWA7VOWygycmNFEngEHX7J9ODdmzm1Qs4au1KYPMRJ_102tfvOXFBcL-Kwghm0bSKbd4U6der3p94l1drpn3ONqb9yfv-uFgHQ=w2400"/>
</center>

The role doesn't dictate where to position the toplevel but provides the offset necessary for correct positioning.

To set the position of a surface, you can use Louvre::LSurface::setPos(). If you call Louvre::LSurface::pos(), it will return the same position. However, if you call Louvre::LSurface::rolePos() and the surface has a toplevel role, it will return the position you assigned minus the decoration offset. In this case, Louvre::LSurface::rolePos() internally invokes Louvre::LToplevelRole::rolePos().
Louvre implements the default position logic for each role, but you have the option to override it if needed. However, it's worth noting that certain positioning rules can be challenging to implement, such as Louvre::LPopupRole::rolePos().

Now, let's consider another example: the subsurface role (Louvre::LSubsurfaceRole). A subsurface is always a child of another surface and is positioned relative to the parent surface's position. In this case, the position set with Louvre::LSurface::setPos() is disregarded, and Louvre::LSurface::rolePos() simply returns the parent surface's position plus the offset defined by the client (check Louvre::LSubsurfaceRole::rolePos()).

In summary, always use Louvre::LSurface::setPos() to set the surface position as desired, and utilize Louvre::LSurface::rolePos() when rendering it.

### Size and Scale

A surface's size is determined by its texture size and its scale. When you use Louvre::LSurface::sizeB(), it returns the texture size, disregarding the scale. Conversely, Louvre::LSurface::size() provides the size in surface coordinates, which is the texture size divided by the scale.

Just as we've seen with outputs, a client may render the surface content in a HiDPI buffer when displayed on a HiDPI output. In such cases, it informs us that it's using a scale of 2 (or greater), allowing us to render it properly.

### Stacking Order

As we've seen before, the Louvre::LCompositor class maintains a list of all client surfaces that defines the stacking order (Louvre::LCompositor::surfaces()).\n
Certain surface roles require us to adhere to their provided stacking order, such as Louvre::LSubsurfaceRole and Louvre::LPopupRole.

<center>
<img style="width:35vw" src="https://lh3.googleusercontent.com/6caGayutKKWqndpd6ogno2lPw8XGELxnFums4gvkWZKOJYO0762yVG3mHLrc1rw63r1eEJabEdW9F5AA2BDTFCtpB_hiPlTY4FkKlHfH1B-2MdLvXCD6RuwZOZvhOl6EhydtsOYGPw=w2400"/>
</center>

You have the flexibility to modify this order tho, for example, by calling Louvre::LSurface::raise(). This action brings the specified surface to the top while ensuring that the stacking order of its role (or other surfaces' roles) is respected, so it may raise other surfaces as well. 

Additionally, you can detect when the order of a surface changes in the list, overriding the Louvre::LSurface::raised() and Louvre::LSurface::orderChanged() virtual methods.

To determine which surface is positioned behind or in front of a particular surface, you can use Louvre::LSurface::prevSurface() and Louvre::LSurface::nextSurface(). However, be careful, as these functions might return nullptr if the surface is at the beginning or end of the surfaces list.

## Rendering Surfaces

Hoping that all that theory didn't bore you to death, it's now time to delve into something more enjoyable â€“ rendering the surfaces in our scene. To achieve this, we'll make use of the Louvre::LSurfaceView. This view inherits all the properties of the surface, like Louvre::LSurface::rolePos() for positioning, Louvre::LSurface::size() to determine its size, and other attributes like opaque/translucent regions, damage, and more.

So, let's get started by creating our very own Louvre::LSurface subclass, and guess what? We'll name it `ESurface`.

#### src/ESurface.h

```cpp
#ifndef ESURFACE_H
#define ESURFACE_H

#include <LSurface.h>
#include <LSurfaceView.h>

using namespace Louvre;

class ESurface : public LSurface
{
public:
    ESurface(LSurface::Params *params);

    void roleChanged() override;
    void orderChanged() override;

    LSurfaceView view;
};

#endif // ESURFACE_H
```

Here, we're overriding the Louvre::LSurface::roleChanged() method because we want to exclude certain roles from rendering, such as the cursor role.

Additionally, we're overriding Louvre::LSurface::orderChanged() method, which we will use for updating the view's stacking order.

Lastly, we've introduced an Louvre::LSurfaceView for rendering the surface within the scene.

#### src/ESurface.cpp

```cpp
#include "ESurface.h"
#include "Global.h"
#include "ECompositor.h"

ESurface::ESurface(Params *params) :
    LSurface(params),
    view(this, &G::compositor()->surfacesLayer)
{

}

void ESurface::roleChanged()
{
    if (cursorRole())
        view.setVisible(false);
}

void ESurface::orderChanged()
{
    ESurface *prev = (ESurface*)prevSurface();

    if (prev)
        view.insertAfter(&prev->view, false);
    else
        view.insertAfter(nullptr, false);
}
```

In the constructor, we initialize both the Louvre::LSurface parent class and Louvre::LSurfaceView, adding it to the surfaces layer.

In the `roleChanged()` method we hide the views that get assigned the cursor role.

In the `orderChanged()` method, we update the view stacking order with LView::insertAfter(). This inserts the view on top of the surface that precedes it in the surfaces list. If there's no previous surface, we pass nullptr, which places the view at the beginning of its parent's children list.

You might also notice the `false` second parameter. This setting prevents the view from changing its parent if the view we are inserting it after belongs to another parent.

Finally, to make Louvre use our subclass, we need to override the Louvre::LCompositor::createSurfaceRequest() virtual constructor:

#### src/ECompositor.h

```cpp
// ...

// Virtual constructors
LOutput *createOutputRequest() override;
LSurface *createSurfaceRequest(LSurface::Params *params) override;

// ...
```

#### src/ECompositor.cpp

```cpp
// ...

#include "ESurface.h"

// ...

LSurface *ECompositor::createSurfaceRequest(LSurface::Params *params)
{
    return new ESurface(params);
}
```

The Louvre::LSurface::Params simply contain Wayland resources and parameters necessary for Louvre to correctly construct each Louvre::LSurface instance.

If you recompile and run the compositor now, you should see the application windows coming back to life. Also, don't forget that you can press `F1` to launch weston-terminal and `Ctrl + Shift + Esc` to exit the compositor.

You may also notice that windows can go behind the topbar, which is an undesired behavior.

<img src="https://lh3.googleusercontent.com/pw/AIL4fc-CzFx_i21hL8QQ8qoMW4mFinMsrvMEJLj6p4VqxZam_I7Nxq6n3QhNDsTrSZWJ6hcURGPFt57IOUlGnj7xptqlfvC3X3jP3oGv__AubCGWWSvWxlI=w2400"/>

We will address how to fix that later. In the meantime, I'll share a tip for checking if Louvre::LScene is drawing efficiently.\n
It's a good practice to use this trick occasionally to ensure it's working correctly, as there could be something causing inefficient rendering.

To do this, let's go to the `paintGL()` implementation in `EOutput.cpp` and clear the output screen before calling Louvre::LScene::handlePaintGL().

#### src/ECompositor.cpp

```cpp
// ...

void EOutput::paintGL()
{
    painter()->clearScreen();
    G::scene()->handlePaintGL(this);
}

// ...
```

Recompile and run the compositor, then launch an app like gedit. You'll notice that only the parts of the window that change, such as when you hover the mouse over a button or move a window, are rendered. However, please note that weston-terminal is a poor example of a client because it damages the entire window, even if only a small part of its surface changes.

So, if you consistently observe that the entire screen is being rendered in every frame, it's likely due to an issue in your implementation.

In the next chapter, we'll explore how to handle pointer events, which involve input from devices like a mouse, touchpad, and more.

Until next time!

Recompile and run the compositor and launch an app like for example gedit. You will see than the only things that get rendered are the parts of the window that change, like when you hover the mouse on a button, or move a window.
weston-terminal, it's a bad client example because it damages the entire window, even if only a small part of its surface changes.
So, if you try this, and you always see that the entire screen is rendered each frame, its probably because you are doing somehting wrong.\n
Delete the 'painter()->clearScreen();' line to restore your compositor to its normal state.

In the next chapter we will see how to handle pointer events, that is, input event from devices like a mouse, touchpad, etc.

Till the next one.

<a href="md_md_tutorial_06.html">â—€ Chapter 6: Rendering with LScene and LViews</a> || <a href="md_md_tutorial_06.html"> Chapter 8: Pointer Events â–¶</a>