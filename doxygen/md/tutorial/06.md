# Chapter 6: Rendering with LScene and LViews

In the previous chapter, we explored the challenges of rendering efficiently using Louvre::LPainter. In this chapter, we'll shift our focus to the Louvre::LScene and Louvre::LView system.

A single Louvre::LScene efficiently manages rendering across all outputs by overseeing multiple child and subchild Louvre::LView instances. You only need to define the stacking order, position, and size of each view, and Louvre::LScene automatically optimizes output rendering for you.

Louvre offers various specialized Louvre::LView types, and you can even create your own ones. These views cater to various purposes, including layer grouping, texture and surface display, solid color rectangles, and nested scenes.

Each view can host multiple child views and has a single parent. Rendering order begins with the parent view and proceeds to its children (from bottom to top), adhering to the sequence defined in the children list.

### Layers

First, let's establish the structure of our scene. We will create four layers as follows:

1. **Background Layer**: This layer will host views that should always remain behind everything else, such as our wallpaper.
2. **Surfaces Layer**: Typically, this is where all client surfaces will reside.
3. **Overlay Layer**: Here, we'll position overlay UI elements, like a topbar.
4. **Fullscreen Layer**: Toplevel surfaces in fullscreen mode will be displayed here.

To implement this, we'll create our scene and layers within our `ECompositor` class, ensuring accessibility from any part of our code.

#### src/ECompositor.h

```cpp
#ifndef ECOMPOSITOR_H
#define ECOMPOSITOR_H

#include <LCompositor.h>
#include <LScene.h>
#include <LLayerView.h>

using namespace Louvre;

class ECompositor : public LCompositor
{
public:
    ECompositor();

    void initialized() override;

    // Virtual constructors
    LOutput *createOutputRequest() override;

    // Scene and layers
    LScene scene;
    LLayerView backgroundLayer, surfacesLayer,
        overlayLayer, fullscreenLayer;
};

#endif // ECOMPOSITOR_H
```

#### src/ECompositor.cpp

```cpp
#include <LOutput.h>
#include <LSceneView.h>
#include "ECompositor.h"
#include "EOutput.h"

ECompositor::ECompositor() : LCompositor(),
    scene(),
    backgroundLayer(scene.mainView()),
    surfacesLayer(scene.mainView()),
    overlayLayer(scene.mainView()),
    fullscreenLayer(scene.mainView())
{
    scene.mainView()->setClearColor(0.f, 0.f, 0.f, 1.f);
}

// ...
```

Here, we're constructing the scene and layers, making them children of Louvre::LScene::mainView(). Additionally, we're defining the default background color for the Louvre::LScene.

> Note that the order in which we add the layers to the scene is the order in which will be rendered, from bottom to top.

### Integrating LScene with LOutput

To enable our scene to render into our outputs, we need to "plug it" like this:

#### src/EOutput.cpp

```cpp
#include <LPainter.h>
#include <LTexture.h>
#include <LOpenGL.h>
#include <LLog.h>
#include <LDNDManager.h>
#include <LCompositor.h>
#include <LCursor.h>
#include <LSeat.h>
#include "EOutput.h"
#include "ECompositor.h"

EOutput::EOutput() {}

void EOutput::initializeGL()
{
    ECompositor *comp = (ECompositor*)compositor();
    comp->scene.handleInitializeGL(this);
    repaint();
}

void EOutput::moveGL()
{
    ECompositor *comp = (ECompositor*)compositor();
    comp->scene.handleMoveGL(this);
    repaint();
}

void EOutput::resizeGL()
{
    ECompositor *comp = (ECompositor*)compositor();
    comp->scene.handleResizeGL(this);
    repaint();
}

void EOutput::paintGL()
{
    ECompositor *comp = (ECompositor*)compositor();
    comp->scene.handlePaintGL(this);
}

void EOutput::uninitializeGL()
{
    ECompositor *comp = (ECompositor*)compositor();
    comp->scene.handleUninitializeGL(this);
}
```

It's crucial to plug the scene into all these events, as it needs to initialize resources before it can handle `paintGL()` calls and release resources when an output is uninitialized.

If you recompile and run the compositor, you may notice that you only see a black background because we've only added layer views, which are invisible by their own.

You might have also observed that we constantly need to cast Louvre::LCompositor into our own `ECompositor` subclass, which can become cumbersome and verbose over time. To streamline this, let's create a global class called "G" to store quick access to global variables like that, eliminating the need for repetitive casting.

#### src/Global.h

```cpp
#ifndef G_H
#define G_H

#include <LCompositor.h>

class ECompositor;

class G
{
public:
    static inline ECompositor *compositor()
    {
        return (ECompositor*)LCompositor::compositor();
    }

    static LScene *scene();
};

#endif // G_H
```

#### src/Global.cpp

```cpp
#include "Global.h"
#include "ECompositor.h"

LScene *G::scene()
{
    return &compositor()->scene;
}
```

Now, we can quickly access our compositor and scene from anywhere using `G::compositor()` and `G::scene()`, we only need to include the `Global.h` header of course.

### Wallpaper

Let's explore how to display our wallpaper in a more sophisticated manner. This time, we'll ensure the texture covers the output while maintaining its aspect ratio, rather than simply scaling it to the output size like before.

To display the wallpaper, we can use Louvre::LTextureView.

#### src/EOutput.h

```cpp
#ifndef EOUTPUT_H
#define EOUTPUT_H

#include <LOutput.h>

using namespace Louvre;

class EOutput : public LOutput
{
public:
    EOutput();

    void initializeGL() override;
    void moveGL() override;
    void resizeGL() override;
    void paintGL() override;
    void uninitializeGL() override;

    LTextureView *wallpaperView = nullptr;
    void updateWallpaper();
};

#endif // EOUTPUT_H
```

Notice that we've replaced the wallpaper Louvre::LTexture pointer with an Louvre::LTextureView and added an `updateWallpaper()` function. Within this function, we will accurately clip and scale our wallpaper each time the output size changes.

#### src/EOutput.cpp

```cpp
#include <LPainter.h>
#include <LTexture.h>
#include <LOpenGL.h>
#include <LLog.h>
#include <LDNDManager.h>
#include <LCompositor.h>
#include <LCursor.h>
#include <LSeat.h>
#include <LTextureView.h>
#include "EOutput.h"
#include "ECompositor.h"
#include "Global.h"

EOutput::EOutput() {}

void EOutput::initializeGL()
{
    wallpaperView = new LTextureView(nullptr, &G::compositor()->backgroundLayer);
    updateWallpaper();
    G::scene()->handleInitializeGL(this);
    repaint();
}

void EOutput::moveGL()
{
    wallpaperView->setPos(pos());
    G::scene()->handleMoveGL(this);
    repaint();
}

void EOutput::resizeGL()
{
    updateWallpaper();
    G::scene()->handleResizeGL(this);
    repaint();
}

void EOutput::paintGL()
{
    G::scene()->handlePaintGL(this);
}

void EOutput::uninitializeGL()
{
    G::scene()->handleUninitializeGL(this);

    // Delete the wallpaper texture first
    if (wallpaperView->texture())
    {
        delete wallpaperView->texture();
        wallpaperView->setTexture(nullptr);
    }

    // Then delete the wallpaper view
    delete wallpaperView;
}

void EOutput::updateWallpaper()
{
    if (wallpaperView->texture())
    {
        // If the current wallpaper size is equal to the output size
        // then the output simply changed its scale
        if (wallpaperView->texture()->sizeB() == sizeB())
        {
            wallpaperView->setBufferScale(scale());
            wallpaperView->setPos(pos());
            return;
        }

        delete wallpaperView->texture();
        wallpaperView->setTexture(nullptr);
    }

    // Load the original wallpaper
    LTexture *originalWallpaper = LOpenGL::loadTexture("../wallpaper.jpg");

    if (!originalWallpaper)
    {
        LLog::error("[louvre-example] Failed to load wallpaper.jpg image.");
        return;
    }

    // Calculate the src wallpaper rect we need to copy and scale to cover the entire output
    // keeping the image aspect ratio
    LRect srcB = LRect(0);
    float w = float(size().w() * originalWallpaper->sizeB().h()) / float(size().h());
    if (w >= originalWallpaper->sizeB().w())
    {
        srcB.setW(originalWallpaper->sizeB().w());
        srcB.setH((originalWallpaper->sizeB().w() * size().h()) / size().w());
        srcB.setY((originalWallpaper->sizeB().h() - srcB.h()) / 2);
    }
    else
    {
        srcB.setH(originalWallpaper->sizeB().h());
        srcB.setW((originalWallpaper->sizeB().h() * size().w()) / size().h());
        srcB.setX((originalWallpaper->sizeB().w() - srcB.w()) / 2);
    }

    // Copy a sub rect of the original wallpaper and scale it to match
    // the output buffer size
    wallpaperView->setTexture(originalWallpaper->copyB(sizeB(), srcB));

    // We also need to match the output scale
    wallpaperView->setBufferScale(scale());

    // Delete the original wallpaper since we are using the scaled copy
    delete originalWallpaper;
    wallpaperView->setPos(pos());
}
```

This is indeed a lot of information to digest, so let's break it down step by step. In the `initializeGL()` function, we are creating our wallpaper view without attaching a texture to it yet and adding it to the background layer. We also call our new `updateWallpaper()` method.

Within the `updateWallpaper()` method, we perform the following steps:

1. We delete the previous wallpaper if there was any.
2. We load the original wallpaper image again.
3. We create a clipped and scaled version using the Louvre::LTexture::copyB() method to ensure it covers the entire output while maintaining the wallpaper's original aspect ratio.
4. We update the wallpaper buffer scale and position.

It's important to note that each Louvre::LTextureView has a default buffer scale of 1. Since we are setting the buffer size of the texture to match the output buffer size, we also need to ensure their scales match. This is because Louvre::LScene internally utilizes Louvre::LPainter for rendering, and it expects the position and size of each view to be in surface coordinates. If the output is HIDPi and we assign it a scale of 2, while keeping the wallpaper view at a scale of 1, it would appear twice as big. This may sound counterintuitive, but think of it this way, if both the wallpaper and the output have a scale of 2, then no transformations are required by Louvre::LPainter to render the view on the output. On the other hand, if we render the same view on an output with a scale of 1 (low DPI), Louvre::LPainter would scale the view from a scale of 2 to 1 by dividing its buffer size by 2, ensuring it appears correctly on this low DPI output.

For a more in-depth understanding of how views are managed within a scene, please refer to the documentation for Louvre::LView.

In `moveGL()`, we simply set the wallpaper position equal to the output position. 

In `resizeGL()`, we again call `updateWallpaper()` so that it gets resized to match the new output resolution or scale.

Finally, in `uninitializeGL()`, we check if the wallpaper view has a texture attached and delete it before deleting the view itself. It's worth noting that a texture is not automatically deleted when a view using it is deleted. This is because you can use the same texture in multiple views at a time. However, you need to be cautious when deleting the texture and set the view's texture to `nullptr`. Doing so hides the view and prevents the scene from trying to access the texture, which could lead to a segmentation fault.

Try recompiling and running the compositor again, and you should see your wallpaper displayed.

### Topbar

Now, let's create a topbar that will serve as the designated space for displaying minimized window thumbnails.\n
Instead of opting for a straightforward Louvre::LSolidColorView to display a solid color rectangle, we're taking a more versatile approach by introducing a custom class called `ETopbar`.

First, let's define the top bar's height in a macro within the `Global.h` header for easy access, as we'll be using it in various parts of our code.

#### src/Global.h

```cpp
#ifndef G_H
#define G_H

#include <LCompositor.h>

#define TOPBAR_HEIGHT 38

// ...

#endif // G_H
```

I'm using 38, but feel free to adjust it to your preference.

#### src/ETopbar.h

```cpp
#ifndef ETOPBAR_H
#define ETOPBAR_H

#include <LSolidColorView.h>

using namespace Louvre;

class EOutput;

class ETopbar : public LObject
{
public:
    ETopbar(EOutput *output);

    EOutput *output = nullptr;
    LSolidColorView view;

    void update();
};

#endif // ETOPBAR_H
```

In this class, we receive an `EOutput` object as a constructor parameter, which we store in the `output` variable. This enables us to precisely adjust the top bar's size and position relative to its associated output when needed.

Additionally, we've integrated a Louvre::LSolidColorView as the visual representation of the top bar within the scene.

Lastly, we've introduced an `update()` method, responsible for dynamically managing the top bar's position, size, and handling child thumbnail elements as necessary.

#### src/ETopbar.cpp

```cpp
#include "ECompositor.h"
#include "ETopbar.h"
#include "EOutput.h"
#include "Global.h"

ETopbar::ETopbar(EOutput *output) :
    output(output),
    view(1.f, 1.f, 1.f, 0.9f, &G::compositor()->overlayLayer)
{
    update();
}

void ETopbar::update()
{
    view.setSize(output->size().w(), TOPBAR_HEIGHT);
    view.setPos(output->pos());
}
```

In the constructor, we're straightforwardly storing the `output` variable. Additionally, we initialize the `view` by setting it to a white, semi-translucent color and making it a child of the overlay layer.

In the `update` function, we ensure that the top bar's width matches the output width, and we set its height to `TOPBAR_HEIGHT`. We also position it at the same coordinates as the output.

Now we only need to create it from its respective output:

#### src/EOutput.h

```cpp
#ifndef EOUTPUT_H
#define EOUTPUT_H

#include <LOutput.h>

using namespace Louvre;

class ETopbar;

class EOutput : public LOutput
{
public:
    EOutput();

    // ...

    ETopbar *topbar = nullptr;
};

#endif // EOUTPUT_H
```

#### src/EOutput.cpp

```cpp
// ...

#include "ETopbar.h"

EOutput::EOutput() {}

void EOutput::initializeGL()
{
    wallpaperView = new LTextureView(nullptr, &G::compositor()->backgroundLayer);
    updateWallpaper();

    topbar = new ETopbar(this);

    G::scene()->handleInitializeGL(this);
    repaint();
}

void EOutput::moveGL()
{
    wallpaperView->setPos(pos());

    topbar->update();

    G::scene()->handleMoveGL(this);
    repaint();
}

void EOutput::resizeGL()
{
    updateWallpaper();

    topbar->update();

    G::scene()->handleResizeGL(this);
    repaint();
}

void EOutput::paintGL()
{
    G::scene()->handlePaintGL(this);
}

void EOutput::uninitializeGL()
{
    // ...

    // Then delete the wallpaper view
    delete wallpaperView;

    delete topbar;
    topbar = nullptr;
}

// ...
```

Here, we've defined the lifecycle of the topbar:

- We create the topbar in `initializeGL()`.
- We update it during `moveGL()` and `resizeGL()` to ensure it stays aligned correctly.
- Finally, we destroy it in `uninitializeGL()` when it's no longer needed.

With these steps in place, you should now be able to admire your elegant white topbar when you recompile and run your application.

<img src="https://lh3.googleusercontent.com/pw/AIL4fc-14MmRM3kVX-a9k6xvH41YBBwb0Ayq2mJ5Ew2FIy5CFGbBDX4yl_jAL_K8RSXri9oq7-n5jBCoNCaO3NrIgBw5rxlJqMZUx66VrWN6gFMYY41eoi4=w2400"/>

### Rendering the Cursor

We have yet to address the scenario in which hardware cursor compositing is not supported. To render the cursor using OpenGL, we can establish a new layer for the cursor, along with an Louvre::LTextureView assigned to display the cursor texture.

However, it's essential to exercise caution, as the Louvre::LCursor texture may be destroyed while it's assigned to the view. To prevent Louvre::LScene from accessing this texture, we can ensure that we update the view texture each time before invoking Louvre::LScene::handlePaintGL().

To initiate this process, let's begin by creating the new cursor layer and cursor view in `ECompositor`, naming them `cursorLayer` and `softwareCursor`, respectively:

#### src/ECompositor.h

```cpp
#ifndef ECOMPOSITOR_H
#define ECOMPOSITOR_H

#include <LCompositor.h>
#include <LScene.h>
#include <LLayerView.h>
#include <LTextureView.h>

using namespace Louvre;

class ECompositor : public LCompositor
{
public:
    
    //...

    // Scene and layers
    LScene scene;
    LLayerView backgroundLayer, surfacesLayer,
        overlayLayer, fullscreenLayer, cursorLayer;

    LTextureView softwareCursor;
};

#endif // ECOMPOSITOR_H

```

To proceed, we add the cursor view to the cursor layer and initially assign it `nullptr` as its texture. We'll need to configure a custom destination size later to ensure the texture scales appropriately to match the cursor size. To achieve this, we must enable custom destination sizing using Louvre::LTextureView::enableDstSize().

#### src/ECompositor.cpp

```cpp
//...

ECompositor::ECompositor() : LCompositor(),
    scene(),
    backgroundLayer(scene.mainView()),
    surfacesLayer(scene.mainView()),
    overlayLayer(scene.mainView()),
    fullscreenLayer(scene.mainView()),
    cursorLayer(scene.mainView()),
    softwareCursor(nullptr, &cursorLayer)
{
    scene.mainView()->setClearColor(0.f, 0.f, 0.f, 1.f);
    softwareCursor.enableDstSize(true);
}

//...
```

Lastly, in Louvre::LOutput::paintGL(), we perform a check to determine whether the output supports hardware cursor compositing. If it does, we appropriately update the view texture, position and size. Importantly, if hardware compositing is supported, we assign `nullptr` as the texture, which effectively hides the cursor view.

#### src/EOutput.cpp

```cpp
//...

void EOutput::paintGL()
{
    // Check if hw cursor is supported
    if (cursor()->hasHardwareSupport(this))
        G::compositor()->softwareCursor.setTexture(nullptr);
    else
    {
        G::compositor()->softwareCursor.setTexture(cursor()->texture());
        G::compositor()->softwareCursor.setPos(cursor()->rect().pos());
        G::compositor()->softwareCursor.setDstSize(cursor()->rect().size());
        G::compositor()->softwareCursor.setVisible(cursor()->visible());
    }

    G::scene()->handlePaintGL(this);
}

//...
```

### Surfaces

Rendering surfaces introduces a bit more complexity as we must keep track of when they are created and monitor changes in their stacking order. In the upcoming chapter, we will delve deeply into surfaces, exploring how to render them using Louvre::LSurfaceView, and handle specific events, such as detecting when they are minimized. See you there!

<a href="md_md_tutorial_05.html">◀ Chapter 5: Rendering with LPainter</a> || <a href="md_md_tutorial_07.html"> Chapter 7: Surfaces ▶</a>