# Chapter 6: Outputs

An output (Louvre::LOutput) typically represents a screen on which the compositor can render and display its content. This may vary depending on the selected graphic backend, for example, in the case of the X11 graphic backend, it represents an X11 window.

<center>
    <img src="https://lh3.googleusercontent.com/4lV1LTHBmO-eFywBrL4UhYIRcQbV5bjGB_17FdWFCzjGvnklxwBnXz5hQKOrkRCOegsn6PjnYZNCWk1SjFjwh9t8olEzr3Uwzd3saEt8EKRbbqX0n1f5R7q6r6V9u1t0PUk7BB0teA=w2400" height="200px"/>
</center>

\n
Outputs generally have several resolutions and refresh rates they can work with, defined in their modes (Louvre::LOutputMode), and a position that allows them to be arranged similarly to how a preferences panel does.\n\n

<center>
    <img height="250px" src="https://lh3.googleusercontent.com/VOWUX4iiqYMF_bIrBP3xMyaiydv_e_ZKznCIJlRLaEA0CtBLMuU4h41R3D4Xm-7krk8jFGZrQGb_SS7hlIFUY9E5dVbQqs0Q3NIBXvRFrGs_cukqOmbCv1ExN9fG3BDdj4Yz45xIkQ=w2400"/>
</center>

The list of avaliable modes of an output can be accessed with Louvre::LOutput::modes(), its preferred mode with Louvre::LOutput::preferredMode(), and Louvre::LOutput::setMode() can be used to assign the current mode.\n

> Graphic backends assign the preferred mode by default, which is usually the one with the highest resolution and refresh rate.

# Scales

As monitors have increasingly higher resolutions, applications developed for older monitors may appear small on modern displays. To prevent this in Wayland, compositors often ask applications to render their content at double scale. However, as a compositor may render on multiple monitors simultaneously, each one with a different scale, it is necessary to define a coordinate system that allows for consistent rendering of surfaces and other graphical content through them.\n

To address this, Louvre works with three coordinate systems:

### Surface coordinates

In this system, dimensions are divided by the scale in use. For example, if a surface has a buffer with dimensions (100x100) and a scale of 2, it will be interpreted as (50x50). On the other hand, if the scale is 1, the dimensions will remain the same (100x100). Although this coordinate system is consistent across different scales, it can result in a loss of precision when using scales larger than 1.

### Buffer Coordinates

In the buffer coordinate system, dimensions do not change based on the scale being used and always represent the highest possible level of detail. However, this system can be inconsistent when working with different scales.

### Compositor Coordinates

In this system, dimensions are transformed to the global scale of the compositor (Louvre::LCompositor::globalScale()). The global scale is determined by the largest scale of the initialized outputs. For example, if you are rendering to two monitors with scales 1 and 2, respectively, the global compositor scale would be 2. Unlike the surface coordinate system, the buffer dimensions of a surface are not divided by its scale, instead they are transformed to the global scale of the compositor which prevents loss of precision. This coordinate system is consistent when working with different scales and also allows for the highest level of precision.\n
To know which coordinate system a method or property of a class uses, the library adds suffixes **S**, **B**, and **C** which refer to surface, buffer, and compositor coordinates respectively. For example, the Louvre::LSurface::rolePosC() method returns the position of a surface based on its role in compositor coordinates.\n

> Louvre primarily uses compositor coordinates to simplify development and eliminate the need for frequent transformations.

# Arrangement

In the previous chapter, we overrided the Louvre::LCompositor::initialized() virtual method which notifies the successful initialization of the compositor.\n
Let's use this method to do an initial set up of the outputs.\n
First, add the following headers in the **MyCompositor.cpp**:

<pre class="cpp-code"><span class="add">#include <LOutput.h>
#include <LLog.h>
</span></pre>

Then add the following lines to Louvre::LCompositor::initialized():

<pre class="cpp-code">
void MyCompositor::initialized()
{
    <span class="add">if(outputManager()->outputs()->empty())
    {
        LLog::fatal("No outputs avaliable.");
        finish();
    }

    for(LOutput *output : *outputManager()->outputs())
    {
        if(output->dpi() >= 120)
            output->setScale(2);

        addOutput(output);
    }

    Int32 totalWidth = 0;

    for(LOutput *output : outputs())
    {
        output->setPosC(LPoint(totalWidth,0));

        totalWidth += output->sizeC().w();
    }</span>
}
</pre>

Now let's analyze what each part of the code does.\n\n

In these lines, we verify that there is at least one available output using the output manager Louvre::LOutputManager.
If there are no outputs available, we print an error message and kill the compositor:

<pre class="cpp-code">
if(outputManager()->outputs()->empty())
{
    LLog::fatal("No outputs avaliable.");
    finish();
}
</pre>

Then we iterate through the list of available outputs, assign scale 2 to those with a DPI value greater than 120, and initialize them with the Louvre::LCompositor::addOutput() method:\n

<pre class="cpp-code">
for(LOutput *output : *outputManager()->outputs())
{
    if(output->dpi() >= 120)
        output->setScale(2);

    addOutput(output);
}
</pre>

Finally, we iterate again, but this time the initialized outputs, and we arrange them continuously from left to right following the order of the list.\n
We are adding the width of the outputs to the **totalWidth** variable on each iteration to assign the position of the next one continuously:\n

<pre class="cpp-code">
Int32 totalWidth = 0;

for(LOutput *output : outputs())
{
    output->setPosC(LPoint(totalWidth,0));

    totalWidth += output->sizeC().w();
}
</pre>

> Note that we are working with the compositor's coordinate system by using the Louvre::LOutput::setPosC() and Louvre::LOutput::sizeC() methods.

If you compile and run the compositor and have more than one monitor connected, you can verify that now you can move the cursor or application windows continuously between them.

The reason why we organize the outputs in a second loop and after adding them to the compositor is because the global scale is calculated based on the initialized outputs (the one with the largest scale) and as you may recall, this is used by the *compositor's coordinate system*.\n
The global scale of the compositor is updated every time an output is added or removed, or when the scale of an already initialized one changes.

With that said, let's relocate the second loop into a separate method so that we can reused it later.\n
Go to **MyCompositor.h** and create a new method called **arrangeOutputs()**:

<pre class="cpp-code">
#ifndef MYCOMPOSITOR_H
#define MYCOMPOSITOR_H

#include <LCompositor.h>

using namespace Louvre;

class MyCompositor : public LCompositor
{
public:
    MyCompositor();

    <span class="add">void arrangeOutputs();</span>

    void initialized() override;

};

#endif // MYCOMPOSITOR_H
</pre>

Then do refactoring (**Right click > Refactor > Add definition to MyCompositor.cpp**) and move the lines of code from the second loop:

<pre class="cpp-code"><span class="add">void MyCompositor::arrangeOutputs()
{
    Int32 totalWidth = 0;

    for(LOutput *output : outputs())
    {
        output->setPosC(LPoint(totalWidth,0));

        totalWidth += output->sizeC().w();
    }
}</span></pre>

Finally, update **MyCompositor::initialized()**:

<pre class="cpp-code">
void MyCompositor::initialized()
{
    if(outputManager()->outputs()->empty())
    {
        LLog::fatal("No outputs avaliable.");
        finish();
    }

    for(LOutput *output : *outputManager()->outputs())
    {
        if(output->dpi() >= 120)
            output->setScale(2);

        addOutput(output);
    }

    <span class="add">arrangeOutputs();</span>
}</pre>

# Hotplug Events

So far we have set up available outputs during the initialization of the compositor, however these can change at any time during execution, for example, when connecting or disconnecting a monitor through a HDMI or VGA port.\n
To access hotplug events of outputs we must reimplement the Louvre::LOutputManager class.\n
Let's create a new subclass of Louvre::LOutputManager called **MyOutputManager**:\n\n

**MyOutputManager.h**

<pre class="cpp-code"><span class="add">#ifndef MYOUTPUTMANAGER_H
#define MYOUTPUTMANAGER_H

#include <LOutputManager.h>

using namespace Louvre;

class MyOutputManager : public LOutputManager
{
public:
    MyOutputManager(Params *params);
};

#endif // MYOUTPUTMANAGER_H</span></pre>

**MyOutputManager.cpp**

<pre class="cpp-code"><span class="add">#include "MyOutputManager.h"

MyOutputManager::MyOutputManager(Params *params) : LOutputManager(params)
{

}</span></pre>

Now let's override its virtual constructor Louvre::LCompositor::createOutputManagerRequest() in **MyCompositor.h**:

<pre class="cpp-code">
#ifndef MYCOMPOSITOR_H
#define MYCOMPOSITOR_H

#include <LCompositor.h>

using namespace Louvre;

class MyCompositor : public LCompositor
{
public:
    MyCompositor();

    void arrangeOutputs();

    void initialized() override;
    <span class="add">
    LOutputManager *createOutputManagerRequest(LOutputManager::Params *params) override;</span>
};

#endif // MYCOMPOSITOR_H
</pre>

And in  **MyOutputManager.cpp**.

<pre class="cpp-code"><span class="add">LOutputManager *MyCompositor::createOutputManagerRequest(LOutputManager::Params *params)
{
    return new MyOutputManager(params);
}</span></pre>

Now, the compositor will use **MyOutputManager** instead of **LOutputManager**.

Let's go back to **MyOutputManager.h** and override the Louvre::LOutputManager::outputPlugged() and Louvre::LOutputManager::outputUnplugged() virtual methods so that we are notified when an output is connected or disconnected.

<pre class="cpp-code">
#ifndef MYOUTPUTMANAGER_H
#define MYOUTPUTMANAGER_H

#include <LOutputManager.h>

using namespace Louvre;

class MyOutputManager : public LOutputManager
{
public:
    MyOutputManager(Params *params);

    <span class="add">void outputPlugged(LOutput *output) override;
    void outputUnplugged(LOutput *output) override;</span>
};

#endif // MYOUTPUTMANAGER_H
</pre>

In **MyOutputManager.cpp** we must add the following headers:\n

<pre class="cpp-code"><span class="add">#include <MyCompositor.h>
#include <LOutput.h>
#include <LCursor.h></span></pre>

### Plugged Notification

If a new output is connected, we assign its scale, initialize it, reorganize all initialized outputs, and repaint them:\n

<pre class="cpp-code"><span class="add">void MyOutputManager::outputPlugged(LOutput *output)
{
    output->setScale(output->dpi() >= 120 ? 2 : 1);

    MyCompositor *comp = (MyCompositor*)compositor();
    comp->addOutput(output);
    comp->arrangeOutputs();
    comp->repaintAllOutputs();

}</span></pre>

### Unplugged Notification

And when an output is disconnected, we uninitialize it, re-arrange all initialized outputs and repaint them:\n

<pre class="cpp-code"><span class="add">void MyOutputManager::outputUnplugged(LOutput *output)
{
    compositor()->removeOutput(output);

    MyCompositor *comp = (MyCompositor*)compositor();
    comp->arrangeOutputs();
    comp->repaintAllOutputs();
}</span></pre>

In this chapter we learned how to set up and organize multiple outputs, both at startup and during execution. For more information about outputs please check the Louvre::LOutput and Louvre::LOutputManager documentation.\n
In the next chapter we will see how to override the default way Louvre renders.