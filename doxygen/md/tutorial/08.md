# Chapter 8: Pointer Events

In this chapter, we will delve into the intricacies of managing pointer events, which encompass actions from a mouse or touchpad, including button clicks, movement, and scrolling. All pointer events can be effectively managed through the `Louvre::LPointer` class. This class serves as an interface utilized by the input backend, which, in turn, triggers numerous of its virtual methods.

Furthermore, this class empowers you to reroute these events to client surfaces, offering a flexible and controlled event-handling mechanism.

### Security

As you may already be aware, Wayland presents a significant advancement in security compared to X11, particularly concerning input events. This is due to the fact that in Wayland, the compositor is the exclusive process with direct access to system input events. Consequently, it can selectively and securely transmit these events to clients, thus thwarting potential security vulnerabilities. This approach effectively safeguards against threats like information theft, which could be exploited by malware keyloggers, providing a more robust security framework.

### Sending Events to Clients

As previously mentioned, events can be directed to a single client surface at a time. To achieve this, you must initially set the pointer's focus to a specific surface using one of the variants of Louvre::LPointer::setFocus(). Once the focus is established, you can then utilize any of the other event-sending functions, such as Louvre::LPointer::sendMoveEvent(), Louvre::LPointer::sendButtonEvent(), or Louvre::LPointer::sendAxisEvent(). These functions will automatically redirect the events to the currently focused surface.

If you subsequently call Louvre::LPointer::setFocus() again, pointing to a different surface, the previous surface will automatically lose focus. To remove focus from all surfaces, you can pass `nullptr` as the argument to Louvre::LPointer::setFocus(). Additionally, when a client destroys a surface that currently holds the pointer's focus, the focus is automatically unset as well. You can ascertain which surface currently has the focus by utilizing Louvre::LPointer::focusSurface(), which may return `nullptr` if no surface currently holds the focus.

Without further delay, let's proceed to override the default way that Louvre handles pointer events. To achieve this, we'll create a subclass of Louvre::LPointer named `EPointer`:

#### src/EPointer.h

```cpp
#ifndef EPOINTER_H
#define EPOINTER_H

#include <LPointer.h>

using namespace Louvre;

class EPointer : public LPointer
{
public:
    EPointer(LPointer::Params *params);

    // Relative pointer move event
    void pointerMoveEvent(Float32 dx, Float32 dy) override;

    // Absolute pointer move event
    void pointerPosChangeEvent(Float32 x, Float32 y) override;

    void pointerButtonEvent(Button button, ButtonState state) override;

    // Scroll events
    void pointerAxisEvent(Float64 axisX, Float64 axisY, Int32 discreteX, Int32 discreteY, AxisSource source) override;
};

#endif // EPOINTER_H
```

Here, we're overriding all input event methods of Louvre::LPointer, each serving a distinct purpose:

* Louvre::LPointer::pointerMoveEvent: Notifies us of relative pointer movement, tracking the change in position using `dx` and `dy` variables.

* Louvre::LPointer::pointerPosChangeEvent: Similar to the previous event but provides absolute pointer coordinates instead of deltas.

> Input backends exclusively use either Louvre::LPointer::pointerMoveEvent or Louvre::LPointer::pointerPosChangeEvent, but never both.

* Louvre::LPointer::pointerButtonEvent: Informs us when a mouse or touchpad button is pressed or released. The Louvre::LPointer::Button argument specifies which button, and Louvre::LPointer::ButtonState indicates the state (pressed or released).

* Louvre::LPointer::pointerAxisEvent: Reports scrolling events, which can involve continuous or discrete axis components depending on the source. For instance, two-finger scrolling employs continuous axis components, while a mouse scroll wheel uses discrete ones.

#### src/EPointer.cpp

```cpp
#include <LCursor.h>
#include <LDNDManager.h>
#include <LSeat.h>
#include <LOutput.h>
#include <LSurface.h>
#include <LDNDIconRole.h>
#include <LToplevelRole.h>
#include <LKeyboard.h>
#include <LCompositor.h>
#include "EPointer.h"

EPointer::EPointer(Params *params) : LPointer(params) {}

void EPointer::pointerMoveEvent(Float32 dx, Float32 dy)
{
    /* For the sake of simplification, we will handle the event in pointerPosChangeEvent().
     * Input backends emit either pointerMoveEvent() or pointerPosChangeEvent(),
     * but never both. */
    pointerPosChangeEvent(cursor()->pos().x() + dx,
                          cursor()->pos().y() + dy);
}

void EPointer::pointerPosChangeEvent(Float32 x, Float32 y)
{
    cursor()->setPos(LPointF(x, y));

    // Repaint cursor outputs if hardware composition is not supported
    for (LOutput *output : cursor()->intersectedOutputs())
    {
        if (!cursor()->hasHardwareSupport(output))
            output->repaint();
    }

    // Update the drag & drop icon (if there was one)
    if (seat()->dndManager()->icon())
    {
        seat()->dndManager()->icon()->surface()->setPos(cursor()->pos());
        seat()->dndManager()->icon()->surface()->repaintOutputs();
    }

    // Update the Toplevel size (if there was one being resized)
    if (resizingToplevel())
    {
        updateResizingToplevelSize();
        return;
    }

    // Update the Toplevel pos (if there was one being moved interactively)
    if (movingToplevel())
    {
        updateMovingToplevelPos();

        movingToplevel()->surface()->repaintOutputs();

        if (movingToplevel()->maximized())
            movingToplevel()->configure(movingToplevel()->states() &~ LToplevelRole::Maximized);

        return;
    }

    // DO NOT GET CONFUSED! If we are in a drag & drop session, we call setDraggingSurface(NULL) in case there is a surface being dragged.
    if (seat()->dndManager()->dragging())
        setDraggingSurface(nullptr);

    // If there was a surface holding the left pointer button
    if (draggingSurface())
    {
        sendMoveEvent();
        return;
    }

    // Find the first surface under the cursor
    LSurface *surface = surfaceAt(cursor()->pos());

    if (!surface)
    {
        setFocus(nullptr);
        cursor()->useDefault();
        cursor()->setVisible(true);
    }
    else
    {
        if (focusSurface() == surface)
            sendMoveEvent();
        else
            setFocus(surface);
    }
}

void EPointer::pointerButtonEvent(Button button, ButtonState state)
{
    if (state == Released && button == Left)
    {
        seat()->dndManager()->drop();
    }

    if (!focusSurface())
    {
        LSurface *surface = surfaceAt(cursor()->pos());

        if (surface)
        {
            seat()->keyboard()->setFocus(surface);
            setFocus(surface);
            sendButtonEvent(button, state);

            if (surface->popup())
                dismissPopups();
        }
        // If no surface under the cursor
        else
        {
            seat()->keyboard()->setFocus(nullptr);
            dismissPopups();
        }

        return;
    }

    sendButtonEvent(button, state);

    if (button != Left)
        return;

    // Left button pressed
    if (state == Pressed)
    {
        /* We save the pointer focus surface in order to continue sending events to it even when the cursor
         * is outside of it (while the left button is being held down)*/
        setDraggingSurface(focusSurface());
        seat()->keyboard()->setFocus(focusSurface());

        if (focusSurface()->toplevel() && !focusSurface()->toplevel()->activated())
            focusSurface()->toplevel()->configure(focusSurface()->toplevel()->states() | LToplevelRole::Activated);

        if (!focusSurface()->popup())
            dismissPopups();

        if (focusSurface() == compositor()->surfaces().back())
            return;

        if (focusSurface()->parent())
            focusSurface()->topmostParent()->raise();
        else
            focusSurface()->raise();
    }
    // Left button released
    else
    {
        stopResizingToplevel();
        stopMovingToplevel();

        // We stop sending events to the surface on which the left button was being held down
        setDraggingSurface(nullptr);

        if (!focusSurface()->inputRegion().containsPoint(cursor()->pos() - focusSurface()->rolePos()))
        {
            setFocus(nullptr);
            cursor()->useDefault();
            cursor()->setVisible(true);
        }
    }
}

void EPointer::pointerAxisEvent(Float64 axisX, Float64 axisY, Int32 discreteX, Int32 discreteY, AxisSource source)
{
    // Inverts the scroll direction
    sendAxisEvent(-axisX, -axisY, -discreteX, -discreteY, source);
}
```

Stay calm! Here, we are currently utilizing the default implementation provided by Louvre. I'll explain the purpose of each function shortly. But first, let's proceed to override the virtual constructor Louvre::LCompositor::createPointerRequest().

#### src/ECompositor.h

```cpp
    // ...

    // Virtual constructors
    LOutput *createOutputRequest() override;
    LSurface *createSurfaceRequest(LSurface::Params *params) override;
    LPointer *createPointerRequest(LPointer::Params *params) override;

    // ...
```

#### src/ECompositor.cpp

```cpp

// ...

#include "EPointer.h"

// ...

LPointer *ECompositor::createPointerRequest(LPointer::Params *params)
{
    return new EPointer(params);
}
```

If you recompile and run the compositor, you won't observe any noticeable changes. This is because we've implemented the same logic that Louvre uses by default to handle each Louvre::LPointer event. 

Now, let's delve deeper into what each function is accomplishing:

#### src/EPointer.cpp

```cpp
void EPointer::pointerMoveEvent(Float32 dx, Float32 dy)
{
    /* For the sake of simplification, we will handle the event in pointerPosChangeEvent().
     * Input backends emit either pointerMoveEvent() or pointerPosChangeEvent(),
     * but never both. */
    pointerPosChangeEvent(cursor()->pos().x() + dx,
                          cursor()->pos().y() + dy);
}
```

Here, instead of separately handling the move event in each Louvre::LPointer::pointerMoveEvent() and Louvre::LPointer::pointerPosChangeEvent() method, we consolidate the process by transforming the relative deltas into absolute pointer coordinates. This transformation is achieved using the Louvre::LCursor position as the reference point. Consequently, all movement logic is now concentrated within Louvre::LPointer::pointerPosChangeEvent().

#### src/EPointer.cpp

```cpp
void EPointer::pointerPosChangeEvent(Float32 x, Float32 y)
{
    cursor()->setPos(LPointF(x, y));

    // Repaint cursor outputs if hardware composition is not supported
    for (LOutput *output : cursor()->intersectedOutputs())
    {
        if (!cursor()->hasHardwareSupport(output))
            output->repaint();
    }

    // Update the drag & drop icon (if there was one)
    if (seat()->dndManager()->icon())
    {
        seat()->dndManager()->icon()->surface()->setPos(cursor()->pos());
        seat()->dndManager()->icon()->surface()->repaintOutputs();
    }

    // ...
}
```

Here, our process begins with the update of the cursor position. Following this, we invoke a repaint action on all outputs where the cursor is visible if hardware cursor composition is not available. This ensures that the cursor is appropriately repainted using OpenGL.

Additionally, we conduct a check to determine if a drag & drop session is currently in progress. If so, we synchronize the position of the dragged icon with the cursor position, ensuring alignment between the two elements.

#### src/EPointer.cpp

```cpp
void EPointer::pointerPosChangeEvent(Float32 x, Float32 y)
{
    // ...

    // Update the Toplevel size (if there was one being resized)
    if (resizingToplevel())
    {
        updateResizingToplevelSize();
        return;
    }

    // Update the Toplevel pos (if there was one being moved interactively)
    if (movingToplevel())
    {
        updateMovingToplevelPos();

        movingToplevel()->surface()->repaintOutputs();

        if (movingToplevel()->maximized())
            movingToplevel()->configure(movingToplevel()->states() &~ LToplevelRole::Maximized);

        return;
    }

    // DO NOT GET CONFUSED! If we are in a drag & drop session, we call setDraggingSurface(NULL) in case there is a surface being dragged.
    if (seat()->dndManager()->dragging())
        setDraggingSurface(nullptr);

    // If there was a surface holding the left pointer button
    if (draggingSurface())
    {
        sendMoveEvent();
        return;
    }

    // ...
}
```

In this code section, we handle interactive resizing or movement of toplevel windows, elaborated further in the Toplevels chapter. 

We also employ Louvre::LPointer::setDraggingSurface() and Louvre::LPointer::draggingSurface() to maintain surface focus when the left pointer button is initially pressed within the surface and then moved outside. This feature is essential for preserving surface focus during actions like text selection, preventing annoying focus loss when the cursor moves outside the surface. It's important to note that this mechanism is unrelated to drag & drop sessions. If a drag and drop session is active, we unset Louvre::LPointer::draggingSurface() to ensure that each surface beneath the cursor receives pointer focus. 

Additionally, we use Louvre::LPointer::sendMoveEvent() without specifying arguments, as it automatically calculates the local surface position based on the cursor position. Alternatively, you can utilize other variants of Louvre::LPointer::sendMoveEvent() to manually specify the local position.

#### src/EPointer.cpp

```cpp
void EPointer::pointerPosChangeEvent(Float32 x, Float32 y)
{
    // ...

    // Find the first surface under the cursor
    LSurface *surface = surfaceAt(cursor()->pos());

    if (!surface)
    {
        setFocus(nullptr);
        cursor()->useDefault();
        cursor()->setVisible(true);
    }
    else
    {
        if (focusSurface() == surface)
            sendMoveEvent();
        else
            setFocus(surface);
    }
}
```

Finally, if this function was not previously returned, we perform the following actions:

1. Recheck which surface is currently under the cursor using Louvre::LPointer::surfaceAt(). This function identifies the first mapped surface beneath the cursor based on the Louvre::LSurface::inputRegion(). It's important to note that certain surfaces, such as Louvre::LCursorRole or Louvre::LDNDIconRole, lack an input region and are therefore not returned by this function. Additionally, this function returns `nullptr` if no surface is found.

2. If we discover a surface under the cursor, we assign it focus. If the surface is the same as the currently focused one, we send a move event.

3. If no surface is found under the cursor, we unset pointer focus from all surfaces and restore the default cursor texture. Details on how clients can request changes to cursor texture and visibility will be covered later.

Now lets move to the Louvre::LPointer::pointerButtonEvent():

#### src/EPointer.cpp

```cpp
void EPointer::pointerButtonEvent(Button button, ButtonState state)
{
    if (state == Released && button == Left)
    {
        seat()->dndManager()->drop();
    }

    // ...
}
```

First, if the left pointer button is released, we invoke Louvre::LDNDManager::drop(). This action initiates a drop operation if a drag & drop session is in progress. Importantly, calling it when no session is active is a harmless no-op.

#### src/EPointer.cpp

```cpp
void EPointer::pointerButtonEvent(Button button, ButtonState state)
{
    // ...

    if (!focusSurface())
    {
        LSurface *surface = surfaceAt(cursor()->pos());

        if (surface)
        {
            seat()->keyboard()->setFocus(surface);
            setFocus(surface);
            sendButtonEvent(button, state);

            if (surface->popup())
                dismissPopups();
        }
        // If no surface under the cursor
        else
        {
            seat()->keyboard()->setFocus(nullptr);
            dismissPopups();
        }

        return;
    }

    // ...
}
```

Then, in the absence of a currently focused surface, we search for one using Louvre::LPointer::surfaceAt() once again.

If a surface is discovered, we assign it both pointer and keyboard focus and transmit the button event. Additionally, if the surface is a popup, we dismiss it. This is employed to address the issue of certain buggy clients failing to close popups, an undesired behavior.

If no surface is found under the cursor, we remove keyboard focus and dismiss any popups.

#### src/EPointer.cpp

```cpp
void EPointer::pointerButtonEvent(Button button, ButtonState state)
{
    // ...

    sendButtonEvent(button, state);

    if (button != Left)
        return;

    // Left button pressed
    if (state == Pressed)
    {
        /* We save the pointer focus surface in order to continue sending events to it even when the cursor
         * is outside of it (while the left button is being held down)*/
        setDraggingSurface(focusSurface());

        seat()->keyboard()->setFocus(focusSurface());

        if (focusSurface()->toplevel() && !focusSurface()->toplevel()->activated())
            focusSurface()->toplevel()->configure(focusSurface()->toplevel()->states() | LToplevelRole::Activated);

        if (!focusSurface()->popup())
            dismissPopups();

        if (focusSurface() == compositor()->surfaces().back())
            return;

        if (focusSurface()->parent())
            focusSurface()->topmostParent()->raise();
        else
            focusSurface()->raise();
    }
    // Left button released
    else
    {
        stopResizingToplevel();
        stopMovingToplevel();

        // We stop sending events to the surface on which the left button was being held down
        setDraggingSurface(nullptr);

        if (!focusSurface()->inputRegion().containsPoint(cursor()->pos() - focusSurface()->rolePos()))
        {
            setFocus(nullptr);
            cursor()->useDefault();
            cursor()->setVisible(true);
        }
    }
}
```

If a surface has pointer focus, we send the button event. If the button isn't the left one, we return since we mainly use the left button for actions.

When the left button is pressed over a surface:
- We set it as the dragging surface, maintaining focus.
- Assign keyboard focus.
- If it's a toplevel, we make it active, highlighting its decorations.
- If not a popup, we dismiss popups.
- Finally, we bring it to the front, along with its parent surface, if applicable, stacking it above others.

When the left button is released:
- We halt interactive toplevel resizing or movement.
- Unset the dragging surface.
- Check if the cursor is over the surface's input region. If not, we clear pointer focus and restore the cursor to its default state.

Well, let's all take a deep breath and shift our focus to the seemingly simpler Louvre::LPointer::pointerAxisEvent().

#### src/EPointer.cpp

```cpp
void EPointer::pointerAxisEvent(Float64 axisX, Float64 axisY, Int32 discreteX, Int32 discreteY, AxisSource source)
{
    // Invert axis for natural scrolling
    sendAxisEvent(-axisX, -axisY, -discreteX, -discreteY, source);
}
```

In this section, we're simply routing the scroll event to the surface that currently holds focus. If there's no surface in focus, this operation becomes a non-action.

Additionally, it's worth noting that we've inverted the axis values. This adjustment is made to accommodate natural scrolling. However, feel free to customize it to your preference.

## Managing Pointer Events with LScene

The detailed breakdown of each event's handling was provided solely for educational purposes, enabling you to grasp event management concepts. However, similar to the approach we explored with Louvre::LOutput, the Louvre::LScene class also offers functions to handle these events in a similar manner.

Using Louvre::LScene presents an additional advantage: it allows you to access per-view events. To integrate Louvre::LScene into your event handling process, you simply need to "plug it" like this:

#### src/EPointer.cpp

```cpp
#include <LScene.h>
#include "EPointer.h"
#include "Global.h"

EPointer::EPointer(Params *params) : LPointer(params) {}

void EPointer::pointerMoveEvent(Float32 dx, Float32 dy)
{
    G::scene()->handlePointerMoveEvent(dx, dy);
}

void EPointer::pointerPosChangeEvent(Float32 x, Float32 y)
{
    G::scene()->handlePointerPosChangeEvent(x, y);
}

void EPointer::pointerButtonEvent(Button button, ButtonState state)
{
    G::scene()->handlePointerButtonEvent(button, state);
}

void EPointer::pointerAxisEvent(Float64 axisX, Float64 axisY, Int32 discreteX, Int32 discreteY, AxisSource source)
{
    G::scene()->handlePointerAxisEvent(-axisX, -axisY, -discreteX, -discreteY, source);
}
```

After recompiling and running the compositor, everything should continue to function as expected, with one minor change. If you happen to move the cursor outside of a surface, you'll notice that the cursor does not revert to its default state.
To address this issue, we can implement the following solution:

#### src/EPointer.cpp

```cpp
#include <LScene.h>
#include <LCursor.h>
#include <LView.h>
#include "EPointer.h"
#include "Global.h"

EPointer::EPointer(Params *params) : LPointer(params) {}

void EPointer::pointerMoveEvent(Float32 dx, Float32 dy)
{
    pointerPosChangeEvent(cursor()->pos().x() + dx,
                          cursor()->pos().y() + dy);
}

void EPointer::pointerPosChangeEvent(Float32 x, Float32 y)
{
    LView *view = G::scene()->handlePointerPosChangeEvent(x, y);

    if ((!view || view->type() != LView::Type::Surface) && !resizingToplevel() && !movingToplevel())
    {
        cursor()->useDefault();
        cursor()->setVisible(true);
    }
}

void EPointer::pointerButtonEvent(Button button, ButtonState state)
{
    G::scene()->handlePointerButtonEvent(button, state);
}

void EPointer::pointerAxisEvent(Float64 axisX, Float64 axisY, Int32 discreteX, Int32 discreteY, AxisSource source)
{
    G::scene()->handlePointerAxisEvent(-axisX, -axisY, -discreteX, -discreteY, source);
}
```

Once again, we handle move events exclusively within the Louvre::LPointer::pointerPosChangeEvent() function.\n
The Louvre::LScene::handlePointerPosChangeEvent() function also returns the first view located at the specified coordinates. It's important to note that this function may return `nullptr` if no view is found.\n
In cases where either no view is found or the identified view is not of type Louvre::LSurfaceView, we take action to restore the cursor to its default state.
Additionally, we avoid restoring the cursor when a toplevel window is currently being resized or moved. This precaution is taken because the client may intend to display a specific cursor, such as a resize edge cursor or a hand-dragging cursor, during these operations.

### Restoring Minimized Surfaces

By using Louvre::LScene for handling pointer events, we can now detect when we click on the topbar thumbnails. To achieve this, we need to enable input events for each thumbnail view using Louvre::LView::enableInput().

Additionally, we must override their Louvre::LView::pointerButtonEvent() virtual method:

#### src/ETopbarItem.h

```cpp
// ...

class ETopbarItem : public LTextureView
{
public:

    // ...

    void pointerButtonEvent(LPointer::Button button, LPointer::ButtonState state) override;

    // ...
};

// ...
```

#### src/ETopbarItem.cpp

```cpp
// ...

ETopbarItem::ETopbarItem(ETopbar *topbar, ESurface *surface) :
    LTextureView(surface->thumbnail, &topbar->view),
    topbar(topbar),
    surface(surface)
{
    // ...

    enableInput(true);
}

// ...

void ETopbarItem::pointerButtonEvent(LPointer::Button button, LPointer::ButtonState state)
{
    if (button == LPointer::Button::Left && state == LPointer::ButtonState::Released)
        surface->setMinimized(false);
}
```

Now, clicking on a thumbnail view using the left mouse button results in the corresponding surface being unminimized—simple and efficient.

You can also explore other per-view pointer events, such as when the cursor enters or leaves the view, scrolling events, and more. For detailed information, please refer to the documentation for Louvre::LView.

### Disabling Wayland Event Handling

If you need to handle pointer events differently from how Louvre::LScene does, while still receiving per-view events, you can disable the Wayland event handling of Louvre::LScene using Louvre::LScene::enableHandleWaylandPointerEvents(). This allows you to continue receiving per-view pointer events while giving you the flexibility to manually send these events to clients, as we demonstrated earlier in this chapter.

In the upcoming chapter, we'll explore the realm of handling keyboard events. Until then, see you there!

<a href="md_md_tutorial_07.html">◀ Chapter 7: Surfaces</a> || <a href="md_md_tutorial_09.html"> Chapter 9: Keyboard Events ▶</a>