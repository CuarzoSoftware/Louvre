# Chapter 7: Toplevels

Surfaces with the Toplevel role (Louvre::LToplevelRole) represent typical application windows that have a title bar, close, minimize and maximize buttons, and can be interactively dragged and resized by the user.\n\n

<center>
    <img src="https://lh3.googleusercontent.com/PvNaxLgkjaPryJ8W_P3bDOccQu1m-zNEcI7aH_R8WggzylV5LQZtuzLTUSImThDI8IVsAI9DERF4cwvSqPAEAyjsihHuPCQlZAbvu33iMC2iXvpTswZC3RBNDyKm1YEWDnnKeCn2Qw=w2400" height="300px"/>
</center>


## Reimplementing LToplevelRole

Let's dive deeper into the functionalities of the Louvre::LToplevelRole class by reimplementing it.\n
Create a new subclass of Louvre::LToplevelRole named MyToplevelRole.\n\n

**MyToplevelRole.h**

<pre class="cpp-code">
<span class="add">#ifndef MYTOPLEVELROLE_H
#define MYTOPLEVELROLE_H

#include <LToplevelRole.h>

using namespace Louvre;

class MyToplevelRole : public LToplevelRole
{
public:
    MyToplevelRole(Params *params);
};

#endif // MYTOPLEVELROLE_H</span>
</pre>

**MyToplevelRole.cpp**

<pre class="cpp-code">
<span class="add">#include <MyToplevelRole.h>
#include <MyCompositor.h>
#include <MyOutput.h>
#include <LCursor.h>

MyToplevelRole::MyToplevelRole(Params *params) : LToplevelRole(params)
{

}</span>
</pre>

We should also override its virtual constructor in **MyCompositor**.\n\n

**MyCompositor.h**

<pre class="cpp-code">
class MyCompositor : public LCompositor
{
public:
    MyCompositor();

    LTexture *background;

    void arrangeOutputs();

    // Virtual methods
    void initialized() override;

    // Virtual constructors
    LOutputManager *createOutputManagerRequest(LOutputManager::Params *params) override;
    LOutput *createOutputRequest() override;
    <span class="add">LToplevelRole *createToplevelRoleRequest(LToplevelRole::Params *params) override;</span>
};
</pre>

**MyCompositor.cpp** ( remember to include ```#include <MyToplevelRole.h>``` )

<pre class="cpp-code">
<span class="add">LToplevelRole *MyCompositor::createToplevelRoleRequest(LToplevelRole::Params *params)
{
    return new MyToplevelRole(params);
}</span>
</pre>

## Initial Configuration

When a client assigns the Toplevel role to a surface, it requests the compositor to suggest a size and states with which to initialize it.
The states could be maximized, fullscreen, active, etc.

> You can see all the possible states of a Toplevel in Louvre::LToplevelRole::State.

Let's override the Louvre::LToplevelRole::configureRequest() virtual method to handle this request.\n\n

**MyToplevelRole.h**

<pre class="cpp-code">
class MyToplevelRole : public LToplevelRole
{
public:
    MyToplevelRole(Params *params);

    <span class="add">// Virtual methods
    void configureRequest() override;</span>
};
</pre>

**MyToplevelRole.cpp**

<pre class="cpp-code">
<span class="add">void MyToplevelRole::configureRequest()
{
    LOutput *output = compositor()->cursor()->output();

    // Notifies the compositor's capabilities
    setWmCapabilities(WmCapabilities::WmWindowMenu | WmCapabilities::WmMinimize | WmCapabilities::WmMaximimize | WmCapabilities::WmFullscreen);

    // Suggests to the Toplevel not to use a size larger than the output where the cursor is located
    configureBoundsC(LSize(
                         output->sizeC().w(),
                         output->sizeC().h() - MENU_H * compositor()->globalScale()
                         ));

    // Activates the Toplevel with size (0,0) so that the client can decide the size
    configureC(LSize(0,0), LToplevelRole::Activated);
}</span>
</pre>

In the **configureRequest()** method, we first notify the client of the compositor's capabilities with Louvre::LToplevelRole::setWmCapabilities(). This could change the visibility of the minimize and maximize buttons of the window.\n
Then we suggest a maximum size for the Toplevel to be configured with, in this case we pass the width of the output where the cursor is located and its height minus the height of the menu.\n
Finally, we let the client decide the window size by passing (0,0) in Louvre::LToplevelRole::configureC() and ask it to use the Louvre::LToplevelRole::Activated state.\n
You can force the Toplevel to use a specific size by passing a value different from (0,0).

> When a Toplevel is active, its decorations stand out over the others. The library internally takes care of maintaining only one Toplevel active at a time.

## Centering

You may have noticed that Toplevels always appear centered on the screen when they are created. The library by default centers them when they are mapped in Louvre::LSurface::mappingChanged(), but it considers the full size of the output.\n
Let's create a new subclass of Louvre::LSurface called MySurface to override this virtual method and center Toplevels considering the height of the menu.\n\n

**MySurface.h**

<pre class="cpp-code">
<span class="add">#ifndef MYSURFACE_H
#define MYSURFACE_H

#include <LSurface.h>

using namespace Louvre;

class MySurface : public LSurface
{
public:
    MySurface(Params *params, GLuint textureUnit = 1);

    // Virtual methods
    void mappingChanged() override;
};

#endif // MYSURFACE_H</span>
</pre>

**MySurface.cpp**

<pre class="cpp-code">
<span class="add">#include <MySurface.h>
#include <MyCompositor.h>
#include <MyOutput.h>
#include <LCursor.h>

MySurface::MySurface(Params *params, GLuint textureUnit) : LSurface(params, textureUnit){}

void MySurface::mappingChanged()
{
    // If the surface is a Toplevel, we place it in the center of the screen
    if(mapped() && toplevel())
    {
        Int32 menuH = MENU_H * compositor()->globalScale();
        LPoint outputPos = compositor()->cursor()->output()->posC();
        LSize outputSize = compositor()->cursor()->output()->sizeC() - LSize(0, menuH);

        setPosC(LPoint(
                    outputPos.x() + outputSize.w()/2 - toplevel()->windowGeometryC().w()/2,
                    outputPos.y() + outputSize.h()/2 - toplevel()->windowGeometryC().h()/2 + menuH
                    ));
    }

    compositor()->repaintAllOutputs();
}</span>
</pre>

And its virtual constructor:\n\n

**MyCompositor.h**

<pre class="cpp-code">
class MyCompositor : public LCompositor
{
public:
    MyCompositor();

    LTexture *background;

    void arrangeOutputs();

    // Virtual methods
    void initialized() override;

    // Virtual constructors
    LOutputManager *createOutputManagerRequest(LOutputManager::Params *params) override;
    LOutput *createOutputRequest() override;
    LToplevelRole *createToplevelRoleRequest(LToplevelRole::Params *params) override;
    <span class="add">LSurface *createSurfaceRequest(LSurface::Params *params) override;</span>
};
</pre>

**MyCompositor.cpp** ( remember to include #include <MySurface.h> )

<pre class="cpp-code">
<span class="add">LSurface *MyCompositor::createSurfaceRequest(LSurface::Params *params)
{
    // The second argument is the OpenGL texture unit used by the surface
    return new MySurface(params, 1);
}</span>
</pre>

In **mappingChanged()**, we check that the surface is mapped and has a Toplevel role, then we center it considering the height of the menu, and finally, we repaint all the outputs.

## Maximizing

Clients can request to maximize a Toplevel, for example when the user clicks its maximize button. On the other hand, the compositor has the freedom to reject or accept the request and maximize it using the Louvre::LToplevelRole::configureC() method.\n
Override the Louvre::LToplevelRole::setMaximizedRequest(), Louvre::LToplevelRole::unsetMaximizedRequest() and Louvre::LToplevelRole::maximizedChanged() virtual methods:\n\n

**MyToplevelRole.h**

<pre class="cpp-code">
class MyToplevelRole : public LToplevelRole
{
public:
    MyToplevelRole(Params *params);

    // Virtual methods
    void configureRequest() override;
    <span class="add">void setMaximizedRequest() override;
    void unsetMaximizedRequest() override;
    void maximizedChanged() override;</span>
};
</pre>

**MyToplevelRole.cpp**

<pre class="cpp-code">
<span class="add">void MyToplevelRole::setMaximizedRequest()
{

}

void MyToplevelRole::unsetMaximizedRequest()
{

}

void MyToplevelRole::maximizedChanged()
{

}</span>
</pre>

If you compile and run the compositor and try to maximize a window you will see that it no longer maximizes.\n
Let's see how to handle each request:\n\n

**MyToplevelRole.cpp**

<pre class="cpp-code">
void MyToplevelRole::setMaximizedRequest()
{
    <span class="add">LOutput *output = compositor()->cursor()->output();

    LSize size = LSize(output->sizeC().w(), output->sizeC().h() - MENU_H);

    // First, we configure the Toplevel exclusively with the Activated flag so that it maintains its size when unmaximized.
    configureC(size, LToplevelRole::Activated);

    // Then we maximize it
    configureC(size, LToplevelRole::Activated | LToplevelRole::Maximized);

    // We wait for maximizeChanged() to be invoked in order to reposition it</span>
}
</pre>

When clients maximize a Toplevel, they often remember its previous size. That's why, we first configure it using only the **Activated** flag so that when it goes back to the normal state it maintains the maximized size. Then, we configure it again, this time with the **Maximized** flag.

> Configuring Toplevels is an asynchronous process, that's why we must use **maximizedChanged()** to know when the configuration has been applied.

**MyToplevelRole.cpp**

<pre class="cpp-code">
void MyToplevelRole::maximizedChanged()
{
    <span class="add">LOutput *output = compositor()->cursor()->output();

    if(maximized())
    {
        // We reposition it at the end of the surfaces list
        compositor()->raiseSurface(surface());

        // We position it at the origin of the output and under the menu
        surface()->setPosC(LPoint(
                               output->posC().x(),
                               output->posC().y() + MENU_H * compositor()->globalScale()
                               ));

        // Unminimize it if it was minimized
        surface()->setMinimized(false);
    }</span>
}
</pre>

If it changed to maximized state, we place it at the end of the surfaces list with Louvre::LCompositor::raiseSurface() so that it is displayed over the others, we position it in the top-left corner of the output, and unminimize it (if it was).\n
You should now see that the windows no longer overlap the menu when they are maximized.\n

<center>
    <img src="https://lh3.googleusercontent.com/5_IG_jDZH2-7uV9IhMyxujlBi3OrXr1O0Ev-X_eRfi8smxPnfk5ZmAUtxLSPDQxqaZlvQNjxjJ-6RLZP0vEyOw7odWBjjuo0N6D3mCmtKb6OVLnKOy5SKQ5F5qt6NLms-M9aoWXsBw=w2400"/>
</center>

Finally, if the client requests to unmaximize it, we configure it again with the current states minus the **Maximized** flag.\n\n

**MyToplevelRole.cpp**

<pre class="cpp-code">
void MyToplevelRole::unsetMaximizedRequest()
{
    <span class="add">// Configure the Toplevel removing the Maximized flag.
    configureC(states() &~ LToplevelRole::Maximized);</span>
}
</pre>

## Interactive Movement

Clients typically request to start interactive movement sessions of a Toplevel when dragging its title bar.\n
Let's override the virtual method Louvre::LToplevelRole::startMoveRequest() to see how to initiate an interactive movement session.\n\n

**MyToplevelRole.h**

<pre class="cpp-code">
class MyToplevelRole : public LToplevelRole
{
public:
    MyToplevelRole(Params *params);

    // Virtual methods
    void configureRequest() override;
    void setMaximizedRequest() override;
    void unsetMaximizedRequest() override;
    void maximizedChanged() override;
    <span class="add">void startMoveRequest() override;</span>
};
</pre>

**MyToplevelRole.cpp**

<pre class="cpp-code">
<span class="add">void MyToplevelRole::startMoveRequest()
{
    Int32 topConstraint =  compositor()->cursor()->output()->posC().y() + MENU_H * compositor()->globalScale();
    
    seat()->pointer()->startMovingToplevelC(this,
                            LPointer::EdgeDisabled,  // Unconstrained L border
                            topConstraint,           // Constrained T border
                            LPointer::EdgeDisabled,  // Unconstrained R border
                            LPointer::EdgeDisabled); // Unconstrained B border
}</span>
</pre>

To start an interactive movement session, we use Louvre::LPointer::startMovingToplevelC(), which takes as arguments a Toplevel and the edges within which it can be positioned.\n
In this case, we only limit the top edge so that it cannot intersect the menu.\n
If you try to move Toplevels, you will see that they can no longer be located under the menu.

## Fullscreen Mode

Similarly to maximizing, clients can request to show their Toplevels in fullscreen mode.
Let's reimplement the Louvre::LToplevelRole::setFullscreenRequest(), Louvre::LToplevelRole::fullscreenChanged() and Louvre::LToplevelRole::unsetFullscreenRequest() methods to handle these requests.\n
Also, in **MyToplevelRole.h**, let's add a vector **posBeforeFullscreen** to store the position of the Toplevel before entering fullscreen mode, so we can restore it later, and a pointer **fullscreenOutput** to store the output on which it will be displayed.\n\n

**MyToplevelRole.h**

<pre class="cpp-code">
class MyToplevelRole : public LToplevelRole
{
public:
    MyToplevelRole(Params *params);

    LPoint posBeforeFullscreen;
    LOutput *fullscreenOutput;

    // Virtual methods
    void configureRequest() override;

    void setMaximizedRequest() override;
    void unsetMaximizedRequest() override;
    void maximizedChanged() override;

    <span class="add">void setFullscreenRequest(LOutput *dstOutput) override;
    void unsetFullscreenRequest() override;
    void fullscreenChanged()override;</span>

    void startMoveRequest() override;
};
</pre>

**MyToplevelRole.cpp**

<pre class="cpp-code">
<span class="add">void MyToplevelRole::setFullscreenRequest(LOutput *dstOutput)
{
    // If the client specifies an output
    if(destOutput)
        fullscreenOutput = destOutput;
    else
        fullscreenOutput = compositor()->cursor()->output();

    // Save its current position (the one defined by the compositor, not by its role)
    posBeforeFullscreen = surface()->posC();

    // This time we use the full size of the output, including the menu region
    configureC(fullscreenOutput->sizeC(), LToplevelRole::Activated | LToplevelRole::Fullscreen);
}</span>
</pre>

In this case, the client can specify on which output they want to display the Toplevel in fullscreen mode.\n
If it does not specify one, the value of **dstOutput** is equal to **nullptr**, in that case we use the size of the output where the cursor is located.\n

> Note that unlike when we maximized it, in this case we do not configure the output exclusively with the Activated flag so that it remembers its size before going into fullscreen mode.

**MyToplevelRole.cpp**

<pre class="cpp-code">
<span class="add">void MyToplevelRole::fullscreenChanged()
{
    // If enters fullscreen mode
    if(fullscreen())
    {
        surface()->setPosC(fullscreenOutput->posC());
        compositor()->raiseSurface(surface());
    }
    // If exits fullscreen mode
    else
    {
        // Restore previous pos
        surface()->setPosC(posBeforeFullscreen);
    }
}</span>
</pre>

When the Toplevel enters fullscreen mode, we set its position to that of the output and raise it.\n
And when it exits fullscreen mode, we restore its initial position.\n\n

<pre class="cpp-code">
<span class="add">void MyToplevelRole::unsetFullscreenRequest()
{
    // Configure it with (0,0) so that it restores its previous size
    configureC(0, 0, states() &~ LToplevelRole::Fullscreen);
}</span>
</pre>

Finally, when it requests to leave fullscreen mode, we configure it with (0,0) so that it restores its previous size and we also remove the **Fullscreen** flag.\n 
If you compile and run the compositor, you will see that Toplevels go into fullscreen mode and then return to their original size and position. However, the menu is still visible when they are in fullscreen mode, so lets hide it.\n

Add a pointer **fullscreenToplevel** in **MyOutput.h**:\n\n

**MyOutput.h**

<pre class="cpp-code">
#include <LOutput.h>
#include <MyToplevelRole.h>

using namespace Louvre;

class MyOutput : public LOutput
{
public:
    MyOutput();

    <span class="add">MyToplevelRole *fullscreenToplevel = nullptr;</span>
    LTexture *backgroundTexture;

    // Virtual methods
    void initializeGL() override;
    void paintGL() override;
    void uninitializeGL() override;

    void drawBackground();
    void drawSurfaces();
    void drawMenu();
    void drawDNDIcon();
    void drawCursor();
};
</pre>

**MyOutput.cpp**

<pre class="cpp-code">
void MyOutput::drawSurfaces()
{
    LPainter *p = painter();

    LRect srcRectB, dstRectC;

    <span class="add">fullscreenToplevel = nullptr;</span>

    for(LSurface *s : compositor()->surfaces())
    {
        if(!s->mapped() || s->minimized())
            continue;
        else if(s->cursor() || s->dndIcon())
            goto callback;
        <span class="add">else if(s->toplevel() && s->toplevel()->fullscreen())
        {
            MyToplevelRole *toplevel = (MyToplevelRole*)s->toplevel();

            if(toplevel->fullscreenOutput == this)
                fullscreenToplevel = toplevel;
        }</span>

        ...
    }
}
</pre>

At the beginning of **drawSurfaces()** we set the value of the pointer **fullscreenToplevel** to **nullptr**.
Then, if any surface has a Toplevel role, is in fullscreen mode and on the same output, we assign the variable **fullscreenToplevel** to that Toplevel.\n\n

**MyOutput.cpp**

<pre class="cpp-code">
void MyOutput::drawMenu()
{
    <span class="add">
    if(fullscreenToplevel)
        return;</span>
    
    ...
}
</pre>

Finally, in **drawMenu()** we return if **fullscreenToplevel** is different from **nullptr**, to avoid rendering the menu in those cases.\n
If you compile and run the compositor, you will see that now the menu does not appear when there is a Toplevel in fullscreen mode.

# Interactive Resizing

Pending...

> In the next chapter we will see how to handle pointer events (touchpad, mouse, etc.).