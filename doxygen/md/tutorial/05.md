# Chapter 5: Rendering with LPainter

In this chapter, we will delve into the process of rendering content onto the outputs that we have previously initialized.\n
Each Louvre::LOutput operates within its own thread and provides a set of events that can be customized to suit our rendering needs.

#### initializeGL()

The Louvre::LOutput::initializeGL() event is invoked once, right after we initialize the output using Louvre::LCompositor::addOutput(). Within this event, your focus should be on setting up and loading any necessary OpenGL resources, such as shaders, programs, and textures. However, it's important to refrain from performing any painting operations at this stage, as they will not be visible on the screen. Instead, use Louvre::LOutput::repaint() to schedule a new frame (Louvre::LOutput::paintGL() call).

#### paintGL()

The Louvre::LOutput::paintGL() event is triggered asynchronously when we call Louvre::LOutput::repaint() from any thread. Within this event, you should handle all the painting operations necessary for the current output frame.

#### moveGL()

The Louvre::LOutput::moveGL() event is asynchronously triggered each time we alter the position of the output using Louvre::LOutput::setPos(). It's crucial to avoid performing any painting operations within this event, as they will not be displayed on the screen. Instead, use Louvre::LOutput::repaint() to schedule a new frame (Louvre::LOutput::paintGL() call).

#### resizeGL()

Similarly, the Louvre::LOutput::resizeGL() event is called asynchronously whenever we modify the output mode or scale using Louvre::LOutput::setMode() or Louvre::LOutput::setScale(). Each output has one or more modes (Louvre::LOutputMode), each of which dictates its refresh rate and resolution. The default output mode typically offers the highest refresh rate and resolution. To access all available output modes, you can use the Louvre::LOutput::modes() list. Like the other events, it's essential not to perform any painting operations within Louvre::LOutput::resizeGL(), as they will not be visible on the screen. Instead, use Louvre::LOutput::repaint() to schedule a new frame (Louvre::LOutput::paintGL() call).

#### uninitializeGL()

The Louvre::LOutput::uninitializeGL() event is invoked once after we uninitialize an output using Louvre::LCompositor::removeOutput() or when the output is unplugged. We will explore how to listen to output hotplugging events later on. Within this event, your responsibility is to release all the resources created during the Louvre::LOutput::initializeGL() event. It's crucial to avoid any painting operations within Louvre::LOutput::uninitializeGL() because they will not be displayed on the screen.

> It's important to note that you should always initialize/uninitialize or change the mode of an output from the main thread, and never within any of these events, as doing so could lead to a deadlock.

### Custom LOutput

As you might expect, Louvre provides a default mechanism for handling all these events, which is why you were able to see content rendered on your screens previously. Now, let's take control by overriding these virtual methods and creating our custom Louvre::LOutput subclass.

#### src/EOutput.h

```cpp
#ifndef EOUTPUT_H
#define EOUTPUT_H

#include <LOutput.h>

using namespace Louvre;

class EOutput : public LOutput
{
public:
    EOutput();

    void initializeGL() override;
    void moveGL() override;
    void resizeGL() override;
    void paintGL() override;
    void uninitializeGL() override;

    LTexture *wallpaper = nullptr;
};

#endif // EOUTPUT_H
```

Here, we are simply overriding all Louvre::LOutput events. Additionally, we have defined a null pointer for a texture that we will use later as our background wallpaper.

#### src/EOutput.cpp

```cpp
#include "EOutput.h"
#include <LPainter.h>

EOutput::EOutput() {}

void EOutput::initializeGL()
{
    LPainter *p = painter();
    p->setClearColor(0.1, 0.3, 0.8, 1.0);
    repaint();
}

void EOutput::moveGL()
{
    repaint();
}

void EOutput::resizeGL()
{
    repaint();
}

void EOutput::paintGL()
{
    LPainter *p = painter();
    p->clearScreen();
}

void EOutput::uninitializeGL() {}
```

Here, we begin by changing the clear color in `initializeGL()`, and when the output geometry changes, we call Louvre::LOutput::repaint(). In `paintGL()`, we simply clear the screen each frame without any additional operations. Lastly, in `uninitializeGL()`, we perform no actions since we haven't allocated any resources in `initializeGL()` thus far.

### Overriding the Virtual Constructor

To let Louvre use our custom `EOutput` class, we must complete one remaining task: overriding its virtual constructor, specifically the Louvre::LCompositor::createOutputRequest() method.

#### src/ECompositor.h

```cpp
#ifndef ECOMPOSITOR_H
#define ECOMPOSITOR_H

#include <LCompositor.h>

using namespace Louvre;

class ECompositor : public LCompositor
{
public:
    ECompositor();

    void initialized() override;

    // Virtual constructors
    LOutput *createOutputRequest() override;
};

#endif // ECOMPOSITOR_H
```

The graphical backend invokes this virtual constructor whenever it necessitates generating a new output instance. Subsequently, it employs this freshly generated output as an interface for invoking the `...GL()` events previously discussed.

#### src/ECompositor.cpp

```cpp
#include <LOutput.h>
#include "ECompositor.h"
#include "EOutput.h"

ECompositor::ECompositor() {}

void ECompositor::initialized() {...}

LOutput *ECompositor::createOutputRequest()
{
    return new EOutput();
}
```

If you recompile and execute the compositor now, you will only see a bluish background color, and no application windows will be visible. Let's proceed to learn how to render application windows.

## Painting

Louvre offers various methods to help you render content on outputs. You can use your own shaders, the Louvre::LPainter functions (which use an internal shader), or work with the Louvre::LScene and Louvre::LView classes. In this section, we will begin by exploring how to render using Louvre::LPainter, and later, we will cover the use of the Louvre::LScene and Louvre::LView classes. We will also discuss why the latter option may be your preferred choice.

### Rendering with LPainter

To get started, let's first render our background wallpaper. Please select an image and place it in the project directory `project_dir/wallpaper.jpg`.

<img src="https://lh3.googleusercontent.com/pw/AIL4fc9lj1vJ_3ro118B5I8-OzxDcNDVWDwIo3EFF2s32SpQiQ_lSSq9lXBfTug_Js6cI2Bj-jSPL6u5C6iBtXDzMyzAvvWJjBPocygquYDR-V5sIp-leic=w2400"/>

I went with this one because I'm a huge Linux fan.

#### src/EOutput.cpp

```cpp
#include <LPainter.h>
#include <LTexture.h>
#include <LOpenGL.h>
#include <LLog.h>
#include "EOutput.h"

EOutput::EOutput() {}

void EOutput::initializeGL()
{
    wallpaper = LOpenGL::loadTexture("../wallpaper.jpg");

    if (!wallpaper)
        LLog::error("[louvre-example] Failed to load wallpaper.jpg image.");

    repaint();
}

...

void EOutput::paintGL()
{
    LPainter *p = painter();

    if (wallpaper)
        p->drawTexture(wallpaper,
                       LRect(0, 0, wallpaper->sizeB().w(), wallpaper->sizeB().h()),
                       LRect(pos(), size()));
}

void EOutput::uninitializeGL()
{
    if (wallpaper)
        delete wallpaper;
}
```

In `initializeGL()`, we load our wallpaper image using the Louvre::LOpenGL::loadTexture() method. This method supports all image formats that [FreeImage](https://freeimage.sourceforge.io/features.html) supports and returns `nullptr` if it fails. 

In `paintGL()`, we draw the wallpaper using the Louvre::LPainter::drawTexture() method. This method takes three (or more) arguments: the first is the texture we want to render, the second is a rect within the texture that we want to render (in this case, we're using the entire texture), and the third argument defines where we want to draw our texture, in this case we pass the position and size of the output to fully cover it.

It's important to note that Louvre uses both buffer coordinates and surface coordinates. Buffer coordinates represent the maximum granularity within the object, independently of the scale associated with it. For example, if the wallpaper image is 1080x512px, its size in buffer coordinates would be the same, 1080x512. Functions and properties that use buffer coordinates have the "B" suffix, such as `Louvre::LTexture::sizeB()`.

Surface coordinates are a concept from the Wayland protocol and are not exclusive to surfaces. For instance, if one of your outputs has a resolution of 1000x1000px and is also HiDPI with a scale of 2, the size of the output in buffer coordinates would be 1000x1000, but in surface coordinates, it would be 500x500. Surface coordinates are essentially defined as buffer coordinates divided by the buffer scale of the object. Using surface coordinates simplifies continuous transformations between scales and allows you to work in an consistent system while rendering.

In the draw operation, for instance, we use buffer coordinates to define the texture's subrect we want to draw and surface coordinates to define the destination rectangle on the screen where we want to draw it. This approach ensures that if you're working with multiple screens with different scales, the image gets automatically scaled by Louvre::LPainter, eliminating the need to handle transformations manually each time. If you're using your own shaders, you would need to manage scaling transformations yourself. In that case, you can access the OpenGL texture ID with Louvre::LTexture::id().

> In Louvre::LPainter::drawTexture(), there is a fourth parameter known as 'srcScale,' which defaults to 1. This default value is why we defined the 'src' parameter in buffer coordinates. If you decide to change the 'srcScale' to match the actual scale of the texture, it would be advisable to use surface coordinates for the 'src' parameter.

Lastly, in `uninitializeGL()`, we destroy the texture if it was successfully loaded previously.

If you recompile and run, you should now see your wallpaper displayed, but you won't see any application windows yet since we haven't drawn them. Let's proceed to implement the rendering of application windows.

#### Rendering Surfaces

In Wayland, surfaces represent what you would typically think of as application windows. So, in the context of Louvre, each surface has a texture that we can draw.\n
Surfaces, on their own, aren't very useful; they need to have a role assigned before the compositor can utilize them, which provide rules of how to stack them, position them and more. For instance, a client may assign the role of a cursor to a surface (Louvre::LCursorRole), allowing the compositor to use its texture as a cursor (duh), or as a drag & drop icon (Louvre::LDNDIconRole), or as a toplevel window (Louvre::LToplevelRole), as a popup (Louvre::LPopupRole), etc. We will delve deeper into surfaces later, but for now, let's focus on how to render them.

The Louvre::LCompositor class contains a list of all surfaces created by all clients (Louvre::LCompositor::surfaces()). This list always maintains the correct rendering order, from bottom to topmost surfaces. Surface roles usually define a specific stacking order that must be respected by the compositor to function correctly. Therefore, by using this list, you can ensure that the order is respected.

So, let's modify `paintGL()` to draw the available surfaces.

#### src/EOutput.cpp

```cpp
#include <LPainter.h>
#include <LTexture.h>
#include <LOpenGL.h>
#include <LLog.h>
#include <LDNDManager.h>
#include <LCompositor.h>
#include <LCursor.h>
#include <LSeat.h>
#include "EOutput.h"

...

void EOutput::paintGL()
{
    LPainter *p = painter();

    if (wallpaper)
        p->drawTexture(wallpaper,
                       LRect(0, 0, wallpaper->sizeB().w(), wallpaper->sizeB().h()),
                       LRect(pos(), size()));

    if (seat()->dndManager()->icon())
        seat()->dndManager()->icon()->surface()->raise();

    // Draws every surface
    for (LSurface *s : compositor()->surfaces())
    {
        // Skip some surfaces
        if (!s->mapped() || s->minimized() || s->cursorRole())
        {
            if (s->cursorRole())
                s->requestNextFrame();
            continue;
        }

        // Current surface rect
        LRect currentRect = LRect(
            s->rolePos(),
            s->size());

        // Calc which outputs intersects the surface
        for (LOutput *o : compositor()->outputs())
        {
            if (o->rect().intersects(currentRect))
                s->sendOutputEnterEvent(o);
            else
                s->sendOutputLeaveEvent(o);
        }

        // Draws the surface
        p->drawTexture(
            s->texture(),        // Surface texture
            LRect(0, s->sizeB()),// The entire texture size
            currentRect);        // The destination rect on screen

        // Notifies the client that it can render the next frame
        s->requestNextFrame();
    }

    // Manualy draw the cursor if hardware composition is not supported
    if (!cursor()->hasHardwareSupport(this))
    {
        p->drawTexture(
            cursor()->texture(),
            LRect(0, cursor()->texture()->sizeB()),
            cursor()->rect());
    }
}

...
```

There's a lot to cover, so let's break it down step by step:

#### src/EOutput.cpp

```cpp
if (seat()->dndManager()->icon())
    seat()->dndManager()->icon()->surface()->raise();
```
To start, in this section, we are checking if there is an ongoing drag & drop session with an icon. If that's the case, we use Louvre::LSurface::raise() to elevate the icon surface. This action places the icon at the end of the surfaces list, ensuring that it will be rendered above the rest of the surfaces.

#### src/EOutput.cpp

```cpp
if (!s->mapped() || s->minimized() || s->cursorRole())
{
    if (s->cursorRole())
        s->requestNextFrame();
    continue;
}
```
In the for loop, we have several conditions to determine whether or not to render a particular surface. Let's break down these conditions:

1. We use the Louvre::LSurface::mapped() property to decide if the surface should be rendered. This property returns false when the surface does not have a buffer, does not have a role, or if the client wants to hide it.

2. We skip rendering surfaces that are minimized or have the Louvre::LCursorRole since we use the Louvre::LCursor class to render them using hardware composition (we'll cover rendering cursors with Louvre::LCursor later).

3. We call Louvre::LSurface::requestNextFrame(), which allows us to control the rate at which clients repaint their surfaces. It notifies the client that it's a good moment to render new content for the given surface. We should avoid calling it if the surface is obscured by other surfaces or if it's not visible. In this case, we are always letting clients update their cursor surfaces.

#### src/EOutput.cpp

```cpp
// Current surface rect
LRect currentRect = LRect(
    s->rolePos(),
    s->size());

// Calc which outputs intersects the surface
for (LOutput *o : compositor()->outputs())
{
    if (o->rect().intersects(currentRect))
        s->sendOutputEnterEvent(o);
    else
        s->sendOutputLeaveEvent(o);
}

// Draws the surface
p->drawTexture(
    s->texture(),        // Surface texture
    LRect(0, s->sizeB()),// The entire texture size
    currentRect);        // The destination rect on screen

// Notifies the client that it can render the next frame
s->requestNextFrame();
```

Next, we determine on which outputs the surface is currently visible and notify the client using Louvre::LSurface::sendOutputEnterEvent() and Louvre::LSurface::sendOutputLeaveEvent(). This informs the client about the outputs where their surfaces are currently visible, allowing them to adjust the surface scale to match the scale of the output (surfaces also have a scale).

After that, we proceed to render the entire Louvre::LSurface::texture(). In this case, we draw it on the screen using the position specified by its current role, which is accessible through Louvre::LSurface::rolePos().

#### src/EOutput.cpp

```cpp
// Manualy draw the cursor if hardware composition is not supported
if (!cursor()->hasHardwareSupport(this))
{
    p->drawTexture(
        cursor()->texture(),
        LRect(0, cursor()->texture()->sizeB()),
        cursor()->rect());
}
```

Finally, we check if hardware cursor compositing is available. Hardware cursor compositing is a feature found in many hardware systems that allows the display of a cursor on the screen in a highly efficient manner, without the need to render it using OpenGL. If hardware composition is not supported, we proceed to render the current cursor using OpenGL. In this case the unique Louvre::LCursor instance provides us the current cursor texture and also the destination rect where we should render it with Louvre::LCursor::rect().

If you recompile and run, you should now see both your wallpaper and the application windows in the background.

## Poor Performance ðŸ˜¥

While the rendering logic we've just implemented may appear straightforward, it's unfortunately quite inefficient. This inefficiency stems from the fact that we're repainting the entire screen in each frame, including the background wallpaper and all the surfaces, even if only a small change occurs or parts of surfaces are hidden by others.

To create an efficient compositor that people would want to use, we should only repaint the regions that change in each frame. To achieve this, we need to consider several factors: the surfaces' opaque and translucent regions, the surfaces' damage regions, and the outputs inter-frame damage.

Each surface has both translucent and opaque regions (Louvre::LSurface::translucentRegion() and Louvre::LSurface::opaqueRegion()), which contain lists of non-overlapping rectangles positioned relative to the surface's top-left corner. These regions can help us prevent rendering objects behind opaque regions.

Additionally, each surface has a damage region (Louvre::LSurface::damage()), similar to the opaque and translucent regions, which indicates which parts of the surface have changed and need repainting. This region is cleared after calling Louvre::LSurface::requestNextFrame().

Lastly, we need to keep track of the output damage. Typically, each output uses more than one framebuffer. While one framebuffer is being displayed on the screen, we render to the other buffer, and then we swap, repeating this process to prevent screen tearing.
So in order to handle damage tracking effectively, we would need to use Louvre::LOutput::currentBuffer(). This function provides the index of the buffer we're currently rendering to, which can range from [0] for single buffering to [0,1] for double buffering, or even [0,1,2] for triple buffering, depending on your setup.

You can use the Louvre::LRegion class to perform efficient boolean rectangle operations to calculate the region that needs repainting each frame. However, due to its complexity, we won't cover it here. You can refer to the [louvre-weston-clone](md_md__examples.html#weston) compositor example to see how it's done, but be warned that it can be quite complex.

## Good News! ðŸ˜ƒ

Fortunately, Louvre provides an excellent solution to this problem: the Louvre::LScene and Louvre::LView system. These classes simplify the process of efficiently rendering only the necessary regions, and we will explore them in the following chapter.

<a href="md_md_tutorial_04.html">â—€ Chapter 4: Compositor Initialization</a> || <a href="md_md_tutorial_06.html"> Chapter 6: Rendering with LScene and LViews â–¶</a>