/* Generated by wayland-scanner 1.23.0 */

#ifndef BACKGROUND_BLUR_SERVER_PROTOCOL_H
#define BACKGROUND_BLUR_SERVER_PROTOCOL_H

#include <stdint.h>
#include <stddef.h>
#include "wayland-server.h"

#ifdef  __cplusplus
extern "C" {
#endif

struct wl_client;
struct wl_resource;

/**
 * @page page_background_blur The background_blur protocol
 * @section page_ifaces_background_blur Interfaces
 * - @subpage page_iface_background_blur_manager - background blur manager
 * - @subpage page_iface_background_blur - background blur object
 * @section page_copyright_background_blur Copyright
 * <pre>
 *
 * Copyright Â© 2025 Cuarzo Software
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 * </pre>
 */
struct background_blur;
struct background_blur_manager;
struct svg_path;
struct wl_region;
struct wl_surface;

#ifndef BACKGROUND_BLUR_MANAGER_INTERFACE
#define BACKGROUND_BLUR_MANAGER_INTERFACE
/**
 * @page page_iface_background_blur_manager background_blur_manager
 * @section page_iface_background_blur_manager_desc Description
 *
 * This interface allows a compositor to announce support for blurring the 
 * backgrounds of surfaces.
 * @section page_iface_background_blur_manager_api API
 * See @ref iface_background_blur_manager.
 */
/**
 * @defgroup iface_background_blur_manager The background_blur_manager interface
 *
 * This interface allows a compositor to announce support for blurring the 
 * backgrounds of surfaces.
 */
extern const struct wl_interface background_blur_manager_interface;
#endif
#ifndef BACKGROUND_BLUR_INTERFACE
#define BACKGROUND_BLUR_INTERFACE
/**
 * @page page_iface_background_blur background_blur
 * @section page_iface_background_blur_desc Description
 *
 * Blur effect that is applied to the background of a surface.
 *
 * Starting from version 2, clients are permitted to define the blur area
 * using a round rect.
 *
 * Starting from version 3, clients are permitted to define the blur area
 * using an svg_path object.
 *
 * Using either set_region, set_round_rect or set_path replaces the last specified blur area.
 *
 * The blur area is always defined in local surface coordinates and must not extend beyond the 
 * surface bounds otherwise the out_of_bounds error is emitted. 
 *
 * The client should avoid both rendering completly opaque content within the blur area while enabled.
 *
 * The initial blur area is an empty region (no blur).
 * @section page_iface_background_blur_api API
 * See @ref iface_background_blur.
 */
/**
 * @defgroup iface_background_blur The background_blur interface
 *
 * Blur effect that is applied to the background of a surface.
 *
 * Starting from version 2, clients are permitted to define the blur area
 * using a round rect.
 *
 * Starting from version 3, clients are permitted to define the blur area
 * using an svg_path object.
 *
 * Using either set_region, set_round_rect or set_path replaces the last specified blur area.
 *
 * The blur area is always defined in local surface coordinates and must not extend beyond the 
 * surface bounds otherwise the out_of_bounds error is emitted. 
 *
 * The client should avoid both rendering completly opaque content within the blur area while enabled.
 *
 * The initial blur area is an empty region (no blur).
 */
extern const struct wl_interface background_blur_interface;
#endif

#ifndef BACKGROUND_BLUR_MANAGER_ERROR_ENUM
#define BACKGROUND_BLUR_MANAGER_ERROR_ENUM
enum background_blur_manager_error {
	/**
	 * the surface already has an associated background blur object
	 */
	BACKGROUND_BLUR_MANAGER_ERROR_ALREADY_CONSTRUCTED = 0,
};
/**
 * @ingroup iface_background_blur_manager
 * Validate a background_blur_manager error value.
 *
 * @return true on success, false on error.
 * @ref background_blur_manager_error
 */
static inline bool
background_blur_manager_error_is_valid(uint32_t value, uint32_t version) {
	switch (value) {
	case BACKGROUND_BLUR_MANAGER_ERROR_ALREADY_CONSTRUCTED:
		return version >= 1;
	default:
		return false;
	}
}
#endif /* BACKGROUND_BLUR_MANAGER_ERROR_ENUM */

/**
 * @ingroup iface_background_blur_manager
 * @struct background_blur_manager_interface
 */
struct background_blur_manager_interface {
	/**
	 * destroy the background blur manager object
	 *
	 * Destroy the background blur manager. This doesn't destroy
	 * objects created with the manager.
	 */
	void (*destroy)(struct wl_client *client,
			struct wl_resource *resource);
	/**
	 * create a new background blur object
	 *
	 * Creates a new background blur object for a given surface.
	 *
	 * The surface must not already have an associated background blur,
	 * otherwise the already_constructed error is emitted.
	 *
	 * Immediately after the object is created, the compositor will
	 * send a state event, a style event, and finally a configure
	 * event.
	 *
	 * Surfaces must acknowledge the configure event and may then
	 * define the blur region, round rect or SVG path before the next
	 * commit.
	 *
	 * The client may ignore all configure events except for the last
	 * one.
	 *
	 * A client can send multiple ack_configure requests before
	 * committing, but only the last request sent prior to the commit
	 * indicates which configure event the client is responding to.
	 */
	void (*get_background_blur)(struct wl_client *client,
				    struct wl_resource *resource,
				    uint32_t id,
				    struct wl_resource *surface);
};


/**
 * @ingroup iface_background_blur_manager
 */
#define BACKGROUND_BLUR_MANAGER_DESTROY_SINCE_VERSION 1
/**
 * @ingroup iface_background_blur_manager
 */
#define BACKGROUND_BLUR_MANAGER_GET_BACKGROUND_BLUR_SINCE_VERSION 1

#ifndef BACKGROUND_BLUR_ERROR_ENUM
#define BACKGROUND_BLUR_ERROR_ENUM
enum background_blur_error {
	/**
	 * surface destroyed before object
	 */
	BACKGROUND_BLUR_ERROR_DESTROYED_SURFACE = 0,
	/**
	 * invalid ack serial
	 */
	BACKGROUND_BLUR_ERROR_INVALID_SERIAL = 1,
	/**
	 * the region, round rect or path extends beyond the surface bounds
	 */
	BACKGROUND_BLUR_ERROR_OUT_OF_BOUNDS = 2,
	/**
	 * invalid round rect
	 * @since 2
	 */
	BACKGROUND_BLUR_ERROR_INVALID_ROUND_RECT = 3,
	/**
	 * invalid svg path
	 * @since 3
	 */
	BACKGROUND_BLUR_ERROR_INVALID_PATH = 4,
};
/**
 * @ingroup iface_background_blur
 */
#define BACKGROUND_BLUR_ERROR_INVALID_ROUND_RECT_SINCE_VERSION 2
/**
 * @ingroup iface_background_blur
 */
#define BACKGROUND_BLUR_ERROR_INVALID_PATH_SINCE_VERSION 3
/**
 * @ingroup iface_background_blur
 * Validate a background_blur error value.
 *
 * @return true on success, false on error.
 * @ref background_blur_error
 */
static inline bool
background_blur_error_is_valid(uint32_t value, uint32_t version) {
	switch (value) {
	case BACKGROUND_BLUR_ERROR_DESTROYED_SURFACE:
		return version >= 1;
	case BACKGROUND_BLUR_ERROR_INVALID_SERIAL:
		return version >= 1;
	case BACKGROUND_BLUR_ERROR_OUT_OF_BOUNDS:
		return version >= 1;
	case BACKGROUND_BLUR_ERROR_INVALID_ROUND_RECT:
		return version >= 2;
	case BACKGROUND_BLUR_ERROR_INVALID_PATH:
		return version >= 3;
	default:
		return false;
	}
}
#endif /* BACKGROUND_BLUR_ERROR_ENUM */

#ifndef BACKGROUND_BLUR_STATE_ENUM
#define BACKGROUND_BLUR_STATE_ENUM
enum background_blur_state {
	/**
	 * the blur effect is not displayed by the compositor
	 */
	BACKGROUND_BLUR_STATE_DISABLED = 0,
	/**
	 * the blur effect is displayed by the compositor
	 */
	BACKGROUND_BLUR_STATE_ENABLED = 1,
};
/**
 * @ingroup iface_background_blur
 * Validate a background_blur state value.
 *
 * @return true on success, false on error.
 * @ref background_blur_state
 */
static inline bool
background_blur_state_is_valid(uint32_t value, uint32_t version) {
	switch (value) {
	case BACKGROUND_BLUR_STATE_DISABLED:
		return version >= 1;
	case BACKGROUND_BLUR_STATE_ENABLED:
		return version >= 1;
	default:
		return false;
	}
}
#endif /* BACKGROUND_BLUR_STATE_ENUM */

#ifndef BACKGROUND_BLUR_STYLE_ENUM
#define BACKGROUND_BLUR_STYLE_ENUM
enum background_blur_style {
	/**
	 * the blur effect has a dark tone
	 */
	BACKGROUND_BLUR_STYLE_DARK = 0,
	/**
	 * the blur effect has a light tone
	 */
	BACKGROUND_BLUR_STYLE_LIGHT = 1,
};
/**
 * @ingroup iface_background_blur
 * Validate a background_blur style value.
 *
 * @return true on success, false on error.
 * @ref background_blur_style
 */
static inline bool
background_blur_style_is_valid(uint32_t value, uint32_t version) {
	switch (value) {
	case BACKGROUND_BLUR_STYLE_DARK:
		return version >= 1;
	case BACKGROUND_BLUR_STYLE_LIGHT:
		return version >= 1;
	default:
		return false;
	}
}
#endif /* BACKGROUND_BLUR_STYLE_ENUM */

/**
 * @ingroup iface_background_blur
 * @struct background_blur_interface
 */
struct background_blur_interface {
	/**
	 * destroy the vector path object
	 *
	 * Switch back to a mode without background blur at the next
	 * commit.
	 *
	 * Must be destroyed before the surface otherwise the
	 * destroyed_surface error is triggered.
	 */
	void (*destroy)(struct wl_client *client,
			struct wl_resource *resource);
	/**
	 * set the blurred region
	 *
	 * 
	 *
	 * This is a double-buffered operation, refer to wl_surface.commit.
	 *
	 * Setting the pending blur region has copy semantics, allowing the
	 * wl_region object to be destroyed immediately.
	 *
	 * Setting a null region means that the blur area automatically
	 * adapts to the entire surface dimensions.
	 *
	 * In order to display the blur effect, the compositor must send an
	 * enabled state event, a configure event, and the client must ACK
	 * and commit a null or valid non-empty region, round rect or SVG
	 * path.
	 *
	 * The same applies afterwards, the compositor should keep the
	 * effect state and style until the client acknowledges and commits
	 * a new configuration.
	 *
	 * The initial blur area is an empty region (no blur).
	 */
	void (*set_region)(struct wl_client *client,
			   struct wl_resource *resource,
			   struct wl_resource *blur_region);
	/**
	 * ack a pending configuration
	 *
	 * Acknowledging a serial that has not been sent, or one that has
	 * already been acknowledged, triggers the invalid_serial error.
	 * @param serial serial of the configure event
	 */
	void (*ack_configure)(struct wl_client *client,
			      struct wl_resource *resource,
			      uint32_t serial);
	/**
	 * set the blur area using a round rect
	 *
	 * Setting a negative width, height, or radius, or if the sum of
	 * radii for an edge exceeds the dimensions for that axis, triggers
	 * the invalid_round_rect error.
	 * @since 2
	 */
	void (*set_round_rect)(struct wl_client *client,
			       struct wl_resource *resource,
			       int32_t x,
			       int32_t y,
			       int32_t width,
			       int32_t height,
			       int32_t radTL,
			       int32_t radTR,
			       int32_t radBR,
			       int32_t radBL);
	/**
	 * set the blur area using an svg_path object
	 *
	 * 
	 *
	 * Setting the pending blur path has copy semantics, allowing the
	 * svg_path object to be destroyed immediately.
	 *
	 * Setting an unconstructed or invalid path triggers the
	 * invalid_path error.
	 * @param path the SVG path commands
	 * @since 3
	 */
	void (*set_path)(struct wl_client *client,
			 struct wl_resource *resource,
			 struct wl_resource *path);
};

#define BACKGROUND_BLUR_STATE 0
#define BACKGROUND_BLUR_STYLE 1
#define BACKGROUND_BLUR_CONFIGURE 2

/**
 * @ingroup iface_background_blur
 */
#define BACKGROUND_BLUR_STATE_SINCE_VERSION 1
/**
 * @ingroup iface_background_blur
 */
#define BACKGROUND_BLUR_STYLE_SINCE_VERSION 1
/**
 * @ingroup iface_background_blur
 */
#define BACKGROUND_BLUR_CONFIGURE_SINCE_VERSION 1

/**
 * @ingroup iface_background_blur
 */
#define BACKGROUND_BLUR_DESTROY_SINCE_VERSION 1
/**
 * @ingroup iface_background_blur
 */
#define BACKGROUND_BLUR_SET_REGION_SINCE_VERSION 1
/**
 * @ingroup iface_background_blur
 */
#define BACKGROUND_BLUR_ACK_CONFIGURE_SINCE_VERSION 1
/**
 * @ingroup iface_background_blur
 */
#define BACKGROUND_BLUR_SET_ROUND_RECT_SINCE_VERSION 2
/**
 * @ingroup iface_background_blur
 */
#define BACKGROUND_BLUR_SET_PATH_SINCE_VERSION 3

/**
 * @ingroup iface_background_blur
 * Sends an state event to the client owning the resource.
 * @param resource_ The client's resource
 * @param state The state of the blur effect.
 */
static inline void
background_blur_send_state(struct wl_resource *resource_, uint32_t state)
{
	wl_resource_post_event(resource_, BACKGROUND_BLUR_STATE, state);
}

/**
 * @ingroup iface_background_blur
 * Sends an style event to the client owning the resource.
 * @param resource_ The client's resource
 * @param style The color tone of the blur effect.
 */
static inline void
background_blur_send_style(struct wl_resource *resource_, uint32_t style)
{
	wl_resource_post_event(resource_, BACKGROUND_BLUR_STYLE, style);
}

/**
 * @ingroup iface_background_blur
 * Sends an configure event to the client owning the resource.
 * @param resource_ The client's resource
 * @param serial serial of the configure event
 */
static inline void
background_blur_send_configure(struct wl_resource *resource_, uint32_t serial)
{
	wl_resource_post_event(resource_, BACKGROUND_BLUR_CONFIGURE, serial);
}

#ifdef  __cplusplus
}
#endif

#endif
