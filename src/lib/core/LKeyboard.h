#ifndef LKEYBOARD_H
#define LKEYBOARD_H

#include <LObject.h>
#include <xkbcommon/xkbcommon.h>

using namespace Louvre::Protocols;

/*!
 * @brief Class for handling keyboard events.
 *
 * The LKeyboard class has virtual methods to access keyboard events generated by the input backend.\n
 * Allows you to assign the keyboard map, send events to client surfaces and configure parameters such as
 * the repeat rate when holding down a key.\n
 * There is a single instance of LKeyboard, which can be accessed from LSeat::keyboard().
 *
 * ### Wayland Events
 *
 * To send keyboard events to clients, you must first assign focus to a surface using one of the setFocus() variants.\n
 * This process entails removing focus from any previously focused surface. As a result, all subsequent keyboard events will be directed to the currently focused surface.
 *
 * @note It's important to note that only one surface can be focused at a time to receive keyboard input.
 */
class Louvre::LKeyboard : public LObject
{
public:

    /*!
     * @brief Constructor parameters.
     *
     * Configuration parameters passed in the LCompositor::createKeyboardRequest() virtual constructor.
     */
    struct Params;

    /*!
     * @brief Keyboard modifiers.
     *
     * Stores the status of keyboard modifiers (Ctrl, Shift, Alt, etc).
     */
    struct KeyboardModifiersState
    {
        /// Active modifiers when physically pressed
        UInt32 depressed;

        /// Hooked modifiers that will be disabled after a non-modifier key is pressed
        UInt32 latched;

        /// Active modifiers until they are pressed again (e.g. the Shift key)
        UInt32 locked;

        /// Group the above states (use this value if the source of a modifier change is not of your interest)
        UInt32 group;
    };

    /*!
     * @brief Key states.
     *
     * Enum with the possible states of a key.
     */
    enum KeyState : UChar8
    {
        /// The key is not being pressed
        Released = 0,

        /// The key is pressed
        Pressed = 1
    };

    /*!
     * @brief Set the surface that grabs keyboard events.
     *
     * This function redirects all keyboard events to the given surface.
     * For example, a LPopupRole can request to make a keyboard grab (see LPopupRole::grabRequest()).
     * If 'surface' is set to nullptr, the keyboard grab is disabled.
     *
     * @param surface The surface that will grab the keyboard events.
     * @param keyboardResource The specific wl_keyboard resource created by the client to which events must be sent.
     *        Clients may bind multiple times to the wl_seat interface.
     */
    void setGrabbingSurface(LSurface* surface, Wayland::RKeyboard* keyboardResource);

    /*!
     * @brief Get the current surface that is grabbing the keyboard events.
     *
     * This function returns the surface that is currently grabbing the keyboard events.
     * If no grab is active, it returns nullptr.
     *
     * @returns The surface that is grabbing keyboard events, or nullptr if no grab is active.
     */
    LSurface* grabbingSurface() const;

    /*!
     * @brief Get the current wl_keyboard resource used during the keyboard grab.
     *
     * This function returns the wl_keyboard resource to which keyboard events are sent during the grab.
     * If no grab is active, it returns nullptr.
     *
     * @returns The wl_keyboard resource used during the keyboard grab, or nullptr if no grab is active.
     */
    Wayland::RKeyboard* grabbingKeyboardResource() const;

    /*!
     * @brief Constructor of the LKeyboard class.
     *
     * There is a single instance of LKeyboard, which can be accessed from LSeat::keyboard().
     *
     * @param params Internal library parameters passed in the LCompositor::createKeyboardRequest() virtual constructor.
     */
    LKeyboard(Params *params);

    /*!
     * @brief Destructor of the LKeyboard class.
     *
     * Invoked internally by the library after LCompositor::destroyKeyboardRequest() is called.
     */
    virtual ~LKeyboard();

    LKeyboard(const LKeyboard&) = delete;
    LKeyboard& operator= (const LKeyboard&) = delete;

    /*!
     * @brief Surface with keyboard focus.
     *
     * Pointer to the surface with keyboard focus assigned with setFocus(). Only surfaces with keyboard focus can receive keyboard events.\n
     * @returns nullptr if no surface has keyboard focus.
     */
    LSurface *focusSurface() const;

    /*!
     * @brief State of the keyboard modifiers.
     *
     * @returns An instance of KeyboardModifiersState, which stores the state of the keyboard modifiers.
     */
    const KeyboardModifiersState &modifiersState() const;

    /*!
     * @brief Keyboard map file descriptor.
     *
     * File descriptor of the XKB keyboard map assigned with setKeymap().
     */
    Int32 keymapFd() const;

    /*!
     * @brief Size of the keyboard map in bytes.
     *
     * Size in bytes of the XKB keyboard map loaded in setKeymap().
     */
    Int32 keymapSize() const;

    /*!
     * The keymap format can be either WL_KEYBOARD_KEYMAP_FORMAT_XKB_V1,
     * which indicates the presence of a valid XKB keymap set, or WL_KEYBOARD_KEYMAP_FORMAT_NO_KEYMAP,
     * indicating an issue with the XKB system configuration.
     */
    UInt32 keymapFormat() const;

    // Since 4

    /*!
     * Repetition rate.\n\n
     *
     * Number of repetitions per second of a key when held down, assigned with setRepeatInfo().\n
     * The default value is 32.
     */
    Int32 repeatRate() const;

    /*!
     * Repeat delay.\n\n
     *
     * Delay in milliseconds before triggering the repetition of a key by holding it down, assigned with setRepeatInfo().\n
     * The default value is 500 ms.
     */
    Int32 repeatDelay() const;

    /*!
     * Assigns the repeat rate and delay.\n\n
     *
     * Assigns the repeat rate and delay when holding down a key.\n
     * The library internally calls the [wl_keyboard::repeat_info](https://wayland.app/protocols/wayland#wl_keyboard:event:repeat_info) event
     * of the Wayland protocol.
     * @param rate Number of repetitions per second. 0 turns off repetition.
     * @param msDelay Delay in milliseconds before triggering the replay.
     */
    void setRepeatInfo(Int32 rate, Int32 msDelay);

    /*!
     * @brief Key symbol.
     *
     * Returns the symbol of a key code generated by the input backend according to the layout and status of the keyboard map.\n
     *
     * The complete list of symbols can be found in the '''<xkbcommon/xkbcommon-keysyms.h>''' header or [here](https://github.com/xkbcommon/libxkbcommon/blob/master/include/xkbcommon/xkbcommon-keysyms.h).
     */
    xkb_keysym_t keySymbol(UInt32 keyCode);

    /*!
     * @brief Keyboard state.
     *
     * XKB keyboard map state.
     */
    xkb_state *keymapState() const;

    /*!
     * @brief Indicates whether a modifier is active.
     *
     * @param name Name of the modifier "Control", "Shift", etc.
     * @returns true if the switch is active, and false otherwise.
     */
    bool isModActive(const char *name) const;

    /*!
     * List of pressed key codes.
     */
    const std::list<UInt32>&pressedKeys() const;

    /*!
     * Check if a key code is pressed.
     */
    bool isKeyCodePressed(UInt32 keyCode) const;

    /*!
     * @brief Assign the keyboard layout.
     *
     * Find and assign a keyboard map that matches the parameters passed in the arguments.\n
     * The keyboard layout is automatically sent to clients when they connect to the compositor and use the wl_keyboard interface 
     * of the Wayland protocol. If a client is already connected, the library re-sends it the new layout.\n
     * The library by default assigns the "latam" layout in LCompositor::initialized().\n
     * The library internally calls the [wl_keyboard::keymap](https://wayland.app/protocols/wayland#wl_keyboard:event:keymap) event
     * of the Wayland protocol.
     *
     * @param rules Rules on how to interpret the other arguments. Can be NULL. [More information] (https://xkbcommon.org/doc/current/structxkb__rule__names.html#a0968f4602001f2306febd32c34bd2280).
     * @param model Keyboard model. Can be NULL. [More information] (https://xkbcommon.org/doc/current/structxkb__rule__names.html#a0968f4602001f2306febd32c34bd2280).
     * @param layout Keyboard layouts separated by comma (e.g. "latam"). Can be NULL. [More information] (https://xkbcommon.org/doc/current/structxkb__rule__names.html#a0968f4602001f2306febd32c34bd2280).
     * @param variant Variants of layouts. Can be NULL. [More information] (https://xkbcommon.org/doc/current/structxkb__rule__names.html#a0968f4602001f2306febd32c34bd2280).
     * @param options Preferences not related to layouts. Can be NULL. [More information] (https://xkbcommon.org/doc/current/structxkb__rule__names.html#a0968f4602001f2306febd32c34bd2280).
     */
    bool setKeymap(const char *rules = NULL, const char *model = NULL, const char *layout = NULL, const char *variant = NULL, const char *options = NULL);

    /*!
     * @brief Assigns keyboard focus to a surface.
     *
     * Assigns the keyboard focus to the surface passed in the argument. The library automatically removes keyboard focus from the surface
     * that currently owns it (only one surface can have keyboard focus at a time).\n
     * Having keyboard focus is required for a surface to receive events sent with sendKeyEvent() and sendModifiersEvent().\n
     * Passing nullptr as argument removes the keyboard focus from all surfaces.\n
     * The library internally calls the [wl_keyboard::enter](https://wayland.app/protocols/wayland#wl_keyboard:event:enter) and 
     * [wl_keyboard::leave](https://wayland.app/protocols/wayland#wl_keyboard:event:leave) events of the Wayland protocol.
     */
    void setFocus(LSurface *surface);

    /*!
     * @brief Sends a key event to a client surface.
     *
     * Sends a key event to the surface with keyboard focus.\n
     * The library internally calls the [wl_keyboard::key](https://wayland.app/protocols/wayland#wl_keyboard:event:key) event of the Wayland protocol.
     * @param keyCode Key identifier (generated by the input backend).
     * @param keyState Key state (KeyState::Pressed or KeyState::Released).
     */
    void sendKeyEvent(UInt32 keyCode, UInt32 keyState);

    /*!
     * @brief Sends modifiers states.
     *
     * Sends modifiers states to the surface with keyboard focus.\n
     * The library internally calls the [wl_keyboard::modifiers](https://wayland.app/protocols/wayland#wl_keyboard:event:modifiers) event of the Wayland protocol.\n
     *
     * The parameters are equivalent to those described in KeyboardModifiersState.
     */
    void sendModifiersEvent(UInt32 depressed, UInt32 latched, UInt32 locked, UInt32 group);

    /*!
     * @brief Sends the current modifiers states.
     *
     * Sends the modifiers states to the surface with keyboard focus.\n
     * The library internally stores and updates the modifiers state, which can be accessed with modifiersState().\n
     * The library internally calls the [wl_keyboard::modifiers](https://wayland.app/protocols/wayland#wl_keyboard:event:modifiers) event of the Wayland protocol.\n
     */
    void sendModifiersEvent();

    /*!
     * @brief Notifies a change in the modifiers state.
     *
     * Override this virtual method if you want to be notified when the keyboard modifiers state changes.\n
     * The default implementation sends the updated modifiers state to the surface with keyboard focus.
     *
     * #### Default implementation
     * @snippet LKeyboardDefault.cpp keyModifiersEvent
     */
    virtual void keyModifiersEvent(UInt32 depressed, UInt32 latched, UInt32 locked, UInt32 group);

    /*!
     * @brief Notifies a key state change.
     *
     * Override this virtual method if you want to be notified when a key state changes.\n
     * The default implementation sends the key state to the surface with keyboard focus, sets the action of
     * drag & drop sessions, allows to start Weston-terminal perssing F1, raise or lower the system volume, and so on.
     *
     * #### Default implementation
     * @snippet LKeyboardDefault.cpp keyEvent
     */
    virtual void keyEvent(UInt32 keyCode, KeyState keyState);

    /**
     * @brief Invoked when the current keyboard focused surface is reassigned with setFocus().
     *
     * This virtual method is called when the keyboard focus is changed to a new surface
     * using the setFocus() method. To retrieve the currently focused surface, you can use
     * the focusSurface() method.
     *
     * This method provides a way for subclasses or implementors to respond to changes in
     * keyboard focus and perform necessary actions when the focus is switched to a different
     * surface.
     *
     * @note This method should be overridden in subclasses to provide custom behavior.
     *
     * @see setFocus()
     * @see focusSurface()
     *
     * #### Default implementation
     * @snippet LKeyboardDefault.cpp focusChanged
     */
    virtual void focusChanged();

    LPRIVATE_IMP(LKeyboard)
};

#endif // LKEYBOARD_H
