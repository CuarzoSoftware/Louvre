#ifndef LKEYBOARD_H
#define LKEYBOARD_H

#include <LObject.h>
#include <xkbcommon/xkbcommon.h>

/*!
 * @brief Class for handling keyboard events.
 *
 * The LKeyboard class has virtual methods to access keyboard events generated by the input backend.\n
 * Allows you to assign the keyboard map, send events to client surfaces and configure parameters such as
 * the repeat rate when holding down a key.\n
 * There is a single instance of LKeyboard, which can be accessed from LSeat::keyboard().
 */
class Louvre::LKeyboard : public LObject
{
public:

    /*!
     * @brief Constructor parameters.
     *
     * Configuration parameters passed in the LCompositor::createKeyboardRequest() virtual constructor.
     */
    struct Params;

    /*!
     * @brief Keyboard modifiers.
     *
     * Stores the status of keyboard modifiers (Ctrl, Shift, Alt, etc).
     */
    struct KeyboardModifiersState
    {
        /// Active modifiers when physically pressed
        UInt32 depressed;

        /// Hooked modifiers that will be disabled after a non-modifier key is pressed
        UInt32 latched;

        /// Active modifiers until they are pressed again (e.g. the Shift key)
        UInt32 locked;

        /// Group the above states (use this value if the source of a modifier change is not of your interest)
        UInt32 group;
    };

    /*!
     * @brief Key states.
     *
     * Enum with the possible states of a key.
     */
    enum KeyState : UChar8
    {
        /// The key is not being pressed
        Released = 0,

        /// The key is pressed
        Pressed = 1
    };

    /*!
     * @brief Constructor of the LKeyboard class.
     *
     * There is a single instance of LKeyboard, which can be accessed from LSeat::keyboard().
     *
     * @param params Internal library parameters passed in the LCompositor::createKeyboardRequest() virtual constructor.
     */
    LKeyboard(Params *params);

    /*!
     * @brief Destructor of the LKeyboard class.
     *
     * Invoked internally by the library after LCompositor::destroyKeyboardRequest() is called.
     */
    virtual ~LKeyboard();

    LKeyboard(const LKeyboard&) = delete;
    LKeyboard& operator= (const LKeyboard&) = delete;

    /*!
     * @brief Surface with keyboard focus.
     *
     * Pointer to the surface with keyboard focus assigned with setFocus(). Only surfaces with keyboard focus can receive keyboard events.\n
     * @returns nullptr if no surface has keyboard focus.
     */
    LSurface *focusSurface() const;

    /*!
     * @brief State of the keyboard modifiers.
     *
     * @returns An instance of KeyboardModifiersState, which stores the state of the keyboard modifiers.
     */
    const KeyboardModifiersState &modifiersState() const;

    /*!
     * @brief Keyboard map file descriptor.
     *
     * File descriptor of the XKB keyboard map assigned with setKeymap().
     */
    Int32 keymapFd() const;

    /*!
     * @brief Size of the keyboard map in bytes.
     *
     * Size in bytes of the XKB keyboard map loaded in setKeymap().
     */
    Int32 keymapSize() const;

#if LOUVRE_WL_SEAT_VERSION >= 4

    /*!
     * @brief Repetition rate.
     *
     * Number of repetitions per second of a key when held down, assigned with setRepeatInfo().\n
     * The default value is 32.
     */
    Int32 repeatRate() const;

    /*!
     * @brief Repeat delay.
     *
     * Delay in milliseconds before triggering the repetition of a key by holding it down, assigned with setRepeatInfo().\n
     * The default value is 500 ms.
     */
    Int32 repeatDelay() const;

    /*!
     * @brief Assigns the repeat rate and delay.
     *
     * Assigns the repeat rate and delay when holding down a key.\n
     * The library internally calls the [wl_keyboard::repeat_info](https://wayland.app/protocols/wayland#wl_keyboard:event:repeat_info) event
     * of the Wayland protocol.
     * @param rate Number of repetitions per second. 0 turns off repetition.
     * @param msDelay Delay in milliseconds before triggering the replay.
     */
    void setRepeatInfo(Int32 rate, Int32 msDelay);
#endif

    /*!
     * @brief Key symbol.
     *
     * Returns the symbol of a key code generated by the input backend according to the layout and status of the keyboard map.\n
     *
     * The complete list of symbols can be found in the '''<xkbcommon/xkbcommon-keysyms.h>''' header or [here](https://github.com/xkbcommon/libxkbcommon/blob/master/include/xkbcommon/xkbcommon-keysyms.h).
     */
    xkb_keysym_t keySymbol(UInt32 keyCode);

    /*!
     * @brief Keyboard status.
     *
     * Keyboard map status.
     */
    xkb_state *keymapState() const;

    /*!
     * @brief Indicates whether a modifier is active.
     *
     * @param name Name of the modifier "Control", "Shift", etc.
     * @returns true if the switch is active, and false otherwise.
     */
    bool isModActive(const char *name) const;

    /*!
     * List of pressed key codes.
     */
    const std::list<UInt32>&pressedKeys() const;

    /*!
     * @brief Assign the keyboard layout.
     *
     * Find and assign a keyboard map that matches the parameters passed in the arguments.\n
     * The keyboard layout is automatically sent to clients when they connect to the compositor and use the wl_keyboard interface 
     * of the Wayland protocol. If a client is already connected, the library re-sends it the new layout.\n
     * The library by default assigns the "latam" layout in LCompositor::initialized().\n
     * The library internally calls the [wl_keyboard::keymap](https://wayland.app/protocols/wayland#wl_keyboard:event:keymap) event
     * of the Wayland protocol.
     *
     * @param rules Rules on how to interpret the other arguments. Can be NULL. [More information] (https://xkbcommon.org/doc/current/structxkb__rule__names.html#a0968f4602001f2306febd32c34bd2280).
     * @param model Keyboard model. Can be NULL. [More information] (https://xkbcommon.org/doc/current/structxkb__rule__names.html#a0968f4602001f2306febd32c34bd2280).
     * @param layout Keyboard layouts separated by comma (e.g. "latam"). Can be NULL. [More information] (https://xkbcommon.org/doc/current/structxkb__rule__names.html#a0968f4602001f2306febd32c34bd2280).
     * @param variant Variants of layouts. Can be NULL. [More information] (https://xkbcommon.org/doc/current/structxkb__rule__names.html#a0968f4602001f2306febd32c34bd2280).
     * @param options Preferences not related to layouts. Can be NULL. [More information] (https://xkbcommon.org/doc/current/structxkb__rule__names.html#a0968f4602001f2306febd32c34bd2280).
     */
    void setKeymap(const char *rules = NULL, const char *model = NULL, const char *layout = NULL, const char *variant = NULL, const char *options = NULL);

    /*!
     * @brief Assigns keyboard focus to a surface.
     *
     * Assigns the keyboard focus to the surface passed in the argument. The library automatically removes keyboard focus from the surface
     * that currently owns it (only one surface can have keyboard focus at a time).\n
     * Having keyboard focus is required for a surface to receive events sent with sendKeyEvent() and sendModifiersEvent().\n
     * Passing nullptr as argument removes the keyboard focus from all surfaces.\n
     * The library internally calls the [wl_keyboard::enter](https://wayland.app/protocols/wayland#wl_keyboard:event:enter) and 
     * [wl_keyboard::leave](https://wayland.app/protocols/wayland#wl_keyboard:event:leave) events of the Wayland protocol.
     */
    void setFocus(LSurface *surface);

    /*!
     * @brief Sends a key event to a client surface.
     *
     * Sends a key event to the surface with keyboard focus.\n
     * The library internally calls the [wl_keyboard::key](https://wayland.app/protocols/wayland#wl_keyboard:event:key) event of the Wayland protocol.
     * @param keyCode Key identifier (generated by the input backend).
     * @param keyState Key state (KeyState::Pressed or KeyState::Released).
     */
    void sendKeyEvent(UInt32 keyCode, UInt32 keyState);

    /*!
     * @brief Sends modifiers states.
     *
     * Sends modifiers states to the surface with keyboard focus.\n
     * The library internally calls the [wl_keyboard::modifiers](https://wayland.app/protocols/wayland#wl_keyboard:event:modifiers) event of the Wayland protocol.\n
     *
     * The parameters are equivalent to those described in KeyboardModifiersState.
     */
    void sendModifiersEvent(UInt32 depressed, UInt32 latched, UInt32 locked, UInt32 group);

    /*!
     * @brief Sends the current modifiers states.
     *
     * Sends the modifiers states to the surface with keyboard focus.\n
     * The library internally stores and updates the modifiers state, which can be accessed with modifiersState().\n
     * The library internally calls the [wl_keyboard::modifiers](https://wayland.app/protocols/wayland#wl_keyboard:event:modifiers) event of the Wayland protocol.\n
     */
    void sendModifiersEvent();

    /*!
     * @brief Notifies a change in the modifiers state.
     *
     * Override this virtual method if you want to be notified when the keyboard modifiers state changes.\n
     * The default implementation sends the updated modifiers state to the surface with keyboard focus.
     *
     * #### Default implementation
     * @snippet LKeyboardDefault.cpp keyModifiersEvent
     */
    virtual void keyModifiersEvent(UInt32 depressed, UInt32 latched, UInt32 locked, UInt32 group);

    /*!
     * @brief Notifies a key state change.
     *
     * Override this virtual method if you want to be notified when a key state changes.\n
     * The default implementation sends the key state to the surface with keyboard focus, sets the action of
     * drag & drop sessions, allows to start Weston-terminal perssing F1, raise or lower the system volume, and so on.
     *
     * #### Default implementation
     * @snippet LKeyboardDefault.cpp keyEvent
     */
    virtual void keyEvent(UInt32 keyCode, UInt32 keyState);

    LPRIVATE_IMP(LKeyboard)
};

#endif // LKEYBOARD_H
