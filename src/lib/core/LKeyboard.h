#ifndef LKEYBOARD_H
#define LKEYBOARD_H

#include <LKeyboardModifiersEvent.h>
#include <LObject.h>
#include <vector>
#include <xkbcommon/xkbcommon.h>
#include <linux/input-event-codes.h>

/**
 * @brief Class for handling keyboard events.
 *
 * The LKeyboard class lets you handle keyboard events generated by the input backend,
 * send them to clients, and configure parameters such as the keyboard map and key repeat rate.\n
 * There is a single instance of LKeyboard, which can be accessed from LSeat::keyboard().
 *
 * ### Wayland Events
 *
 * To send keyboard events to clients, you must first assign focus to a surface using setFocus().\n
 * Doing so, automatically removes focus from any previously focused surface.
 * As a result, all subsequent keyboard events sent with sendKeyEvent() or sendModifiersEvent() will be
 * directed to the currently focused surface.
 */
class Louvre::LKeyboard : public LObject
{
public:

    /**
     * @brief Constructor parameters.
     *
     * Configuration parameters passed in the LCompositor::createKeyboardRequest() virtual constructor.
     */
    struct Params;

    /**
     * @brief Constructor of the LKeyboard class.
     *
     * There is a single instance of LKeyboard, which can be accessed from LSeat::keyboard().
     *
     * @param params Internal library parameters passed in the LCompositor::createKeyboardRequest() virtual constructor.
     */
    LKeyboard(const void *params);

    /**
     * @brief Destructor of the LKeyboard class.
     *
     * Invoked internally by the library after LCompositor::destroyKeyboardRequest() is called.
     */
    virtual ~LKeyboard();

    /// @cond OMIT
    LKeyboard(const LKeyboard&) = delete;
    LKeyboard& operator= (const LKeyboard&) = delete;
    /// @endcond

    /**
     * @brief Set keyboard focus.
     *
     * This method assigns keyboard focus to the specified surface.
     * Only one surface can have keyboard focus at a time, and this method automatically removes focus from any previously focused surface.\n
     * To remove focus from all surfaces, pass `nullptr` as the argument.
     *
     * @note Calling this method while there is a surface grabbing the keyboard is a no-op.
     */
    void setFocus(LSurface *surface);

    /**
     * @brief Surface with keyboard focus.
     *
     * Pointer to the surface with keyboard focus assigned with setFocus().
     * Only surfaces with keyboard focus can receive keyboard events.
     *
     * @returns `nullptr` if no surface has keyboard focus.
     */
    LSurface *focus() const;

    /**
     * @brief Set the surface that grabs keyboard events.
     *
     * TODO: Update doc
     *
     * This method redirects all keyboard events to the given surface, preventing other surfaces from gain focus with setFocus().\n
     * If the surface grabbing the keyboard is destroyed the grab is automatically assigned to its parent.\n
     * For example, an LPopupRole can request to make a keyboard grab with LPopupRole::grabSeatRequest().
     *
     * If 'surface' is set to `nullptr`, the keyboard grab is disabled.
     *
     * @param surface The surface that will grab the keyboard events or `nullptr` to disable it.
     * @param keyboardResource The specific `wl_keyboard` resource created by the client to which events must be sent.
     */
    void setGrab(LSurface* surface);

    /**
     * @brief Get the current surface that is grabbing the keyboard events.
     *
     * This method returns the surface that is currently grabbing the keyboard events.
     * If no grab is active, it returns `nullptr`.
     *
     * @returns The surface that is grabbing keyboard events, or `nullptr` if no grab is active.
     */
    LSurface* grab() const;

    /**
     * @brief Current keyboard modifiers state.
     *
     * @returns An instance of LKeyboardModifiersEvent::Modifiers, which stores the state of the keyboard modifiers.
     */
    const LKeyboardModifiersEvent::Modifiers &modifiers() const;

    /**
     * @brief Keyboard map file descriptor.
     *
     * File descriptor of the XKB keyboard map assigned with setKeymap().
     */
    Int32 keymapFd() const;

    /**
     * @brief Size of the keyboard map in bytes.
     *
     * Size in bytes of the XKB keyboard map loaded with setKeymap().
     */
    Int32 keymapSize() const;

    /**
     * @brief Keymap format.
     *
     * The keymap format can be either `WL_KEYBOARD_KEYMAP_FORMAT_XKB_V1`,
     * which indicates the presence of a valid XKB keymap set, or `WL_KEYBOARD_KEYMAP_FORMAT_NO_KEYMAP`,
     * indicating an issue with the XKB system configuration.
     */
    UInt32 keymapFormat() const;

    // Since 4

    /**
     * @brief Repetition rate.
     *
     * Number of repetitions per second of a key when held down, assigned with setRepeatInfo().
     *
     * The default value is 32 repetitions per second.
     */
    Int32 repeatRate() const;

    /**
     * @brief Repetition delay.
     *
     * Delay in milliseconds before triggering the repetition of a key by holding it down, set with setRepeatInfo().
     *
     * The default value is 500 ms.
     */
    Int32 repeatDelay() const;

    /**
     * @brief Set the key repeat rate and delay.
     *
     * Assigns the repeat rate and delay when holding down a key.
     *
     * @note This impacts how clients respond to a key being held down.
     *
     * @param rate Number of repetitions per second. 0 turns off repetition.
     * @param msDelay Delay in milliseconds before triggering the replay.
     */
    void setRepeatInfo(Int32 rate, Int32 msDelay);

    /**
     * @brief Key symbol.
     *
     * Returns the symbol of a raw key code generated by the input backend according to the status of the keyboard map.\n
     *
     * The complete list of symbols can be found in [`<xkbcommon/xkbcommon-keysyms.h>`](https://github.com/xkbcommon/libxkbcommon/blob/master/include/xkbcommon/xkbcommon-keysyms.h).
     */
    xkb_keysym_t keySymbol(UInt32 keyCode);

    /**
     * @brief Keyboard state.
     *
     * XKB keyboard map state.
     */
    xkb_state *keymapState() const;

    /**
     * @brief Check the state of a modifier.
     *
     * @param name Modifier name defined in `<xkbcommon/xkbcommon_names.h>` such as `XKB_MOD_NAME_SHIFT`, `XKB_LED_NAME_CAPS`, etc.
     * @param type In XKB, the `XKB_STATE_MODS_DEPRESSED`, `XKB_STATE_MODS_LATCHED`, `XKB_STATE_MODS_LOCKED`, and `XKB_STATE_MODS_EFFECTIVE` are flags used to represent different aspects of the keyboard modifier keys' states.
     *
     * **XKB_STATE_MODS_DEPRESSED:** This flag represents the currently depressed (pressed down) modifiers. When a modifier key is pressed, it falls into the depressed state. This flag helps identify which modifiers are currently held down.
     *
     * **XKB_STATE_MODS_LATCHED:** This flag represents modifiers that are latched. A latched modifier is one that will be activated with the next non-modifier key press. Once the latched modifier is used, it returns to its original state.
     *
     * **XKB_STATE_MODS_LOCKED:** This flag represents modifiers that are locked. When a modifier is locked, it stays active until explicitly unlocked. For example, if Caps Lock is activated, the Caps Lock state is locked until Caps Lock is pressed again.
     *
     * **XKB_STATE_MODS_EFFECTIVE:** This flag represents the effective state of the modifiers. It takes into account the depressed, latched, and locked states to provide a combined view of the current modifier key states.
     *
     * @returns `true` if the modifier is active and `false` otherwise.
     */
    bool isModActive(const char *, xkb_state_component type) const;

    /**
     * @brief Vector of pressed key codes.
     */
    const std::vector<UInt32> &pressedKeys() const;

    /**
     * @brief Check if a key code is pressed.
     */
    bool isKeyCodePressed(UInt32 keyCode) const;

    /**
     * @brief Check if a key symbol is pressed.
     */
    bool isKeySymbolPressed(xkb_keysym_t keySymbol) const;

    /**
     * @brief Set the keyboard map.
     *
     * This method finds and assigns a keyboard map that matches the parameters passed in the arguments.\n
     * The keyboard map is automatically sent to clients when they connect to the compositor and use the [wl_keyboard](https://wayland.app/protocols/wayland#wl_keyboard) interface
     * of the Wayland protocol. If a client is already connected, the library re-sends it the new keyboard map.\n
     * The library by default assigns the "latam" layout in LCompositor::initialized().\n
     *
     * @param rules Rules on how to interpret the other arguments. Can be `nullptr`. [More information] (https://xkbcommon.org/doc/current/structxkb__rule__names.html#a0968f4602001f2306febd32c34bd2280).
     * @param model Keyboard model. Can be `nullptr`. [More information] (https://xkbcommon.org/doc/current/structxkb__rule__names.html#a0968f4602001f2306febd32c34bd2280).
     * @param layout Keyboard layouts separated by comma (e.g. "latam"). Can be `nullptr`. [More information] (https://xkbcommon.org/doc/current/structxkb__rule__names.html#a0968f4602001f2306febd32c34bd2280).
     * @param variant Variants of layouts. Can be `nullptr`. [More information] (https://xkbcommon.org/doc/current/structxkb__rule__names.html#a0968f4602001f2306febd32c34bd2280).
     * @param options Preferences not related to layouts. Can be `nullptr`. [More information] (https://xkbcommon.org/doc/current/structxkb__rule__names.html#a0968f4602001f2306febd32c34bd2280).
     */
    bool setKeymap(const char *rules = nullptr, const char *model = nullptr, const char *layout = nullptr, const char *variant = nullptr, const char *options = nullptr);

    /**
     * @brief Send a key event.
     *
     * Sends a key event to the currently focused surface.
     *
     * @param keyCode Raw key code generated by the input backend.
     * @param keyState Key state (LKeyboard::Pressed or LKeyboard::Released).
     */
    void sendKeyEvent(const LKeyboardKeyEvent &event);

    /**
     * @brief Notifies a key state change.
     *
     * Override this virtual method if you want to handle key press/release events.
     *
     * #### Default implementation
     * @snippet LKeyboardDefault.cpp keyEvent
     */
    virtual void keyEvent(const LKeyboardKeyEvent &event);

    /**
     * @brief Notifies that the focused surface changed.
     *
     * This event is triggered when the focus() property changes, either through the use of setFocus()
     * or when the current focused surface is destroyed.
     *
     * @see setFocus()
     * @see focus()
     *
     * #### Default Implementation
     * @snippet LKeyboardDefault.cpp focusChanged
     */
    virtual void focusChanged();

    LPRIVATE_IMP_UNIQUE(LKeyboard)
};

#endif // LKEYBOARD_H
