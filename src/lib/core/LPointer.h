#ifndef LPOINTER_H
#define LPOINTER_H

#include <LObject.h>
#include <LPoint.h>
#include <LToplevelRole.h>
#include <linux/input-event-codes.h>
#include <limits>
#include <vector>

/**
 * @brief Class for handling events generated by pointing devices.
 *
 * The LPointer class allows you to handle pointer events generated by devices such as a mouse or touchpad.\n
 * It provides utility methods for interactive tasks like moving and resizing toplevel surfaces, sending pointer events to client surfaces, and more.\n
 * There is always a single instance of LPointer, which can be accessed through LSeat::pointer().
 *
 * ### Wayland Events
 *
 * To send pointer events to clients, you must first assign focus to a surface using one of the setFocus() variants.\n
 * This action automatically removes focus from any previously focused surface.
 * Subsequently, all pointer events are directed to the currently focused surface.
 */
class Louvre::LPointer : public LObject
{
public:
    /**
     * @brief Constructor parameters.
     *
     * Configuration parameters provided in the virtual LCompositor::createPointerRequest() virtual constructor.
     */
    struct Params;

    /**
     * @brief Pointer buttons.
     *
     * Enumeration of common pointer buttons.
     *
     * You can find the complete list of pointer button codes in the [`<linux/input-event-codes.h>`](https://github.com/torvalds/linux/blob/master/include/uapi/linux/input-event-codes.h) header.
     */
    enum Button : UInt32
    {
        /// Left button
        Left = BTN_LEFT,

        /// Right button
        Right = BTN_RIGHT,

        /// Middle button
        Middle = BTN_MIDDLE,

        /// Side button
        Side = BTN_SIDE,

        /// Extra button
        Extra = BTN_EXTRA,

        /// Forward button
        Forward = BTN_FORWARD,

        /// Back button
        Back = BTN_BACK,

        /// Task button
        Task = BTN_TASK
    };

    /**
     * @brief Pointer button states.
     *
     * Possible states of a pointer button.
     */
    enum ButtonState : UInt32
    {
        /// Button released
        Released = 0,

        /// Button pressed
        Pressed = 1
    };

    /**
     * @brief Source of a scroll event
     *
     * Possible sources of a scroll event.
     */
    enum AxisSource : UInt32
    {
        /// Mouse wheel (discrete)
        Wheel = 0,

        /// Trackpad swipe (continuous)
        Finger = 1,

        /// Continuous movement (with unspecified source)
        Continuous = 2,

        /// Side movement of a mouse wheel (since 6)
        WheelTilt = 3
    };

    /**
     * @brief Edge constraint when resizing a Toplevel
     */
    enum ResizeEdgeSize : Int32
    {
        /// Disables the constraint on the specified edge.
        EdgeDisabled = std::numeric_limits<Int32>::min()
    };

    /**
     * @brief LPointer class constructor.
     *
     * There is a single instance of LPointer, which can be accessed from LSeat::pointer().
     *
     * @param params Internal library parameters provided in the LCompositor::createPointerRequest() virtual constructor.
     */
    LPointer(Params *params);

    /**
     * @brief LPointer class destructor.
     *
     * Invoked internally by the library after notification of its destruction with LCompositor::destroyPointerRequest().
     */
    virtual ~LPointer();

    /// @cond OMIT
    LPointer(const LPointer&) = delete;
    LPointer& operator= (const LPointer&) = delete;
    /// @endcond

    /**
     * @brief Get the surface with pointer focus.
     *
     * This method returns the surface that has been assigned pointer focus using setFocus().\n
     * Only surfaces with pointer focus can receive pointer events.
     *
     * @return A pointer to the focused surface, or `nullptr` if no surface has pointer focus.
     */
    LSurface *focus() const;

    /**
     * @brief Set the pointer focus to a specific surface.
     *
     * This method assigns the pointer focus to the specified surface at the given local surface position within the surface.\n
     * If a surface already had pointer focus, it will lose it.
     *
     * Passing `nullptr` removes pointer focus from all surfaces.
     *
     * @param surface Surface to which the pointer focus will be assigned, or `nullptr` to remove focus from all surfaces.
     * @param localPos Local position within the surface where the pointer enters.
     */
    void setFocus(LSurface *surface, const LPoint &localPos);

    /**
     * @brief Set the pointer focus to a specific surface.
     *
     * This method sets the pointer focus to the provided surface based on the current LCursor position.\n
     * If a surface already had pointer focus, it will lose it.
     *
     * Passing `nullptr` removes pointer focus from all surfaces.
     *
     * @note This method internally transforms the LCursor position to the local coordinates of the focused surface,
     *       taking into account the surface's role position.
     *
     * @param surface The surface to which you want to assign the pointer focus or `nullptr` to remove focus from all surfaces.
     */
    void setFocus(LSurface *surface);

    /**
     * @brief Keep track of the surface pressed by the left pointer button.
     *
     * This is just a utility method used by the default LPointer implementation to ensure that pointer focus remains
     * on a surface while it's being actively pressed by the left pointer button, for example, during text selection, even
     * if the pointer moves outside the surface boundaries.\n
     * The draggingSurface() property is automatically set to `nullptr` if the given surface is destroyed.
     *
     * @note This method is unrelated to drag & drop sessions.
     *
     * @param surface The surface being pressed or `nullptr` to unset.
     *
     * @see draggingSurface()
     */
    void setDraggingSurface(LSurface *surface);

    /**
     * @brief Surface being actively pressed by the left pointer button.
     *
     * This method returns the surface that is currently being actively pressed by the left pointer button.
     * It is set using the setDraggingSurface() utility method to ensure that pointer focus remains on the surface
     * even if the pointer moves outside its boundaries during interaction.
     *
     * @returns The surface being pressed or `nullptr`.
     *
     * @see setDraggingSurface()
     */
    LSurface *draggingSurface() const;

    /**
     * @brief Look for a surface.
     *
     * This method looks for the first mapped surface that contains the point given by the `point` parameter.\n
     * It takes into account the surfaces role position (LSurface::rolePos()), their input region (LSurface::inputRegion()) and the order
     * given by the list of surfaces of the compositor (LCompositor::surfaces()).\n
     * Some surface roles do not have an input region such as LCursorRole or LDNDIconRole so these surfaces are always ignored.
     *
     * @param point Point in compositor coordinates.
     * @returns Returns the first surface that contains the point or `nullptr` if no surface is found.
     */
    LSurface *surfaceAt(const LPoint &point);

    /**
     * @brief Retrieve the last LCursorRole provided in the most recent setCursorRequest() call.
     *
     * If the cursor role has been destroyed or if a client has requested to hide the cursor, this method returns `nullptr`.
     *
     * @return A pointer to the last LCursorRole, or `nullptr` if the cursor role has been destroyed or the client requested to hide the cursor.
     *
     * @note To distinguish whether the last cursor was destroyed or the request was to hide it, use the lastCursorRequestWasHide() method.
     */
    LCursorRole *lastCursorRequest() const;

    /**
     * @brief Determine if the intention of the most recent setCursorRequest() was to hide the cursor.
     *
     * This method returns `true` if the most recent setCursorRequest() was intended to hide the cursor; otherwise, it returns `false`.
     *
     * @return `true` if the last cursor request was to hide the cursor; otherwise, `false`.
     */
    bool lastCursorRequestWasHide() const;

    /**
     * @brief Close all popups.
     *
     * This method closes all active Popup surfaces in reverse order of creation.
     *
     * @see LPopupRole::sendPopupDoneEvent()
     */
    void dismissPopups();

    /**
     * @brief Vector of pressed buttons.
     */
    const std::vector<Button> &pressedKeys() const;

    /**
     * @brief Check if a button is pressed.
     */
    bool isButtonPressed(Button button) const;

    /**
     * @name Client Events
     *
     * These methods allow you to send pointer events to clients.
     *
     * @note Pointer events are sent to the currently focused surface set with setFocus(). If no surface has focus, calling these methods has no effect.
     */

///@{

    /**
     * @brief Send a pointer move event to the surface with focus.
     *
     * This method sends the current pointer position to the surface with pointer focus.\n
     *
     * @note This method internally transforms the LCursor position to the local coordinates of the focused surface,
     *       taking into account the surface's role position.
     */
    void sendMoveEvent();

    /**
     * @brief Send a pointer move event to the surface with focus.
     *
     * This method sends the current pointer position, provided as 'localPos', to the surface with pointer focus.
     *
     * @param localPos Pointer position relative to the top-left corner of the surface in surface coordinates.
     */
    void sendMoveEvent(const LPoint &localPos);

    /**
     * @brief Send a pointer button event to the surface with focus.
     *
     * This method sends a pointer button event with the specified 'button' code and 'state' to the surface currently in focus.
     *
     * @param button Button code.
     * @param state State of the button.
     */
    void sendButtonEvent(Button button, ButtonState state);

    /**
     * @brief Send a scroll event to the focused surface.
     *
     * This method sends a scroll event to the currently focused surface.
     *
     * @param axisX The horizontal continous scroll axis value.
     * @param axisY The vertical continous scroll axis value.
     * @param discreteX The discrete horizontal scroll value.
     * @param discreteY The discrete vertical scroll value.
     * @param source The source of the scroll event (one of the values from LPointer::AxisSource).
     */
    void sendAxisEvent(Float64 axisX, Float64 axisY, Int32 discreteX, Int32 discreteY, AxisSource source);

///@}

    /**
     * @name Interactive Toplevel Resizing
     *
     * These utility methods simplify the management of interactive toplevel resizing sessions.
     *
     * @note Using these methods is optional.
     *
     * @see LToplevelRole::startResizeRequest()
     * @see LToplevelRole::geometryChanged()
     */

///@{

    /**
     * @brief Start an interactive toplevel resizing session.
     *
     * This method starts an interactive resizing session on a toplevel surface from one of its edges or corners.\n
     * You can restrict the space in which the surface expands by defining a rectangle given by the L, T, R, and B values.\n
     * If you do not want to restrict an edge, assign its value to LPointer::EdgeDisabled.
     *
     * To update the position and size of the Toplevel, call updateResizingToplevelSize() when the pointer moves and
     * updateResizingToplevelPos() when the toplevel size changes.\n
     * Once finished, call stopResizingToplevel() to end the session.
     *
     * @note The session will automatically cease if the toplevel is destroyed.
     *
     * @see See an example of its use in LToplevelRole::startResizeRequest().
     *
     * @param toplevel Toplevel that will change size.
     * @param edge Edge or corner from which the resizing will be performed.
     * @param pointerPos Current pointer position.
     * @param minSize Minimum toplevel size.
     * @param L Restriction of the left edge.
     * @param T Restriction of the top edge.
     * @param R Restriction of the right edge.
     * @param B Restriction of the bottom edge.
     */
    void startResizingToplevel(LToplevelRole *toplevel,
                               LToplevelRole::ResizeEdge edge,
                               const LPoint &pointerPos,
                               const LSize &minSize = LSize(0, 0),
                               Int32 L = EdgeDisabled, Int32 T = EdgeDisabled,
                               Int32 R = EdgeDisabled, Int32 B = EdgeDisabled);

    /**
     * @brief Update the size of a toplevel during an interactive resizing session.
     *
     * This method should be called each time the pointer position changes.
     *
     * @param pointerPos Current pointer position.
     *
     * @see See an example of its use in the default implementation of pointerPosChangeEvent().
     */
    void updateResizingToplevelSize(const LPoint &pointerPos);

    /**
     * @brief Update the position of a toplevel during an interactive resizing session.
     *
     * This method should be called each time the toplevel size changes.
     *
     * @see See an example of its use in the default implementation of LToplevelRole::geometryChanged().
     */
    void updateResizingToplevelPos();

    /**
     * @brief End an interactive toplevel resizing session.
     *
     * This method is used to end the resizing session. Should be used for example when releasing the left pointer button.
     *
     * @see See an example of its use in the default implementation of pointerButtonEvent().
     */
    void stopResizingToplevel();

    /**
     * @brief Get the current toplevel in an interactive resizing session.
     *
     * @return A pointer to the current toplevel being resized, or `nullptr` if there is no active resizing session.
     */
    LToplevelRole *resizingToplevel() const;

///@}

    /**
     * @name Interactive toplevel Movement
     *
     * These utility methods simplify the management of interactive toplevel moving sessions.
     *
     * @note Using these methods is optional.
     *
     * @see LToplevelRole::startMoveRequest()
     */

///@{

    /**
     * @brief Initiate an interactive toplevel moving session.
     *
     * This method initiates an interactive moving session for a toplevel surface.\n
     * You can confine the Toplevel's placement within a rectangle by specifying values for L, T, R, and B.\n
     * If you don't wish to restrict any edges, set their values to LPointer::EdgeDisabled.
     *
     * To update the Toplevel's position, use the updateMovingToplevelPos() method.
     * Once the position change is complete, use the stopMovingToplevel() method to conclude the session.
     *
     * @note The session will automatically cease if the toplevel is destroyed.
     *
     * @see See an example of its use in LToplevelRole::startMoveRequest().
     *
     * @param toplevel The toplevel whose size will change.
     * @param pointerPos Current pointer position.
     * @param L Restriction for the left edge.
     * @param T Restriction for the top edge.
     * @param R Restriction for the right edge.
     * @param B Restriction for the bottom edge.
     */
    void startMovingToplevel(LToplevelRole *toplevel,
                             const LPoint &pointerPos,
                             Int32 L = EdgeDisabled, Int32 T = EdgeDisabled,
                             Int32 R = EdgeDisabled, Int32 B = EdgeDisabled);

    /**
     * @brief Update the position of a toplevel during an interactive moving session.
     *
     * Call this method when the pointer position changes.
     *
     * @see See an example of its usage in the default implementation of pointerPosChangeEvent().
     *
     * @param pointerPos The current pointer position.
     */
    void updateMovingToplevelPos(const LPoint &pointerPos);

     /**
     * @brief Conclude an interactive moving session.
     *
     * Use this method to conclude a moving toplevel session, for example, when releasing the left pointer button.
     *
     * @see See an example of its usage in the default implementation of pointerButtonEvent().
     */
    void stopMovingToplevel();

    /**
     * @brief Get the toplevel surface involved in an interactive moving session.
     *
     * @return A pointer to the toplevel surface, or `nullptr` if there is no ongoing interactive moving session.
     */
    LToplevelRole *movingToplevel() const;

    /**
     * @brief Retrieve the initial position of a toplevel during an interactive moving session.
     *
     * This method provides the initial position of a toplevel surface when an interactive moving session begins.
     */
    const LPoint &movingToplevelInitPos() const;

    /**
     * @brief Retrieve the initial pointer position during a toplevel interactive moving session.
     *
     * This method provides the initial pointer position when an interactive moving session of a toplevel surface starts.
     */
    const LPoint &movingToplevelInitPointerPos() const;

///@}

    /**
     * @name Virtual Methods
     */

///@{

    /**
     * @brief Pointer move event.
     *
     * This virtual method notifies of pointer movement generated by the input backend.\n
     * Override this virtual method if you need to be informed when the pointer changes its position.
     *
     * @param x The x-component of the new pointer position or delta from its previous position.
     * @param y The y-component of the new pointer position or delta from its previous position.
     * @param absolute If `true`, the (x, y) values represent absolute coordinates; if `false`, they are deltas from the previous position.
     *
     * #### Default Implementation
     * @snippet LPointerDefault.cpp pointerMoveEvent
     */
    virtual void pointerMoveEvent(Float32 x, Float32 y, bool absolute);

    /**
     * @brief Pointer button event.
     *
     * This virtual method notifies of a change in the state of a pointer button generated by the input backend.\n
     * Override this virtual method if you need to be informed when a pointer button changes its state.
     *
     * @param button The code of the pressed button.
     * @param state The state of the button (LPointer::Pressed or LPointer::Released).
     *
     * #### Default Implementation
     * @snippet LPointerDefault.cpp pointerButtonEvent
     */
    virtual void pointerButtonEvent(Button button, ButtonState state);

    /**
     * @brief Pointer scroll event.
     *
     * This virtual method notifies about a pointer scroll event generated by the input backend.\n
     * Override this virtual method if you need to handle scroll events.
     *
     * @param axisX The direction and magnitude of the scroll on the x component.
     * @param axisY The direction and magnitude of the scroll on the y component.
     * @param discreteX The discrete scroll step on the x component.
     * @param discreteY The discrete scroll step on the y component.
     * @param source The source of the event.
     *
     * #### Default Implementation
     * @snippet LPointerDefault.cpp pointerAxisEvent
     */
    virtual void pointerAxisEvent(Float64 axisX, Float64 axisY, Int32 discreteX, Int32 discreteY, AxisSource source);

    /**
     * @brief Set cursor request.
     *
     * This virtual method is triggered when a client requests to set the cursor texture and hotspot or hide it.\n
     * If you want to assign the cursor texture as requested by the client, override this method.
     *
     * @note Only clients with a focused surface can request to set the cursor texture.
     *
     * @param cursorRole Surface role to use as a cursor. If it is `nullptr`, it indicates that the client wants to hide the cursor.
     *
     * @see lastCursorRequest()
     * @see lastCursorRequestWasHide()
     *
     * #### Default Implementation
     * @snippet LPointerDefault.cpp setCursorRequest
     */
    virtual void setCursorRequest(LCursorRole *cursorRole);

///@}

    LPRIVATE_IMP_UNIQUE(LPointer)
};

#endif // LPOINTER_H
