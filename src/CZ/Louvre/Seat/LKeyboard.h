#ifndef LKEYBOARD_H
#define LKEYBOARD_H

#include <CZ/Louvre/LFactoryObject.h>
#include <CZ/Core/Events/CZKeyboardModifiersEvent.h>
#include <CZ/Core/CZLogger.h>
#include <unordered_set>
#include <xkbcommon/xkbcommon.h>
#include <linux/input-event-codes.h>
#include <memory>
#include <vector>

/**
 * @brief Class for handling keyboard events.
 *
 * @anchor lkeyboard_detailed
 *
 * The LKeyboard class lets you handle keyboard events generated by the input backend,
 * redirect them to clients, and configure parameters such as the keyboard map and key repeat rate.\n
 * There is a single instance of LKeyboard, which can be accessed from LSeat::keyboard().
 *
 * ### Wayland Events
 *
 * To send keyboard events to clients, you must first assign focus to a surface using setFocus()
 * and then all subsequent keyboard events sent with sendKeyEvent() will be directed to that surface.
 */
class CZ::LKeyboard : public LFactoryObject
{
public:

    static constexpr LFactoryObject::Type FactoryObjectType = LFactoryObject::Type::LKeyboard;

    /**
     * @brief Constructor of the LKeyboard class.
     *
     * There is a single instance of LKeyboard, which can be accessed from LSeat::keyboard().
     *
     * @param params Internal parameters provided in LCompositor::createObjectRequest().
     */
    LKeyboard(const void *params) noexcept;

    /**
     * @brief Destructor of the LKeyboard class.
     *
     * Invoked after LCompositor::onAnticipatedObjectDestruction().
     */
    ~LKeyboard() noexcept;

    /**
     * @brief Set keyboard focus.
     *
     * This method assigns keyboard focus to the specified surface.
     * Only one surface can have keyboard focus at a time, and this method automatically removes focus from any previously focused surface.\n
     * To remove focus from all surfaces, pass `nullptr` as the argument.
     *
     * @note Calling this method while there is a surface grabbing the keyboard is a no-op.
     */
    void setFocus(LSurface *surface);

    /**
     * @brief Focused surface.
     *
     * @see setFocus().
     *
     * @returns The focused surface or `nullptr` if no surface has keyboard focus.
     */
    LSurface *focus() const noexcept;

    /**
     * @brief Sets a keyboard grab.
     *
     * Setting a keyboard grab prevents other surfaces from gain focus with setFocus().\n
     * If the surface grabbing the keyboard is destroyed the grab is automatically assigned to its parent or unset
     * if it has no parent.\n
     * For example, an LPopupRole can request to make a keyboard grab with LPopupRole::grabKeyboardRequest().
     *
     * If 'surface' is set to `nullptr`, the keyboard grab is unset.
     *
     * @param surface The surface that will grab the keyboard events or `nullptr` to disable it.
     */
    void setGrab(LSurface* surface) noexcept;

    /**
     * @brief Gets the grab surface.
     *
     * @see setGrab()
     *
     * @returns The grabbing surface, or `nullptr` if unset.
     */
    LSurface *grab() const noexcept;

    /**
     * @brief The current keymap or nullptr if none.
     */
    std::shared_ptr<CZKeymap> keymap() const noexcept;

    /**
     * @brief Replaces the current keymap.
     *
     * The keymap is automatically sent to clients when they bind to the the [wl_keyboard](https://wayland.app/protocols/wayland#wl_keyboard) interface.
     * If a client is already connected, Louvre re-sends it the new one.
     *
     * @returns true on success, false if unchanged.
     */
    bool setKeymap(const char *rules = nullptr, const char *model = nullptr, const char *layout = nullptr, const char *variant = nullptr, const char *options = nullptr) noexcept;

    /**
     * @brief Repetition rate.
     *
     * Number of repetitions per second of a key when held down, assigned with setRepeatInfo().
     *
     * The default value is 32 repetitions per second.
     */
    Int32 repeatRate() const noexcept;

    /**
     * @brief Repetition delay.
     *
     * Delay in milliseconds before triggering the repetition of a key by holding it down, set with setRepeatInfo().
     *
     *
     * The default value is 500 ms.
     */
    Int32 repeatDelay() const noexcept;

    /**
     * @brief Set the key repeat rate and delay.
     *
     * Assigns the repeat rate and delay when holding down a key.
     *
     * @note This impacts how clients respond to a key being held down.
     *
     * @param rate Number of repetitions per second. 0 turns off repetition.
     * @param msDelay Delay in milliseconds before triggering the replay.
     */
    void setRepeatInfo(Int32 rate, Int32 msDelay) noexcept;

    /**
     * @brief Key symbol.
     *
     * Returns the symbol of a raw key code generated by the input backend according to the current keymap state.
     *
     * The complete list of symbols can be found in [`<xkbcommon/xkbcommon-keysyms.h>`](https://github.com/xkbcommon/libxkbcommon/blob/master/include/xkbcommon/xkbcommon-keysyms.h).
     */
    xkb_keysym_t keySymbol(UInt32 keyCode) noexcept;

    /**
     * @brief Checks the state of a modifier.
     *
     * @param name Modifier name defined in `<xkbcommon/xkbcommon_names.h>` such as `XKB_MOD_NAME_SHIFT`, `XKB_LED_NAME_CAPS`, etc.
     * @param type In XKB, the `XKB_STATE_MODS_DEPRESSED`, `XKB_STATE_MODS_LATCHED`, `XKB_STATE_MODS_LOCKED`, and `XKB_STATE_MODS_EFFECTIVE` are flags used to represent different aspects of the keyboard modifier keys' states.
     *
     * **XKB_STATE_MODS_DEPRESSED:** This flag represents the currently depressed (pressed down) modifiers. When a modifier key is pressed, it falls into the depressed state. This flag helps identify which modifiers are currently held down.
     *
     * **XKB_STATE_MODS_LATCHED:** This flag represents modifiers that are latched. A latched modifier is one that will be activated with the next non-modifier key press. Once the latched modifier is used, it returns to its original state.
     *
     * **XKB_STATE_MODS_LOCKED:** This flag represents modifiers that are locked. When a modifier is locked, it stays active until explicitly unlocked. For example, if Caps Lock is activated, the Caps Lock state is locked until Caps Lock is pressed again.
     *
     * **XKB_STATE_MODS_EFFECTIVE:** This flag represents the effective state of the modifiers. It takes into account the depressed, latched, and locked states to provide a combined view of the current modifier key states.
     *
     * @returns `true` if the modifier is active and `false` otherwise.
     */
    bool isModActive(const char *name, xkb_state_component type) const noexcept;

    /**
     * @brief Checks if a key code is pressed.
     */
    bool isKeyCodePressed(UInt32 keyCode) const noexcept;

    /**
     * @brief Check if a key symbol is pressed.
     */
    bool isKeySymbolPressed(xkb_keysym_t keySymbol) const noexcept;

    /**
     * @brief Sends a key event to the currently focused surface.
     *
     * @see setFocus() and setGrab().
     */
    void sendKeyEvent(const CZKeyboardKeyEvent &event) noexcept;

    /**
     * @name Virtual Methods
     */

    ///@{

    /**
     * @brief Keyboard key event generated by the input backend.
     *
     * #### Default implementation
     * @snippet LKeyboardDefault.cpp keyEvent
     */
    virtual void keyEvent(const CZKeyboardKeyEvent &event);

    /**
     * @brief Notifies when the focused surface changes.
     *
     * This method is triggered whenever the focus() property changes, either by
     * calling setFocus() or when the currently focused surface is destroyed.
     * 
     * @warning Changing the focused surface within this event using setFocus()
     *          may result in an infinite feedback loop if not managed carefully.
     * 
     * #### Default Implementation
     * @snippet LKeyboardDefault.cpp focusChanged
     */
    virtual void focusChanged();
    virtual void handleTTYSwitchShortcut(const CZKeyboardKeyEvent &e) noexcept;
    virtual void updateKeymapState(const CZKeyboardKeyEvent &e) noexcept;
    virtual bool event(const CZEvent &e) noexcept override;

    ///@}

    CZLogger log;

    LPRIVATE_IMP_UNIQUE(LKeyboard)
};

#endif // LKEYBOARD_H
